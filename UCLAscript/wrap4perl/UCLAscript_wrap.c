/* ----------------------------------------------------------------------------
 * This file was automatically generated by SWIG (http://www.swig.org).
 * Version 1.3u-20001008-0201 (Alpha 5)
 * 
 * This file is not intended to be easily readable and contains a number of 
 * coding conventions designed to improve portability and efficiency. Do not make
 * changes to this file unless you know what you are doing--modify the SWIG 
 * interface file instead. 
 * ----------------------------------------------------------------------------- */

/***********************************************************************
 * common.swg
 *
 *     This file contains generic SWIG runtime support for pointer
 *     type checking as well as a few commonly used macros to control
 *     external linkage.
 *
 * Author : David Beazley (beazley@cs.uchicago.edu)
 *
 * Copyright (c) 1999-2000, The University of Chicago
 * 
 * This file may be freely redistributed without license or fee provided
 * this copyright message remains intact.
 ************************************************************************/

#include <string.h>

#if defined(_WIN32) || defined(__WIN32__)
#       if defined(_MSC_VER)
#               if defined(STATIC_LINKED)
#                       define SWIGEXPORT(a) a
#               else
#                       define SWIGEXPORT(a) __declspec(dllexport) a
#               endif
#       else
#               if defined(__BORLANDC__)
#                       define SWIGEXPORT(a) a _export
#               else
#                       define SWIGEXPORT(a) a
#       endif
#endif
#else
#       define SWIGEXPORT(a) a
#endif

#ifdef SWIG_GLOBAL
#define SWIGRUNTIME(a) SWIGEXPORT(a)
#else
#define SWIGRUNTIME(a) static a
#endif

#ifdef __cplusplus
#include <iostream>
extern "C" {
#endif

typedef struct swig_type_info {
  char  *name;                 
  void *(*converter)(void *);
  char  *str;
  struct swig_type_info  *next;
  struct swig_type_info  *prev;
} swig_type_info;

#ifdef SWIG_NOINCLUDE
SWIGEXPORT(swig_type_info *) SWIG_TypeRegister(swig_type_info *);
SWIGEXPORT(swig_type_info *) SWIG_TypeCheck(char *c, swig_type_info *);
SWIGEXPORT(void *) SWIG_TypeCast(swig_type_info *, void *);
#else

static swig_type_info *swig_type_list = 0;

/* Register a type mapping with the type-checking */
SWIGRUNTIME(swig_type_info *)
SWIG_TypeRegister(swig_type_info *ti)
{
  swig_type_info *tc, *head, *ret, *next;
  /* Check to see if this type has already been registered */
  tc = swig_type_list;
  while (tc) {
    if (strcmp(tc->name, ti->name) == 0) {
      /* Already exists in the table.  Just add additional types to the list */
      head = tc;
      next = tc->next;
      goto l1;
    }
    tc = tc->prev;
  }
  head = ti;
  next = 0;

  /* Place in list */
  ti->prev = swig_type_list;
  swig_type_list = ti;

  /* Build linked lists */
 l1:
  ret = head;
  tc = ti + 1;
  /* Patch up the rest of the links */
  while (tc->name) {
    head->next = tc;
    tc->prev = head;
    head = tc;
    tc++;
  }
  head->next = next;
  return ret;
}

/* Check the typename */
SWIGRUNTIME(swig_type_info *) 
SWIG_TypeCheck(char *c, swig_type_info *ty)
{
  swig_type_info *s;
  if (!ty) return 0;        /* Void pointer */
  s = ty->next;             /* First element always just a name */
  while (s) {
    if (strcmp(s->name,c) == 0) {
      if (s == ty->next) return s;
      /* Move s to the top of the linked list */
      s->prev->next = s->next;
      if (s->next) {
	s->next->prev = s->prev;
      }
      /* Insert s as second element in the list */
      s->next = ty->next;
      if (ty->next) ty->next->prev = s;
      ty->next = s;
      return s;
    }
    s = s->next;
  }
  return 0;
}

/* Cast a pointer (needed for C++ inheritance */
SWIGRUNTIME(void *) 
SWIG_TypeCast(swig_type_info *ty, void *ptr) 
{
  if ((!ty) || (!ty->converter)) return ptr;
  return (*ty->converter)(ptr);
}

/* Search for a swig_type_info structure */
SWIGRUNTIME(void *)
SWIG_TypeQuery(const char *name) {
  swig_type_info *ty = swig_type_list;
  while (ty) {
    if (ty->str && (strcmp(name,ty->str) == 0)) return ty;
    if (ty->name && (strcmp(name,ty->name) == 0)) return ty;
    ty = ty->prev;
  }
  return 0;
}

#endif

#ifdef __cplusplus
}
#endif



/* -----------------------------------------------------------------------------
 * perl5.swg
 *
 * Perl5 runtime library
 * $Header: /cvs/projects/SWIG/Lib/perl5/perl5.swg,v 1.4 2000/09/02 16:25:28 beazley Exp $
 * ----------------------------------------------------------------------------- */

#define SWIGPERL
#define SWIGPERL5
#ifdef __cplusplus
/* Needed on some windows machines---since MS plays funny
   games with the header files under C++ */
#include <math.h>
#include <stdlib.h>
extern "C" {
#endif
#include "EXTERN.h"
#include "perl.h"
#include "XSUB.h"

/* Get rid of free and malloc defined by perl */
#undef free
#undef malloc

#include <string.h>
#ifdef __cplusplus
}
#endif

#ifdef PERL_OBJECT
#define MAGIC_PPERL  CPerlObj *pPerl = (CPerlObj *) this;
#define MAGIC_CAST   (int (CPerlObj::*)(SV *, MAGIC *))
#define SWIGCLASS_STATIC 
#else
#define MAGIC_PPERL
#define MAGIC_CAST
#define SWIGCLASS_STATIC static
#endif

#if defined(WIN32) && defined(PERL_OBJECT) && !defined(PerlIO_exportFILE)
#define PerlIO_exportFILE(fh,fl) (FILE*)(fh)
#endif

/* Modifications for newer Perl 5.005 releases */

#if !defined(PERL_REVISION) || ((PERL_REVISION >= 5) && ((PERL_VERSION < 5) || ((PERL_VERSION == 5) && (PERL_SUBVERSION < 50))))
#ifndef PL_sv_yes
#define PL_sv_yes sv_yes
#endif
#ifndef PL_sv_undef
#define PL_sv_undef sv_undef
#endif
#ifndef PL_na
#define PL_na na
#endif
#endif

#include <stdlib.h>

#ifdef __cplusplus
extern "C" {
#endif

#ifdef SWIG_NOINCLUDE

#ifndef PERL_OBJECT
extern int SWIG_ConvertPtr(SV *, void **, swig_type_info *);
extern void SWIG_MakePtr(SV *, void *, swig_type_info *);
#else
extern int _SWIG_ConvertPtr(CPerlObj *, SV *, void **, swig_type_info *);
extern void _SWIG_MakePtr(CPerlObj *, SV *, void *, swig_type_info *);
#define SWIG_ConvertPtr(a,b,c) _SWIG_ConvertPtr(pPerl,a,b,c)
#define SWIG_MakePtr(a,b,c) _SWIG_MakePtr(pPerl,a,b,c)
#endif

#endif

/* Function for getting a pointer value */

#ifndef PERL_OBJECT
SWIGRUNTIME(int) 
SWIG_ConvertPtr(SV *sv, void **ptr, swig_type_info *_t)
#else
#define SWIG_ConvertPtr(a,b,c) _SWIG_GetConvert(pPerl,a,b,c)
SWIGRUNTIME(int)
_SWIG_ConvertPtr(CPerlObj *pPerl, SV *sv, void **ptr, swig_type_info *_t)
#endif
{
  char *_c;
  swig_type_info *tc;
  IV   tmp;

  /* If magical, apply more magic */
  if (SvGMAGICAL(sv))
    mg_get(sv);

  /* Check to see if this is an object */
  if (sv_isobject(sv)) {
    SV *tsv = (SV*) SvRV(sv);
    if ((SvTYPE(tsv) == SVt_PVHV)) {
      MAGIC *mg;
      if (SvMAGICAL(tsv)) {
	mg = mg_find(tsv,'P');
	if (mg) {
	  SV *rsv = mg->mg_obj;
	  if (sv_isobject(rsv)) {
	    tmp = SvIV((SV*)SvRV(rsv));
	  }
	}
      } else {
	return -1;
      }
    } else {
      tmp = SvIV((SV*)SvRV(sv));
    }
    if (!_t) {
      *(ptr) = (void *) tmp;
      return 0;
    }
  } else if (! SvOK(sv)) {            /* Check for undef */
    *(ptr) = (void *) 0;
    return 0;
  } else if (SvTYPE(sv) == SVt_RV) {  /* Check for NULL pointer */
    *(ptr) = (void *) 0;
    if (!SvROK(sv)) 
      return 0;
    else
      return -1;
  } else {                            /* Don't know what it is */
      *(ptr) = (void *) 0;
      return -1;
  }
  if (_t) {
    /* Now see if the types match */      
    _c = HvNAME(SvSTASH(SvRV(sv)));
    tc = SWIG_TypeCheck(_c,_t);
    if (!tc) {
      *ptr = (void *) tmp;
      return -1;
    }
    *ptr = SWIG_TypeCast(tc,(void *)tmp);
    return 0;
  }
  *ptr = (void *) tmp;
  return 0;
}
#ifndef PERL_OBJECT
SWIGRUNTIME(void) 
SWIG_MakePtr(SV *sv, void *ptr, swig_type_info *t)
#else
#define SWIG_MakePtr(a,b,c) _SWIG_MakePtr(pPerl,a,b,c)
SWIGRUNTIME(int *)
_SWIG_MakePtr(CPerlObj *pPerl, SV *sv, void *ptr, swig_type_info *t)
#endif
{
  sv_setref_pv(sv, t->name, ptr);
}

/* Magic variable code */
#ifndef PERL_OBJECT
#define swig_create_magic(s,a,b,c) _swig_create_magic(s,a,b,c)
static void _swig_create_magic(SV *sv, char *name, int (*set)(SV *, MAGIC *), int (*get)(SV *,MAGIC *)) {
#else
#define swig_create_magic(s,a,b,c) _swig_create_magic(pPerl,s,a,b,c)
static void _swig_create_magic(CPerlObj *pPerl, SV *sv, char *name, int (CPerlObj::*set)(SV *, MAGIC *), int (CPerlObj::*get)(SV *, MAGIC *)) {
#endif
  MAGIC *mg;
  sv_magic(sv,sv,'U',name,strlen(name));
  mg = mg_find(sv,'U');
  mg->mg_virtual = (MGVTBL *) malloc(sizeof(MGVTBL));
  mg->mg_virtual->svt_get = get;
  mg->mg_virtual->svt_set = set;
  mg->mg_virtual->svt_len = 0;
  mg->mg_virtual->svt_clear = 0;
  mg->mg_virtual->svt_free = 0;
}

#ifdef __cplusplus
}
#endif







/* -------- TYPES TABLE (BEGIN) -------- */

#define  SWIGTYPE_p_Constraints swig_types[0] 
#define  SWIGTYPE_p_PartitioningProblemForCapo swig_types[1] 
#define  SWIGTYPE_p_CapoPlacer swig_types[2] 
#define  SWIGTYPE_p_MetaPlacer swig_types[3] 
#define  SWIGTYPE_p_Orientation swig_types[4] 
#define  SWIGTYPE_p_dbCellType swig_types[5] 
#define  SWIGTYPE_p_dbMasterCellType swig_types[6] 
#define  SWIGTYPE_p_PartitioningProblem swig_types[7] 
#define  SWIGTYPE_p_FillableHierarchy swig_types[8] 
#define  SWIGTYPE_p_ComparePinsByCellIndexAndDir swig_types[9] 
#define  SWIGTYPE_p_vector_Point_ swig_types[10] 
#define  SWIGTYPE_p_itCellLocal swig_types[11] 
#define  SWIGTYPE_p_dbNetType swig_types[12] 
#define  SWIGTYPE_p_CompareCellIdsByX swig_types[13] 
#define  SWIGTYPE_p_dbSpatial swig_types[14] 
#define  SWIGTYPE_p_vector__vector_unsigned___ swig_types[15] 
#define  SWIGTYPE_p_HGWeight swig_types[16] 
#define  SWIGTYPE_p_dbSite swig_types[17] 
#define  SWIGTYPE_p_ISPairLayer swig_types[18] 
#define  SWIGTYPE_p_Placement swig_types[19] 
#define  SWIGTYPE_p_Subset swig_types[20] 
#define  SWIGTYPE_p_RBPlacement swig_types[21] 
#define  SWIGTYPE_p_dbPin swig_types[22] 
#define  SWIGTYPE_p_HGfromDB swig_types[23] 
#define  SWIGTYPE_p_dbGCellGrid swig_types[24] 
#define  SWIGTYPE_p_itGCellGridLocal swig_types[25] 
#define  SWIGTYPE_p_vector_char__ swig_types[26] 
#define  SWIGTYPE_p_vector_const_char__ swig_types[27] 
#define  SWIGTYPE_p_Point swig_types[28] 
#define  SWIGTYPE_p_HGFNode swig_types[29] 
#define  SWIGTYPE_p_RBPCoreRow swig_types[30] 
#define  SWIGTYPE_p_itRBPCoreRow swig_types[31] 
#define  SWIGTYPE_p_Partitioning swig_types[32] 
#define  SWIGTYPE_p_HGraphWDimensions swig_types[33] 
#define  SWIGTYPE_p_ctainerLayerGeoms swig_types[34] 
#define  SWIGTYPE_r_q_const__ctainerLayerGeoms swig_types[35] 
#define  SWIGTYPE_p_Permutation swig_types[36] 
#define  SWIGTYPE_p_vector_const_CapoBlock__ swig_types[37] 
#define  SWIGTYPE_p_Verbosity swig_types[38] 
#define  SWIGTYPE_p_Symmetry swig_types[39] 
#define  SWIGTYPE_p_RBCellCoord swig_types[40] 
#define  SWIGTYPE_p_ComparePinsByDirAndName swig_types[41] 
#define  SWIGTYPE_p_bit_vector swig_types[42] 
#define  SWIGTYPE_p_Rectangle swig_types[43] 
#define  SWIGTYPE_r_q_const__dbLayout swig_types[44] 
#define  SWIGTYPE_p_PartitioningProblem_Attributes swig_types[45] 
#define  SWIGTYPE_p_ifstream swig_types[46] 
#define  SWIGTYPE_p_itSite swig_types[47] 
#define  SWIGTYPE_p_itLayerGeom swig_types[48] 
#define  SWIGTYPE_p_dbLayerGeom swig_types[49] 
#define  SWIGTYPE_p_CompareNetsByDegree swig_types[50] 
#define  SWIGTYPE_p_itLayer swig_types[51] 
#define  SWIGTYPE_p_BaseMLPart swig_types[52] 
#define  SWIGTYPE_p_MLPart swig_types[53] 
#define  SWIGTYPE_p_vector_Orientation_ swig_types[54] 
#define  SWIGTYPE_p_dbEasyAccess swig_types[55] 
#define  SWIGTYPE_p_dbLayer swig_types[56] 
#define  SWIGTYPE_p_dbContext swig_types[57] 
#define  SWIGTYPE_p_DB swig_types[58] 
#define  SWIGTYPE_r_q_const__ctainerTracksGlobal swig_types[59] 
#define  SWIGTYPE_p_itRowGlobal swig_types[60] 
#define  SWIGTYPE_r_q_const__ctainerGCellGridsGlobal swig_types[61] 
#define  SWIGTYPE_p_itHGFNodeGlobal swig_types[62] 
#define  SWIGTYPE_p_itHGFEdgeGlobal swig_types[63] 
#define  SWIGTYPE_p_CompareNetsByDirection swig_types[64] 
#define  SWIGTYPE_p_CompareObstaclesByXmin swig_types[65] 
#define  SWIGTYPE_p_itNetLocal swig_types[66] 
#define  SWIGTYPE_p_nodesMasInfo swig_types[67] 
#define  SWIGTYPE_p_vector_double_ swig_types[68] 
#define  SWIGTYPE_r_q_const__ctainerPinsLocal swig_types[69] 
#define  SWIGTYPE_p_ctainerPinsLocal swig_types[70] 
#define  SWIGTYPE_p_ctainerCellsLocal swig_types[71] 
#define  SWIGTYPE_r_ctainerMasterPinsLocal swig_types[72] 
#define  SWIGTYPE_r_q_const__ctainerMasterPinsLocal swig_types[73] 
#define  SWIGTYPE_r_ctainerPinsLocal swig_types[74] 
#define  SWIGTYPE_p_dbTemporal swig_types[75] 
#define  SWIGTYPE_p_dbCell swig_types[76] 
#define  SWIGTYPE_p_dbRoutingInfo swig_types[77] 
#define  SWIGTYPE_p_eqClassMasterCells swig_types[78] 
#define  SWIGTYPE_p_dbRow swig_types[79] 
#define  SWIGTYPE_p_eqClassMasterPins swig_types[80] 
#define  SWIGTYPE_p_CompareNetsByCellIndex swig_types[81] 
#define  SWIGTYPE_p_CompareCellsByCellIndex swig_types[82] 
#define  SWIGTYPE_p_CompareNetsByName swig_types[83] 
#define  SWIGTYPE_p_CompareMCsByName swig_types[84] 
#define  SWIGTYPE_p_CompareCellsByName swig_types[85] 
#define  SWIGTYPE_p_itMasterPinLocal swig_types[86] 
#define  SWIGTYPE_p_itPinLocal swig_types[87] 
#define  SWIGTYPE_p_CompareCellsByStatus swig_types[88] 
#define  SWIGTYPE_p_itMasterCell swig_types[89] 
#define  SWIGTYPE_p_dbMasterCell swig_types[90] 
#define  SWIGTYPE_p_dbNet swig_types[91] 
#define  SWIGTYPE_p_DB_Parameters swig_types[92] 
#define  SWIGTYPE_p_RBPlacement_Parameters swig_types[93] 
#define  SWIGTYPE_p_CapoParameters swig_types[94] 
#define  SWIGTYPE_p_PartitioningProblem_Parameters swig_types[95] 
#define  SWIGTYPE_p_BaseMLPart_Parameters swig_types[96] 
#define  SWIGTYPE_p_ClustHGraphParameters swig_types[97] 
#define  SWIGTYPE_p_HGraphParameters swig_types[98] 
#define  SWIGTYPE_p_vector_unsigned_ swig_types[99] 
#define  SWIGTYPE_p_dbTrack swig_types[100] 
#define  SWIGTYPE_p_vector_char___ swig_types[101] 
#define  SWIGTYPE_p_dbMasterPin swig_types[102] 
#define  SWIGTYPE_p_itTrackLocal swig_types[103] 
#define  SWIGTYPE_p_CapoSplitterParams swig_types[104] 
#define  SWIGTYPE_p_MLPartParams swig_types[105] 
#define  SWIGTYPE_p_SmallPlParams swig_types[106] 
#define  SWIGTYPE_p_MetaPlacerParams swig_types[107] 
#define  SWIGTYPE_p_ostream swig_types[108] 
#define  SWIGTYPE_p_CompareCellsByDir swig_types[109] 
#define  SWIGTYPE_p_PartitioningBuffer swig_types[110] 
#define  SWIGTYPE_p_HGraphFixed swig_types[111] 
#define  SWIGTYPE_p_PartitionerType swig_types[112] 
#define  SWIGTYPE_p_HGFEdge swig_types[113] 
#define  SWIGTYPE_p_vector_Orient_ swig_types[114] 
#define  SWIGTYPE_p_RBPSubRow swig_types[115] 
#define  SWIGTYPE_p_vector_int_ swig_types[116] 
#define  SWIGTYPE_p_CapoBlock swig_types[117] 
#define  SWIGTYPE_p_itMasterPinGlobal swig_types[118] 
#define  SWIGTYPE_p_itPinGlobal swig_types[119] 
#define  SWIGTYPE_p_itNetGlobal swig_types[120] 
#define  SWIGTYPE_p_itCellGlobal swig_types[121] 
#define  SWIGTYPE_p_RBRowPtrs swig_types[122] 
#define  SWIGTYPE_p_Orient swig_types[123] 
#define  SWIGTYPE_p_BBox swig_types[124] 
#define  SWIGTYPE_p_dbNetlist swig_types[125] 
#define  SWIGTYPE_p_PlacementWOrient swig_types[126] 
#define  SWIGTYPE_p_masterNodeInfo swig_types[127] 
#define  SWIGTYPE_p_vector_BBox_ swig_types[128] 
#define  SWIGTYPE_p_vector_vector_double___ swig_types[129] 
#define  SWIGTYPE_p_HGNodeNamesMap swig_types[130] 
#define  SWIGTYPE_p_HGNetNamesMap swig_types[131] 
#define  SWIGTYPE_p_vector_IntervalSeqLayer_ swig_types[132] 
#define  SWIGTYPE_p_dbMasterPinType swig_types[133] 
static swig_type_info *swig_types[135];

/* -------- TYPES TABLE (END) -------- */

#define SWIG_init    boot_UCLAscript

#define SWIG_name   "UCLAscriptc::boot_UCLAscript"
#define SWIG_varinit "UCLAscriptc::var_UCLAscript_init();"
#ifdef __cplusplus
extern "C"
#endif
#ifndef PERL_OBJECT
SWIGEXPORT(void) SWIG_init (CV* cv);
#else
SWIGEXPORT(void) SWIG_init (CV *cv, CPerlObj *);
#endif

#undef list
#undef assert
#include "DB/dbTypes.h"
#include "DB/dbContext.h"
#include "DB/dbDesign.h"
#include "DB/dbSpatial.h"
#include "DB/dbEasyAccess.h"
#include "DB/dbRoutingInfo.h"
#include "Placement/placeWOri.h"
#include "Placement/placement.h"
//#include "dbTemporal.h"
#include "DB/DB.h"
#include "DB/dbNetlist.h"
#define DB_Parameters DB::Parameters
#include "Capo/capoPlacer.h"
#include "RBPlace/RBPlacement.h"
#define RBPlacement_Parameters RBPlacement::Parameters
#include "MetaPlacer/metaPl.h"
#include "Partitioning/partProb.h"
#define PartitioningProblem_Parameters PartitioningProblem::Parameters
#define PartitioningProblem_Attributes PartitioningProblem::Attributes
#include "MLPart/mlPart.h"
#define BaseMLPart_Parameters BaseMLPart::Parameters
#include "NetTopology/dbHGr.h"
#include "PartEvals/partEvals.h"
#include "FilledHier/fillHier.h"
#ifndef PERL_OBJECT
#define swig_setiv(a,b) _swig_setiv(a,b)
static void _swig_setiv(char *name, long value) { 
#else
#define swig_setiv(a,b) _swig_setiv(pPerl,a,b)
static void _swig_setiv(CPerlObj *pPerl, char *name, long value) { 
#endif
     SV *sv; 
     sv = perl_get_sv(name,TRUE | 0x2);
     sv_setiv(sv, (IV) value);
     SvREADONLY_on(sv);
}

#ifdef PERL_OBJECT
#define MAGIC_CLASS _wrap_UCLAscript_var::
class _wrap_UCLAscript_var : public CPerlObj {
public:
#else
#define MAGIC_CLASS
#endif
SWIGCLASS_STATIC int swig_magic_readonly(SV *sv, MAGIC *mg) {
    MAGIC_PPERL
    sv = sv; mg = mg;
    croak("Value is read-only.");
    return 0;
}


#ifdef PERL_OBJECT
};
#endif

XS(_wrap_new_dbMasterCellType) {
    char *arg0 ;
    char *arg1 ;
    int argvi = 0;
    dbMasterCellType *result ;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) 
    croak("Usage: new_dbMasterCellType(mtype,stype);");
    if (! SvOK((SV*) ST(0))) {
        arg0 = 0; 
    }
    else {
        arg0 = (char *) SvPV(ST(0),PL_na); 
    }
    if (! SvOK((SV*) ST(1))) {
        arg1 = 0; 
    }
    else {
        arg1 = (char *) SvPV(ST(1),PL_na); 
    }
    result = (dbMasterCellType *)new dbMasterCellType(arg0,arg1);
    ST(argvi) = sv_newmortal();
    SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_dbMasterCellType);
    XSRETURN(argvi);
}


XS(_wrap_dbMasterCellType_setCoreClass) {
    dbMasterCellType *arg0 ;
    char *arg1 ;
    int argvi = 0;
    bool result ;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) 
    croak("Usage: dbMasterCellType_setCoreClass(self,lgc_type);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_dbMasterCellType) < 0) {
        croak("Type error in argument 1 of dbMasterCellType_setCoreClass. Expected %s", SWIGTYPE_p_dbMasterCellType->name);
        XSRETURN(1);
    }
    if (! SvOK((SV*) ST(1))) {
        arg1 = 0; 
    }
    else {
        arg1 = (char *) SvPV(ST(1),PL_na); 
    }
    result = (bool )arg0->setCoreClass(arg1);
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) result);
    XSRETURN(argvi);
}


XS(_wrap_dbMasterCellType_isCover) {
    dbMasterCellType *arg0 ;
    int argvi = 0;
    bool result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: dbMasterCellType_isCover(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_dbMasterCellType) < 0) {
        croak("Type error in argument 1 of dbMasterCellType_isCover. Expected %s", SWIGTYPE_p_dbMasterCellType->name);
        XSRETURN(1);
    }
    result = (bool )arg0->isCover();
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) result);
    XSRETURN(argvi);
}


XS(_wrap_dbMasterCellType_isRing) {
    dbMasterCellType *arg0 ;
    int argvi = 0;
    bool result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: dbMasterCellType_isRing(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_dbMasterCellType) < 0) {
        croak("Type error in argument 1 of dbMasterCellType_isRing. Expected %s", SWIGTYPE_p_dbMasterCellType->name);
        XSRETURN(1);
    }
    result = (bool )arg0->isRing();
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) result);
    XSRETURN(argvi);
}


XS(_wrap_dbMasterCellType_isBlock) {
    dbMasterCellType *arg0 ;
    int argvi = 0;
    bool result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: dbMasterCellType_isBlock(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_dbMasterCellType) < 0) {
        croak("Type error in argument 1 of dbMasterCellType_isBlock. Expected %s", SWIGTYPE_p_dbMasterCellType->name);
        XSRETURN(1);
    }
    result = (bool )arg0->isBlock();
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) result);
    XSRETURN(argvi);
}


XS(_wrap_dbMasterCellType_isCore) {
    dbMasterCellType *arg0 ;
    int argvi = 0;
    bool result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: dbMasterCellType_isCore(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_dbMasterCellType) < 0) {
        croak("Type error in argument 1 of dbMasterCellType_isCore. Expected %s", SWIGTYPE_p_dbMasterCellType->name);
        XSRETURN(1);
    }
    result = (bool )arg0->isCore();
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) result);
    XSRETURN(argvi);
}


XS(_wrap_dbMasterCellType_isPad) {
    dbMasterCellType *arg0 ;
    int argvi = 0;
    bool result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: dbMasterCellType_isPad(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_dbMasterCellType) < 0) {
        croak("Type error in argument 1 of dbMasterCellType_isPad. Expected %s", SWIGTYPE_p_dbMasterCellType->name);
        XSRETURN(1);
    }
    result = (bool )arg0->isPad();
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) result);
    XSRETURN(argvi);
}


XS(_wrap_dbMasterCellType_isEndCap) {
    dbMasterCellType *arg0 ;
    int argvi = 0;
    bool result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: dbMasterCellType_isEndCap(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_dbMasterCellType) < 0) {
        croak("Type error in argument 1 of dbMasterCellType_isEndCap. Expected %s", SWIGTYPE_p_dbMasterCellType->name);
        XSRETURN(1);
    }
    result = (bool )arg0->isEndCap();
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) result);
    XSRETURN(argvi);
}


XS(_wrap_dbMasterCellType_isExtPin) {
    dbMasterCellType *arg0 ;
    int argvi = 0;
    bool result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: dbMasterCellType_isExtPin(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_dbMasterCellType) < 0) {
        croak("Type error in argument 1 of dbMasterCellType_isExtPin. Expected %s", SWIGTYPE_p_dbMasterCellType->name);
        XSRETURN(1);
    }
    result = (bool )arg0->isExtPin();
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) result);
    XSRETURN(argvi);
}


XS(_wrap_dbMasterCellType_isUnknown) {
    dbMasterCellType *arg0 ;
    int argvi = 0;
    bool result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: dbMasterCellType_isUnknown(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_dbMasterCellType) < 0) {
        croak("Type error in argument 1 of dbMasterCellType_isUnknown. Expected %s", SWIGTYPE_p_dbMasterCellType->name);
        XSRETURN(1);
    }
    result = (bool )arg0->isUnknown();
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) result);
    XSRETURN(argvi);
}


XS(_wrap_dbMasterCellType_isFlipFlop) {
    dbMasterCellType *arg0 ;
    int argvi = 0;
    bool result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: dbMasterCellType_isFlipFlop(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_dbMasterCellType) < 0) {
        croak("Type error in argument 1 of dbMasterCellType_isFlipFlop. Expected %s", SWIGTYPE_p_dbMasterCellType->name);
        XSRETURN(1);
    }
    result = (bool )arg0->isFlipFlop();
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) result);
    XSRETURN(argvi);
}


XS(_wrap_dbMasterCellType_isLatch) {
    dbMasterCellType *arg0 ;
    int argvi = 0;
    bool result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: dbMasterCellType_isLatch(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_dbMasterCellType) < 0) {
        croak("Type error in argument 1 of dbMasterCellType_isLatch. Expected %s", SWIGTYPE_p_dbMasterCellType->name);
        XSRETURN(1);
    }
    result = (bool )arg0->isLatch();
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) result);
    XSRETURN(argvi);
}


XS(_wrap_dbMasterCellType_isInverter) {
    dbMasterCellType *arg0 ;
    int argvi = 0;
    bool result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: dbMasterCellType_isInverter(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_dbMasterCellType) < 0) {
        croak("Type error in argument 1 of dbMasterCellType_isInverter. Expected %s", SWIGTYPE_p_dbMasterCellType->name);
        XSRETURN(1);
    }
    result = (bool )arg0->isInverter();
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) result);
    XSRETURN(argvi);
}


XS(_wrap_dbMasterCellType_isBuffer) {
    dbMasterCellType *arg0 ;
    int argvi = 0;
    bool result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: dbMasterCellType_isBuffer(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_dbMasterCellType) < 0) {
        croak("Type error in argument 1 of dbMasterCellType_isBuffer. Expected %s", SWIGTYPE_p_dbMasterCellType->name);
        XSRETURN(1);
    }
    result = (bool )arg0->isBuffer();
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) result);
    XSRETURN(argvi);
}


XS(_wrap_dbMasterCellType_isNAND) {
    dbMasterCellType *arg0 ;
    int argvi = 0;
    bool result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: dbMasterCellType_isNAND(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_dbMasterCellType) < 0) {
        croak("Type error in argument 1 of dbMasterCellType_isNAND. Expected %s", SWIGTYPE_p_dbMasterCellType->name);
        XSRETURN(1);
    }
    result = (bool )arg0->isNAND();
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) result);
    XSRETURN(argvi);
}


XS(_wrap_dbMasterCellType_isNOR) {
    dbMasterCellType *arg0 ;
    int argvi = 0;
    bool result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: dbMasterCellType_isNOR(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_dbMasterCellType) < 0) {
        croak("Type error in argument 1 of dbMasterCellType_isNOR. Expected %s", SWIGTYPE_p_dbMasterCellType->name);
        XSRETURN(1);
    }
    result = (bool )arg0->isNOR();
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) result);
    XSRETURN(argvi);
}


XS(_wrap_dbMasterCellType_isCoreUnknown) {
    dbMasterCellType *arg0 ;
    int argvi = 0;
    bool result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: dbMasterCellType_isCoreUnknown(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_dbMasterCellType) < 0) {
        croak("Type error in argument 1 of dbMasterCellType_isCoreUnknown. Expected %s", SWIGTYPE_p_dbMasterCellType->name);
        XSRETURN(1);
    }
    result = (bool )arg0->isCoreUnknown();
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) result);
    XSRETURN(argvi);
}


XS(_wrap_dbMasterCellType_isPI) {
    dbMasterCellType *arg0 ;
    int argvi = 0;
    bool result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: dbMasterCellType_isPI(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_dbMasterCellType) < 0) {
        croak("Type error in argument 1 of dbMasterCellType_isPI. Expected %s", SWIGTYPE_p_dbMasterCellType->name);
        XSRETURN(1);
    }
    result = (bool )arg0->isPI();
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) result);
    XSRETURN(argvi);
}


XS(_wrap_dbMasterCellType_isPO) {
    dbMasterCellType *arg0 ;
    int argvi = 0;
    bool result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: dbMasterCellType_isPO(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_dbMasterCellType) < 0) {
        croak("Type error in argument 1 of dbMasterCellType_isPO. Expected %s", SWIGTYPE_p_dbMasterCellType->name);
        XSRETURN(1);
    }
    result = (bool )arg0->isPO();
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) result);
    XSRETURN(argvi);
}


XS(_wrap_dbMasterCellType_isPIO) {
    dbMasterCellType *arg0 ;
    int argvi = 0;
    bool result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: dbMasterCellType_isPIO(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_dbMasterCellType) < 0) {
        croak("Type error in argument 1 of dbMasterCellType_isPIO. Expected %s", SWIGTYPE_p_dbMasterCellType->name);
        XSRETURN(1);
    }
    result = (bool )arg0->isPIO();
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) result);
    XSRETURN(argvi);
}


XS(_wrap_dbMasterCellType_isPPower) {
    dbMasterCellType *arg0 ;
    int argvi = 0;
    bool result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: dbMasterCellType_isPPower(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_dbMasterCellType) < 0) {
        croak("Type error in argument 1 of dbMasterCellType_isPPower. Expected %s", SWIGTYPE_p_dbMasterCellType->name);
        XSRETURN(1);
    }
    result = (bool )arg0->isPPower();
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) result);
    XSRETURN(argvi);
}


XS(_wrap_dbMasterCellType_isPSpacer) {
    dbMasterCellType *arg0 ;
    int argvi = 0;
    bool result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: dbMasterCellType_isPSpacer(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_dbMasterCellType) < 0) {
        croak("Type error in argument 1 of dbMasterCellType_isPSpacer. Expected %s", SWIGTYPE_p_dbMasterCellType->name);
        XSRETURN(1);
    }
    result = (bool )arg0->isPSpacer();
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) result);
    XSRETURN(argvi);
}


XS(_wrap_dbMasterCellType_isPUnknown) {
    dbMasterCellType *arg0 ;
    int argvi = 0;
    bool result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: dbMasterCellType_isPUnknown(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_dbMasterCellType) < 0) {
        croak("Type error in argument 1 of dbMasterCellType_isPUnknown. Expected %s", SWIGTYPE_p_dbMasterCellType->name);
        XSRETURN(1);
    }
    result = (bool )arg0->isPUnknown();
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) result);
    XSRETURN(argvi);
}


XS(_wrap_new_dbCellType) {
    int argvi = 0;
    dbCellType *result ;
    dXSARGS;
    
    if ((items < 0) || (items > 0)) 
    croak("Usage: new_dbCellType();");
    result = (dbCellType *)new dbCellType();
    ST(argvi) = sv_newmortal();
    SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_dbCellType);
    XSRETURN(argvi);
}


XS(_wrap_dbCellType_isInitialized) {
    dbCellType *arg0 ;
    int argvi = 0;
    bool result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: dbCellType_isInitialized(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_dbCellType) < 0) {
        croak("Type error in argument 1 of dbCellType_isInitialized. Expected %s", SWIGTYPE_p_dbCellType->name);
        XSRETURN(1);
    }
    result = (bool )arg0->isInitialized();
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) result);
    XSRETURN(argvi);
}


XS(_wrap_dbCellType_isIO) {
    dbCellType *arg0 ;
    int argvi = 0;
    bool result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: dbCellType_isIO(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_dbCellType) < 0) {
        croak("Type error in argument 1 of dbCellType_isIO. Expected %s", SWIGTYPE_p_dbCellType->name);
        XSRETURN(1);
    }
    result = (bool )arg0->isIO();
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) result);
    XSRETURN(argvi);
}


XS(_wrap_dbCellType_isBlock) {
    dbCellType *arg0 ;
    int argvi = 0;
    bool result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: dbCellType_isBlock(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_dbCellType) < 0) {
        croak("Type error in argument 1 of dbCellType_isBlock. Expected %s", SWIGTYPE_p_dbCellType->name);
        XSRETURN(1);
    }
    result = (bool )arg0->isBlock();
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) result);
    XSRETURN(argvi);
}


XS(_wrap_dbCellType_isCore) {
    dbCellType *arg0 ;
    int argvi = 0;
    bool result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: dbCellType_isCore(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_dbCellType) < 0) {
        croak("Type error in argument 1 of dbCellType_isCore. Expected %s", SWIGTYPE_p_dbCellType->name);
        XSRETURN(1);
    }
    result = (bool )arg0->isCore();
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) result);
    XSRETURN(argvi);
}


XS(_wrap_dbCellType_isOther) {
    dbCellType *arg0 ;
    int argvi = 0;
    bool result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: dbCellType_isOther(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_dbCellType) < 0) {
        croak("Type error in argument 1 of dbCellType_isOther. Expected %s", SWIGTYPE_p_dbCellType->name);
        XSRETURN(1);
    }
    result = (bool )arg0->isOther();
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) result);
    XSRETURN(argvi);
}


XS(_wrap_dbCellType_isUnknown) {
    dbCellType *arg0 ;
    int argvi = 0;
    bool result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: dbCellType_isUnknown(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_dbCellType) < 0) {
        croak("Type error in argument 1 of dbCellType_isUnknown. Expected %s", SWIGTYPE_p_dbCellType->name);
        XSRETURN(1);
    }
    result = (bool )arg0->isUnknown();
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) result);
    XSRETURN(argvi);
}


XS(_wrap_dbCellType_isPI) {
    dbCellType *arg0 ;
    int argvi = 0;
    bool result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: dbCellType_isPI(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_dbCellType) < 0) {
        croak("Type error in argument 1 of dbCellType_isPI. Expected %s", SWIGTYPE_p_dbCellType->name);
        XSRETURN(1);
    }
    result = (bool )arg0->isPI();
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) result);
    XSRETURN(argvi);
}


XS(_wrap_dbCellType_isPO) {
    dbCellType *arg0 ;
    int argvi = 0;
    bool result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: dbCellType_isPO(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_dbCellType) < 0) {
        croak("Type error in argument 1 of dbCellType_isPO. Expected %s", SWIGTYPE_p_dbCellType->name);
        XSRETURN(1);
    }
    result = (bool )arg0->isPO();
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) result);
    XSRETURN(argvi);
}


XS(_wrap_dbCellType_isPIO) {
    dbCellType *arg0 ;
    int argvi = 0;
    bool result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: dbCellType_isPIO(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_dbCellType) < 0) {
        croak("Type error in argument 1 of dbCellType_isPIO. Expected %s", SWIGTYPE_p_dbCellType->name);
        XSRETURN(1);
    }
    result = (bool )arg0->isPIO();
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) result);
    XSRETURN(argvi);
}


XS(_wrap_dbCellType_isPOther) {
    dbCellType *arg0 ;
    int argvi = 0;
    bool result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: dbCellType_isPOther(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_dbCellType) < 0) {
        croak("Type error in argument 1 of dbCellType_isPOther. Expected %s", SWIGTYPE_p_dbCellType->name);
        XSRETURN(1);
    }
    result = (bool )arg0->isPOther();
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) result);
    XSRETURN(argvi);
}


XS(_wrap_dbCellType_isPUnknown) {
    dbCellType *arg0 ;
    int argvi = 0;
    bool result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: dbCellType_isPUnknown(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_dbCellType) < 0) {
        croak("Type error in argument 1 of dbCellType_isPUnknown. Expected %s", SWIGTYPE_p_dbCellType->name);
        XSRETURN(1);
    }
    result = (bool )arg0->isPUnknown();
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) result);
    XSRETURN(argvi);
}


XS(_wrap_dbCellType_isCC) {
    dbCellType *arg0 ;
    int argvi = 0;
    bool result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: dbCellType_isCC(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_dbCellType) < 0) {
        croak("Type error in argument 1 of dbCellType_isCC. Expected %s", SWIGTYPE_p_dbCellType->name);
        XSRETURN(1);
    }
    result = (bool )arg0->isCC();
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) result);
    XSRETURN(argvi);
}


XS(_wrap_dbCellType_isSC) {
    dbCellType *arg0 ;
    int argvi = 0;
    bool result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: dbCellType_isSC(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_dbCellType) < 0) {
        croak("Type error in argument 1 of dbCellType_isSC. Expected %s", SWIGTYPE_p_dbCellType->name);
        XSRETURN(1);
    }
    result = (bool )arg0->isSC();
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) result);
    XSRETURN(argvi);
}


XS(_wrap_dbCellType_isCoreOther) {
    dbCellType *arg0 ;
    int argvi = 0;
    bool result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: dbCellType_isCoreOther(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_dbCellType) < 0) {
        croak("Type error in argument 1 of dbCellType_isCoreOther. Expected %s", SWIGTYPE_p_dbCellType->name);
        XSRETURN(1);
    }
    result = (bool )arg0->isCoreOther();
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) result);
    XSRETURN(argvi);
}


XS(_wrap_new_dbNetType) {
    char *arg0 ;
    int argvi = 0;
    dbNetType *result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: new_dbNetType(txt);");
    if (! SvOK((SV*) ST(0))) {
        arg0 = 0; 
    }
    else {
        arg0 = (char *) SvPV(ST(0),PL_na); 
    }
    result = (dbNetType *)new dbNetType(arg0);
    ST(argvi) = sv_newmortal();
    SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_dbNetType);
    XSRETURN(argvi);
}


XS(_wrap_dbNetType_isSignal) {
    dbNetType *arg0 ;
    int argvi = 0;
    bool result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: dbNetType_isSignal(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_dbNetType) < 0) {
        croak("Type error in argument 1 of dbNetType_isSignal. Expected %s", SWIGTYPE_p_dbNetType->name);
        XSRETURN(1);
    }
    result = (bool )arg0->isSignal();
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) result);
    XSRETURN(argvi);
}


XS(_wrap_dbNetType_isPower) {
    dbNetType *arg0 ;
    int argvi = 0;
    bool result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: dbNetType_isPower(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_dbNetType) < 0) {
        croak("Type error in argument 1 of dbNetType_isPower. Expected %s", SWIGTYPE_p_dbNetType->name);
        XSRETURN(1);
    }
    result = (bool )arg0->isPower();
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) result);
    XSRETURN(argvi);
}


XS(_wrap_dbNetType_isGround) {
    dbNetType *arg0 ;
    int argvi = 0;
    bool result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: dbNetType_isGround(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_dbNetType) < 0) {
        croak("Type error in argument 1 of dbNetType_isGround. Expected %s", SWIGTYPE_p_dbNetType->name);
        XSRETURN(1);
    }
    result = (bool )arg0->isGround();
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) result);
    XSRETURN(argvi);
}


XS(_wrap_dbNetType_isClock) {
    dbNetType *arg0 ;
    int argvi = 0;
    bool result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: dbNetType_isClock(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_dbNetType) < 0) {
        croak("Type error in argument 1 of dbNetType_isClock. Expected %s", SWIGTYPE_p_dbNetType->name);
        XSRETURN(1);
    }
    result = (bool )arg0->isClock();
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) result);
    XSRETURN(argvi);
}


XS(_wrap_dbNetType_isTieOff) {
    dbNetType *arg0 ;
    int argvi = 0;
    bool result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: dbNetType_isTieOff(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_dbNetType) < 0) {
        croak("Type error in argument 1 of dbNetType_isTieOff. Expected %s", SWIGTYPE_p_dbNetType->name);
        XSRETURN(1);
    }
    result = (bool )arg0->isTieOff();
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) result);
    XSRETURN(argvi);
}


XS(_wrap_dbNetType_isAnalog) {
    dbNetType *arg0 ;
    int argvi = 0;
    bool result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: dbNetType_isAnalog(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_dbNetType) < 0) {
        croak("Type error in argument 1 of dbNetType_isAnalog. Expected %s", SWIGTYPE_p_dbNetType->name);
        XSRETURN(1);
    }
    result = (bool )arg0->isAnalog();
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) result);
    XSRETURN(argvi);
}


XS(_wrap_dbNetType_isUnknown) {
    dbNetType *arg0 ;
    int argvi = 0;
    bool result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: dbNetType_isUnknown(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_dbNetType) < 0) {
        croak("Type error in argument 1 of dbNetType_isUnknown. Expected %s", SWIGTYPE_p_dbNetType->name);
        XSRETURN(1);
    }
    result = (bool )arg0->isUnknown();
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) result);
    XSRETURN(argvi);
}


XS(_wrap_new_dbMasterPinType) {
    char *arg0 ;
    char *arg1 ;
    char *arg2 ;
    int argvi = 0;
    dbMasterPinType *result ;
    dXSARGS;
    
    if ((items < 3) || (items > 3)) 
    croak("Usage: new_dbMasterPinType(nDir,nUse,nShape);");
    if (! SvOK((SV*) ST(0))) {
        arg0 = 0; 
    }
    else {
        arg0 = (char *) SvPV(ST(0),PL_na); 
    }
    if (! SvOK((SV*) ST(1))) {
        arg1 = 0; 
    }
    else {
        arg1 = (char *) SvPV(ST(1),PL_na); 
    }
    if (! SvOK((SV*) ST(2))) {
        arg2 = 0; 
    }
    else {
        arg2 = (char *) SvPV(ST(2),PL_na); 
    }
    result = (dbMasterPinType *)new dbMasterPinType((char const *)arg0,(char const *)arg1,(char const *)arg2);
    ST(argvi) = sv_newmortal();
    SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_dbMasterPinType);
    XSRETURN(argvi);
}


XS(_wrap_dbMasterPinType_isShapeAbutment) {
    dbMasterPinType *arg0 ;
    int argvi = 0;
    bool result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: dbMasterPinType_isShapeAbutment(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_dbMasterPinType) < 0) {
        croak("Type error in argument 1 of dbMasterPinType_isShapeAbutment. Expected %s", SWIGTYPE_p_dbMasterPinType->name);
        XSRETURN(1);
    }
    result = (bool )arg0->isShapeAbutment();
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) result);
    XSRETURN(argvi);
}


XS(_wrap_dbMasterPinType_isShapeFeedthrough) {
    dbMasterPinType *arg0 ;
    int argvi = 0;
    bool result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: dbMasterPinType_isShapeFeedthrough(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_dbMasterPinType) < 0) {
        croak("Type error in argument 1 of dbMasterPinType_isShapeFeedthrough. Expected %s", SWIGTYPE_p_dbMasterPinType->name);
        XSRETURN(1);
    }
    result = (bool )arg0->isShapeFeedthrough();
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) result);
    XSRETURN(argvi);
}


XS(_wrap_dbMasterPinType_isShapeRing) {
    dbMasterPinType *arg0 ;
    int argvi = 0;
    bool result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: dbMasterPinType_isShapeRing(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_dbMasterPinType) < 0) {
        croak("Type error in argument 1 of dbMasterPinType_isShapeRing. Expected %s", SWIGTYPE_p_dbMasterPinType->name);
        XSRETURN(1);
    }
    result = (bool )arg0->isShapeRing();
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) result);
    XSRETURN(argvi);
}


XS(_wrap_dbMasterPinType_isShapeUnknown) {
    dbMasterPinType *arg0 ;
    int argvi = 0;
    bool result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: dbMasterPinType_isShapeUnknown(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_dbMasterPinType) < 0) {
        croak("Type error in argument 1 of dbMasterPinType_isShapeUnknown. Expected %s", SWIGTYPE_p_dbMasterPinType->name);
        XSRETURN(1);
    }
    result = (bool )arg0->isShapeUnknown();
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) result);
    XSRETURN(argvi);
}


XS(_wrap_dbMasterPinType_isUseSignal) {
    dbMasterPinType *arg0 ;
    int argvi = 0;
    bool result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: dbMasterPinType_isUseSignal(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_dbMasterPinType) < 0) {
        croak("Type error in argument 1 of dbMasterPinType_isUseSignal. Expected %s", SWIGTYPE_p_dbMasterPinType->name);
        XSRETURN(1);
    }
    result = (bool )arg0->isUseSignal();
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) result);
    XSRETURN(argvi);
}


XS(_wrap_dbMasterPinType_isUseAnalog) {
    dbMasterPinType *arg0 ;
    int argvi = 0;
    bool result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: dbMasterPinType_isUseAnalog(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_dbMasterPinType) < 0) {
        croak("Type error in argument 1 of dbMasterPinType_isUseAnalog. Expected %s", SWIGTYPE_p_dbMasterPinType->name);
        XSRETURN(1);
    }
    result = (bool )arg0->isUseAnalog();
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) result);
    XSRETURN(argvi);
}


XS(_wrap_dbMasterPinType_isUsePower) {
    dbMasterPinType *arg0 ;
    int argvi = 0;
    bool result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: dbMasterPinType_isUsePower(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_dbMasterPinType) < 0) {
        croak("Type error in argument 1 of dbMasterPinType_isUsePower. Expected %s", SWIGTYPE_p_dbMasterPinType->name);
        XSRETURN(1);
    }
    result = (bool )arg0->isUsePower();
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) result);
    XSRETURN(argvi);
}


XS(_wrap_dbMasterPinType_isUseGround) {
    dbMasterPinType *arg0 ;
    int argvi = 0;
    bool result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: dbMasterPinType_isUseGround(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_dbMasterPinType) < 0) {
        croak("Type error in argument 1 of dbMasterPinType_isUseGround. Expected %s", SWIGTYPE_p_dbMasterPinType->name);
        XSRETURN(1);
    }
    result = (bool )arg0->isUseGround();
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) result);
    XSRETURN(argvi);
}


XS(_wrap_dbMasterPinType_isUseClock) {
    dbMasterPinType *arg0 ;
    int argvi = 0;
    bool result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: dbMasterPinType_isUseClock(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_dbMasterPinType) < 0) {
        croak("Type error in argument 1 of dbMasterPinType_isUseClock. Expected %s", SWIGTYPE_p_dbMasterPinType->name);
        XSRETURN(1);
    }
    result = (bool )arg0->isUseClock();
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) result);
    XSRETURN(argvi);
}


XS(_wrap_dbMasterPinType_isUseTieoff) {
    dbMasterPinType *arg0 ;
    int argvi = 0;
    bool result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: dbMasterPinType_isUseTieoff(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_dbMasterPinType) < 0) {
        croak("Type error in argument 1 of dbMasterPinType_isUseTieoff. Expected %s", SWIGTYPE_p_dbMasterPinType->name);
        XSRETURN(1);
    }
    result = (bool )arg0->isUseTieoff();
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) result);
    XSRETURN(argvi);
}


XS(_wrap_dbMasterPinType_isUseUnknown) {
    dbMasterPinType *arg0 ;
    int argvi = 0;
    bool result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: dbMasterPinType_isUseUnknown(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_dbMasterPinType) < 0) {
        croak("Type error in argument 1 of dbMasterPinType_isUseUnknown. Expected %s", SWIGTYPE_p_dbMasterPinType->name);
        XSRETURN(1);
    }
    result = (bool )arg0->isUseUnknown();
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) result);
    XSRETURN(argvi);
}


XS(_wrap_dbMasterPinType_isDirOutput) {
    dbMasterPinType *arg0 ;
    int argvi = 0;
    bool result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: dbMasterPinType_isDirOutput(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_dbMasterPinType) < 0) {
        croak("Type error in argument 1 of dbMasterPinType_isDirOutput. Expected %s", SWIGTYPE_p_dbMasterPinType->name);
        XSRETURN(1);
    }
    result = (bool )arg0->isDirOutput();
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) result);
    XSRETURN(argvi);
}


XS(_wrap_dbMasterPinType_isDirInput) {
    dbMasterPinType *arg0 ;
    int argvi = 0;
    bool result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: dbMasterPinType_isDirInput(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_dbMasterPinType) < 0) {
        croak("Type error in argument 1 of dbMasterPinType_isDirInput. Expected %s", SWIGTYPE_p_dbMasterPinType->name);
        XSRETURN(1);
    }
    result = (bool )arg0->isDirInput();
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) result);
    XSRETURN(argvi);
}


XS(_wrap_dbMasterPinType_isDirInOut) {
    dbMasterPinType *arg0 ;
    int argvi = 0;
    bool result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: dbMasterPinType_isDirInOut(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_dbMasterPinType) < 0) {
        croak("Type error in argument 1 of dbMasterPinType_isDirInOut. Expected %s", SWIGTYPE_p_dbMasterPinType->name);
        XSRETURN(1);
    }
    result = (bool )arg0->isDirInOut();
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) result);
    XSRETURN(argvi);
}


XS(_wrap_dbMasterPinType_isDirOutputTristate) {
    dbMasterPinType *arg0 ;
    int argvi = 0;
    bool result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: dbMasterPinType_isDirOutputTristate(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_dbMasterPinType) < 0) {
        croak("Type error in argument 1 of dbMasterPinType_isDirOutputTristate. Expected %s", SWIGTYPE_p_dbMasterPinType->name);
        XSRETURN(1);
    }
    result = (bool )arg0->isDirOutputTristate();
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) result);
    XSRETURN(argvi);
}


XS(_wrap_dbMasterPinType_isDirFeedthrough) {
    dbMasterPinType *arg0 ;
    int argvi = 0;
    bool result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: dbMasterPinType_isDirFeedthrough(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_dbMasterPinType) < 0) {
        croak("Type error in argument 1 of dbMasterPinType_isDirFeedthrough. Expected %s", SWIGTYPE_p_dbMasterPinType->name);
        XSRETURN(1);
    }
    result = (bool )arg0->isDirFeedthrough();
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) result);
    XSRETURN(argvi);
}


XS(_wrap_dbMasterPinType_isDirUnknown) {
    dbMasterPinType *arg0 ;
    int argvi = 0;
    bool result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: dbMasterPinType_isDirUnknown(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_dbMasterPinType) < 0) {
        croak("Type error in argument 1 of dbMasterPinType_isDirUnknown. Expected %s", SWIGTYPE_p_dbMasterPinType->name);
        XSRETURN(1);
    }
    result = (bool )arg0->isDirUnknown();
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) result);
    XSRETURN(argvi);
}


XS(_wrap_new_dbContext) {
    int argvi = 0;
    dbContext *result ;
    dXSARGS;
    
    if ((items < 0) || (items > 0)) 
    croak("Usage: new_dbContext();");
    result = (dbContext *)new dbContext();
    ST(argvi) = sv_newmortal();
    SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_dbContext);
    XSRETURN(argvi);
}


XS(_wrap_delete_dbContext) {
    dbContext *arg0 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: delete_dbContext(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_dbContext) < 0) {
        croak("Type error in argument 1 of delete_dbContext. Expected %s", SWIGTYPE_p_dbContext->name);
        XSRETURN(1);
    }
    delete arg0;
    XSRETURN(argvi);
}


XS(_wrap_dbContext_getMinFeatureX) {
    dbContext *arg0 ;
    int argvi = 0;
    double result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: dbContext_getMinFeatureX(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_dbContext) < 0) {
        croak("Type error in argument 1 of dbContext_getMinFeatureX. Expected %s", SWIGTYPE_p_dbContext->name);
        XSRETURN(1);
    }
    result = (double )arg0->getMinFeatureX();
    ST(argvi) = sv_newmortal();
    sv_setnv(ST(argvi++), (double) result);
    XSRETURN(argvi);
}


XS(_wrap_dbContext_getMinFeatureY) {
    dbContext *arg0 ;
    int argvi = 0;
    double result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: dbContext_getMinFeatureY(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_dbContext) < 0) {
        croak("Type error in argument 1 of dbContext_getMinFeatureY. Expected %s", SWIGTYPE_p_dbContext->name);
        XSRETURN(1);
    }
    result = (double )arg0->getMinFeatureY();
    ST(argvi) = sv_newmortal();
    sv_setnv(ST(argvi++), (double) result);
    XSRETURN(argvi);
}


XS(_wrap_dbContext_getUnits) {
    dbContext *arg0 ;
    int argvi = 0;
    unsigned int result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: dbContext_getUnits(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_dbContext) < 0) {
        croak("Type error in argument 1 of dbContext_getUnits. Expected %s", SWIGTYPE_p_dbContext->name);
        XSRETURN(1);
    }
    result = (unsigned int )arg0->getUnits();
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) result);
    XSRETURN(argvi);
}


XS(_wrap_dbContext_getBBox) {
    dbContext *arg0 ;
    int argvi = 0;
    BBox *result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: dbContext_getBBox(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_dbContext) < 0) {
        croak("Type error in argument 1 of dbContext_getBBox. Expected %s", SWIGTYPE_p_dbContext->name);
        XSRETURN(1);
    }
    result = new BBox (arg0->getBBox());    ST(argvi) = sv_newmortal();
    SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_BBox);
    XSRETURN(argvi);
}


XS(_wrap_dbContext_getNumSites) {
    dbContext *arg0 ;
    int argvi = 0;
    unsigned int result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: dbContext_getNumSites(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_dbContext) < 0) {
        croak("Type error in argument 1 of dbContext_getNumSites. Expected %s", SWIGTYPE_p_dbContext->name);
        XSRETURN(1);
    }
    result = (unsigned int )arg0->getNumSites();
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) result);
    XSRETURN(argvi);
}


XS(_wrap_dbContext_getNumLayers) {
    dbContext *arg0 ;
    int argvi = 0;
    unsigned int result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: dbContext_getNumLayers(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_dbContext) < 0) {
        croak("Type error in argument 1 of dbContext_getNumLayers. Expected %s", SWIGTYPE_p_dbContext->name);
        XSRETURN(1);
    }
    result = (unsigned int )arg0->getNumLayers();
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) result);
    XSRETURN(argvi);
}


XS(_wrap_dbContext_getNumRows) {
    dbContext *arg0 ;
    int argvi = 0;
    unsigned int result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: dbContext_getNumRows(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_dbContext) < 0) {
        croak("Type error in argument 1 of dbContext_getNumRows. Expected %s", SWIGTYPE_p_dbContext->name);
        XSRETURN(1);
    }
    result = (unsigned int )arg0->getNumRows();
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) result);
    XSRETURN(argvi);
}


XS(_wrap_dbContext_getNumTracks) {
    dbContext *arg0 ;
    int argvi = 0;
    unsigned int result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: dbContext_getNumTracks(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_dbContext) < 0) {
        croak("Type error in argument 1 of dbContext_getNumTracks. Expected %s", SWIGTYPE_p_dbContext->name);
        XSRETURN(1);
    }
    result = (unsigned int )arg0->getNumTracks();
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) result);
    XSRETURN(argvi);
}


XS(_wrap_dbContext_beginSites) {
    dbContext *arg0 ;
    int argvi = 0;
    itSite *result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: dbContext_beginSites(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_dbContext) < 0) {
        croak("Type error in argument 1 of dbContext_beginSites. Expected %s", SWIGTYPE_p_dbContext->name);
        XSRETURN(1);
    }
    result = new itSite (arg0->beginSites());    ST(argvi) = sv_newmortal();
    SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_itSite);
    XSRETURN(argvi);
}


XS(_wrap_dbContext_endSites) {
    dbContext *arg0 ;
    int argvi = 0;
    itSite *result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: dbContext_endSites(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_dbContext) < 0) {
        croak("Type error in argument 1 of dbContext_endSites. Expected %s", SWIGTYPE_p_dbContext->name);
        XSRETURN(1);
    }
    result = new itSite (arg0->endSites());    ST(argvi) = sv_newmortal();
    SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_itSite);
    XSRETURN(argvi);
}


XS(_wrap_dbContext_getSiteByIdx) {
    dbContext *arg0 ;
    unsigned int arg1 ;
    int argvi = 0;
    dbSite *result ;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) 
    croak("Usage: dbContext_getSiteByIdx(self,i);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_dbContext) < 0) {
        croak("Type error in argument 1 of dbContext_getSiteByIdx. Expected %s", SWIGTYPE_p_dbContext->name);
        XSRETURN(1);
    }
    arg1 = (unsigned int )SvIV(ST(1));
    dbSite const &_result_ref = arg0->getSiteByIdx(arg1);
    result = (dbSite *) &_result_ref;
    ST(argvi) = sv_newmortal();
    SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_dbSite);
    XSRETURN(argvi);
}


XS(_wrap_dbContext_beginLayers) {
    dbContext *arg0 ;
    int argvi = 0;
    itLayer *result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: dbContext_beginLayers(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_dbContext) < 0) {
        croak("Type error in argument 1 of dbContext_beginLayers. Expected %s", SWIGTYPE_p_dbContext->name);
        XSRETURN(1);
    }
    result = new itLayer (arg0->beginLayers());    ST(argvi) = sv_newmortal();
    SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_itLayer);
    XSRETURN(argvi);
}


XS(_wrap_dbContext_endLayers) {
    dbContext *arg0 ;
    int argvi = 0;
    itLayer *result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: dbContext_endLayers(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_dbContext) < 0) {
        croak("Type error in argument 1 of dbContext_endLayers. Expected %s", SWIGTYPE_p_dbContext->name);
        XSRETURN(1);
    }
    result = new itLayer (arg0->endLayers());    ST(argvi) = sv_newmortal();
    SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_itLayer);
    XSRETURN(argvi);
}


XS(_wrap_dbContext_getLayerByIdx) {
    dbContext *arg0 ;
    unsigned int arg1 ;
    int argvi = 0;
    dbLayer *result ;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) 
    croak("Usage: dbContext_getLayerByIdx(self,i);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_dbContext) < 0) {
        croak("Type error in argument 1 of dbContext_getLayerByIdx. Expected %s", SWIGTYPE_p_dbContext->name);
        XSRETURN(1);
    }
    arg1 = (unsigned int )SvIV(ST(1));
    dbLayer const &_result_ref = arg0->getLayerByIdx(arg1);
    result = (dbLayer *) &_result_ref;
    ST(argvi) = sv_newmortal();
    SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_dbLayer);
    XSRETURN(argvi);
}


XS(_wrap_dbContext_rowsBegin) {
    dbContext *arg0 ;
    int argvi = 0;
    itRowGlobal *result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: dbContext_rowsBegin(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_dbContext) < 0) {
        croak("Type error in argument 1 of dbContext_rowsBegin. Expected %s", SWIGTYPE_p_dbContext->name);
        XSRETURN(1);
    }
    result = new itRowGlobal (arg0->rowsBegin());    ST(argvi) = sv_newmortal();
    SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_itRowGlobal);
    XSRETURN(argvi);
}


XS(_wrap_dbContext_rowsEnd) {
    dbContext *arg0 ;
    int argvi = 0;
    itRowGlobal *result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: dbContext_rowsEnd(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_dbContext) < 0) {
        croak("Type error in argument 1 of dbContext_rowsEnd. Expected %s", SWIGTYPE_p_dbContext->name);
        XSRETURN(1);
    }
    result = new itRowGlobal (arg0->rowsEnd());    ST(argvi) = sv_newmortal();
    SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_itRowGlobal);
    XSRETURN(argvi);
}


XS(_wrap_dbContext_getRowByIdx) {
    dbContext *arg0 ;
    unsigned int arg1 ;
    int argvi = 0;
    dbRow *result ;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) 
    croak("Usage: dbContext_getRowByIdx(self,i);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_dbContext) < 0) {
        croak("Type error in argument 1 of dbContext_getRowByIdx. Expected %s", SWIGTYPE_p_dbContext->name);
        XSRETURN(1);
    }
    arg1 = (unsigned int )SvIV(ST(1));
    dbRow const &_result_ref = arg0->getRowByIdx(arg1);
    result = (dbRow *) &_result_ref;
    ST(argvi) = sv_newmortal();
    SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_dbRow);
    XSRETURN(argvi);
}


XS(_wrap_dbContext_beginTracks) {
    dbContext *arg0 ;
    int argvi = 0;
    itTrackLocal *result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: dbContext_beginTracks(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_dbContext) < 0) {
        croak("Type error in argument 1 of dbContext_beginTracks. Expected %s", SWIGTYPE_p_dbContext->name);
        XSRETURN(1);
    }
    result = new itTrackLocal (arg0->beginTracks());    ST(argvi) = sv_newmortal();
    SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_itTrackLocal);
    XSRETURN(argvi);
}


XS(_wrap_dbContext_endTracks) {
    dbContext *arg0 ;
    int argvi = 0;
    itTrackLocal *result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: dbContext_endTracks(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_dbContext) < 0) {
        croak("Type error in argument 1 of dbContext_endTracks. Expected %s", SWIGTYPE_p_dbContext->name);
        XSRETURN(1);
    }
    result = new itTrackLocal (arg0->endTracks());    ST(argvi) = sv_newmortal();
    SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_itTrackLocal);
    XSRETURN(argvi);
}


XS(_wrap_dbContext_getTracks) {
    dbContext *arg0 ;
    int argvi = 0;
    ctainerTracksGlobal *result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: dbContext_getTracks(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_dbContext) < 0) {
        croak("Type error in argument 1 of dbContext_getTracks. Expected %s", SWIGTYPE_p_dbContext->name);
        XSRETURN(1);
    }
    ctainerTracksGlobal const &_result_ref = arg0->getTracks();
    result = (ctainerTracksGlobal *) &_result_ref;
    ST(argvi) = sv_newmortal();
    SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_r_q_const__ctainerTracksGlobal);
    XSRETURN(argvi);
}


XS(_wrap_dbContext_getTrackByIdx) {
    dbContext *arg0 ;
    unsigned int arg1 ;
    int argvi = 0;
    dbTrack *result ;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) 
    croak("Usage: dbContext_getTrackByIdx(self,i);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_dbContext) < 0) {
        croak("Type error in argument 1 of dbContext_getTrackByIdx. Expected %s", SWIGTYPE_p_dbContext->name);
        XSRETURN(1);
    }
    arg1 = (unsigned int )SvIV(ST(1));
    dbTrack const &_result_ref = arg0->getTrackByIdx(arg1);
    result = (dbTrack *) &_result_ref;
    ST(argvi) = sv_newmortal();
    SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_dbTrack);
    XSRETURN(argvi);
}


XS(_wrap_dbContext_getNumHorizTracks) {
    dbContext *arg0 ;
    BBox *arg1 ;
    int argvi = 0;
    unsigned int result ;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) 
    croak("Usage: dbContext_getNumHorizTracks(self,rect);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_dbContext) < 0) {
        croak("Type error in argument 1 of dbContext_getNumHorizTracks. Expected %s", SWIGTYPE_p_dbContext->name);
        XSRETURN(1);
    }
    if (SWIG_ConvertPtr(ST(1),(void **) &arg1,SWIGTYPE_p_BBox) < 0) {
        croak("Type error in argument 2 of dbContext_getNumHorizTracks. Expected %s", SWIGTYPE_p_BBox->name);
        XSRETURN(1);
    }
    result = (unsigned int )arg0->getNumHorizTracks((BBox const &)*arg1);
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) result);
    XSRETURN(argvi);
}


XS(_wrap_dbContext_getNumVertTracks) {
    dbContext *arg0 ;
    BBox *arg1 ;
    int argvi = 0;
    unsigned int result ;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) 
    croak("Usage: dbContext_getNumVertTracks(self,rect);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_dbContext) < 0) {
        croak("Type error in argument 1 of dbContext_getNumVertTracks. Expected %s", SWIGTYPE_p_dbContext->name);
        XSRETURN(1);
    }
    if (SWIG_ConvertPtr(ST(1),(void **) &arg1,SWIGTYPE_p_BBox) < 0) {
        croak("Type error in argument 2 of dbContext_getNumVertTracks. Expected %s", SWIGTYPE_p_BBox->name);
        XSRETURN(1);
    }
    result = (unsigned int )arg0->getNumVertTracks((BBox const &)*arg1);
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) result);
    XSRETURN(argvi);
}


XS(_wrap_dbContext_beginGCellGrids) {
    dbContext *arg0 ;
    int argvi = 0;
    itGCellGridLocal *result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: dbContext_beginGCellGrids(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_dbContext) < 0) {
        croak("Type error in argument 1 of dbContext_beginGCellGrids. Expected %s", SWIGTYPE_p_dbContext->name);
        XSRETURN(1);
    }
    result = new itGCellGridLocal (arg0->beginGCellGrids());    ST(argvi) = sv_newmortal();
    SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_itGCellGridLocal);
    XSRETURN(argvi);
}


XS(_wrap_dbContext_endGCellGrids) {
    dbContext *arg0 ;
    int argvi = 0;
    itGCellGridLocal *result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: dbContext_endGCellGrids(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_dbContext) < 0) {
        croak("Type error in argument 1 of dbContext_endGCellGrids. Expected %s", SWIGTYPE_p_dbContext->name);
        XSRETURN(1);
    }
    result = new itGCellGridLocal (arg0->endGCellGrids());    ST(argvi) = sv_newmortal();
    SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_itGCellGridLocal);
    XSRETURN(argvi);
}


XS(_wrap_dbContext_getGCellGrids) {
    dbContext *arg0 ;
    int argvi = 0;
    ctainerGCellGridsGlobal *result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: dbContext_getGCellGrids(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_dbContext) < 0) {
        croak("Type error in argument 1 of dbContext_getGCellGrids. Expected %s", SWIGTYPE_p_dbContext->name);
        XSRETURN(1);
    }
    ctainerGCellGridsGlobal const &_result_ref = arg0->getGCellGrids();
    result = (ctainerGCellGridsGlobal *) &_result_ref;
    ST(argvi) = sv_newmortal();
    SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_r_q_const__ctainerGCellGridsGlobal);
    XSRETURN(argvi);
}


XS(_wrap_dbContext_addGCellGrid) {
    dbContext *arg0 ;
    bool arg1 ;
    double arg2 ;
    unsigned int arg3 ;
    double arg4 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 5) || (items > 5)) 
    croak("Usage: dbContext_addGCellGrid(self,horiz,start,nGrids,space);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_dbContext) < 0) {
        croak("Type error in argument 1 of dbContext_addGCellGrid. Expected %s", SWIGTYPE_p_dbContext->name);
        XSRETURN(1);
    }
    arg1 = (bool )SvIV(ST(1));
    arg2 = (double )SvNV(ST(2));
    arg3 = (unsigned int )SvIV(ST(3));
    arg4 = (double )SvNV(ST(4));
    arg0->addGCellGrid(arg1,arg2,arg3,arg4);
    XSRETURN(argvi);
}


XS(_wrap_dbContext_isConsistent) {
    dbContext *arg0 ;
    int argvi = 0;
    bool result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: dbContext_isConsistent(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_dbContext) < 0) {
        croak("Type error in argument 1 of dbContext_isConsistent. Expected %s", SWIGTYPE_p_dbContext->name);
        XSRETURN(1);
    }
    result = (bool )arg0->isConsistent();
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) result);
    XSRETURN(argvi);
}


XS(_wrap_new_dbLayerGeom) {
    Rectangle *arg0 ;
    dbLayer *arg1 ;
    bool arg2 = false ;
    int argvi = 0;
    dbLayerGeom *result ;
    dXSARGS;
    
    if ((items < 2) || (items > 3)) 
    croak("Usage: new_dbLayerGeom(rect,layer,isVia);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_Rectangle) < 0) {
        croak("Type error in argument 1 of new_dbLayerGeom. Expected %s", SWIGTYPE_p_Rectangle->name);
        XSRETURN(1);
    }
    if (SWIG_ConvertPtr(ST(1),(void **) &arg1,SWIGTYPE_p_dbLayer) < 0) {
        croak("Type error in argument 2 of new_dbLayerGeom. Expected %s", SWIGTYPE_p_dbLayer->name);
        XSRETURN(1);
    }
    if (items > 2) {
        arg2 = (bool )SvIV(ST(2));
    }
    result = (dbLayerGeom *)new dbLayerGeom((Rectangle const &)*arg0,(dbLayer const &)*arg1,arg2);
    ST(argvi) = sv_newmortal();
    SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_dbLayerGeom);
    XSRETURN(argvi);
}


XS(_wrap_dbLayerGeom_getPolygon) {
    dbLayerGeom *arg0 ;
    int argvi = 0;
    vector<Point> *result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: dbLayerGeom_getPolygon(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_dbLayerGeom) < 0) {
        croak("Type error in argument 1 of dbLayerGeom_getPolygon. Expected %s", SWIGTYPE_p_dbLayerGeom->name);
        XSRETURN(1);
    }
    vector<Point> const &_result_ref = arg0->getPolygon();
    result = (vector<Point> *) &_result_ref;
    ST(argvi) = sv_newmortal();
    SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_vector_Point_);
    XSRETURN(argvi);
}


XS(_wrap_dbLayerGeom_isVia) {
    dbLayerGeom *arg0 ;
    int argvi = 0;
    bool result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: dbLayerGeom_isVia(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_dbLayerGeom) < 0) {
        croak("Type error in argument 1 of dbLayerGeom_isVia. Expected %s", SWIGTYPE_p_dbLayerGeom->name);
        XSRETURN(1);
    }
    result = (bool )arg0->isVia();
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) result);
    XSRETURN(argvi);
}


XS(_wrap_new_dbSite) {
    char *arg0 ;
    int arg1 ;
    Symmetry *arg2 ;
    double arg3 ;
    double arg4 ;
    int argvi = 0;
    dbSite *result ;
    dXSARGS;
    
    if ((items < 5) || (items > 5)) 
    croak("Usage: new_dbSite(name,type,sym,ht,wth);");
    if (! SvOK((SV*) ST(0))) {
        arg0 = 0; 
    }
    else {
        arg0 = (char *) SvPV(ST(0),PL_na); 
    }
    arg1 = (int )SvIV(ST(1));
    if (SWIG_ConvertPtr(ST(2),(void **) &arg2,SWIGTYPE_p_Symmetry) < 0) {
        croak("Type error in argument 3 of new_dbSite. Expected %s", SWIGTYPE_p_Symmetry->name);
        XSRETURN(1);
    }
    arg3 = (double )SvNV(ST(3));
    arg4 = (double )SvNV(ST(4));
    result = (dbSite *)new dbSite((char const *)arg0,(dbSite::Type )arg1,*arg2,arg3,arg4);
    ST(argvi) = sv_newmortal();
    SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_dbSite);
    XSRETURN(argvi);
}


XS(_wrap_delete_dbSite) {
    dbSite *arg0 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: delete_dbSite(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_dbSite) < 0) {
        croak("Type error in argument 1 of delete_dbSite. Expected %s", SWIGTYPE_p_dbSite->name);
        XSRETURN(1);
    }
    delete arg0;
    XSRETURN(argvi);
}


XS(_wrap_dbSite_getName) {
    dbSite *arg0 ;
    int argvi = 0;
    char *result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: dbSite_getName(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_dbSite) < 0) {
        croak("Type error in argument 1 of dbSite_getName. Expected %s", SWIGTYPE_p_dbSite->name);
        XSRETURN(1);
    }
    result = (char *)arg0->getName();
    ST(argvi) = sv_newmortal();
    sv_setpv((SV*)ST(argvi++),(char *) result);
    XSRETURN(argvi);
}


XS(_wrap_dbSite_getType) {
    dbSite *arg0 ;
    int argvi = 0;
    int result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: dbSite_getType(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_dbSite) < 0) {
        croak("Type error in argument 1 of dbSite_getType. Expected %s", SWIGTYPE_p_dbSite->name);
        XSRETURN(1);
    }
    result = (int )arg0->getType();
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) result);
    XSRETURN(argvi);
}


XS(_wrap_dbSite_getSymmetry) {
    dbSite *arg0 ;
    int argvi = 0;
    Symmetry *result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: dbSite_getSymmetry(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_dbSite) < 0) {
        croak("Type error in argument 1 of dbSite_getSymmetry. Expected %s", SWIGTYPE_p_dbSite->name);
        XSRETURN(1);
    }
    result = new Symmetry (arg0->getSymmetry());    ST(argvi) = sv_newmortal();
    SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_Symmetry);
    XSRETURN(argvi);
}


XS(_wrap_dbSite_getHeight) {
    dbSite *arg0 ;
    int argvi = 0;
    double result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: dbSite_getHeight(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_dbSite) < 0) {
        croak("Type error in argument 1 of dbSite_getHeight. Expected %s", SWIGTYPE_p_dbSite->name);
        XSRETURN(1);
    }
    result = (double )arg0->getHeight();
    ST(argvi) = sv_newmortal();
    sv_setnv(ST(argvi++), (double) result);
    XSRETURN(argvi);
}


XS(_wrap_dbSite_getWidth) {
    dbSite *arg0 ;
    int argvi = 0;
    double result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: dbSite_getWidth(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_dbSite) < 0) {
        croak("Type error in argument 1 of dbSite_getWidth. Expected %s", SWIGTYPE_p_dbSite->name);
        XSRETURN(1);
    }
    result = (double )arg0->getWidth();
    ST(argvi) = sv_newmortal();
    sv_setnv(ST(argvi++), (double) result);
    XSRETURN(argvi);
}


XS(_wrap_new_dbLayer) {
    char *arg0 ;
    unsigned int arg1 ;
    int arg2 ;
    int arg3 ;
    unsigned int arg4 ;
    unsigned int arg5 ;
    unsigned int arg6 ;
    unsigned int arg7 ;
    unsigned int arg8 ;
    unsigned int arg9 ;
    double arg10 ;
    double arg11 ;
    double arg12 ;
    double arg13 ;
    int argvi = 0;
    dbLayer *result ;
    dXSARGS;
    
    if ((items < 14) || (items > 14)) 
    croak("Usage: new_dbLayer(name,index,type,dir,pitch,height,width,thickness,spacing,shrinkage,capMult,edgeCap,unitRes,unitCap);");
    if (! SvOK((SV*) ST(0))) {
        arg0 = 0; 
    }
    else {
        arg0 = (char *) SvPV(ST(0),PL_na); 
    }
    arg1 = (unsigned int )SvIV(ST(1));
    arg2 = (int )SvIV(ST(2));
    arg3 = (int )SvIV(ST(3));
    arg4 = (unsigned int )SvIV(ST(4));
    arg5 = (unsigned int )SvIV(ST(5));
    arg6 = (unsigned int )SvIV(ST(6));
    arg7 = (unsigned int )SvIV(ST(7));
    arg8 = (unsigned int )SvIV(ST(8));
    arg9 = (unsigned int )SvIV(ST(9));
    arg10 = (double )SvNV(ST(10));
    arg11 = (double )SvNV(ST(11));
    arg12 = (double )SvNV(ST(12));
    arg13 = (double )SvNV(ST(13));
    result = (dbLayer *)new dbLayer((char const *)arg0,arg1,(dbLayer::Type )arg2,(dbLayer::Dir )arg3,arg4,arg5,arg6,arg7,arg8,arg9,arg10,arg11,arg12,arg13);
    ST(argvi) = sv_newmortal();
    SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_dbLayer);
    XSRETURN(argvi);
}


XS(_wrap_delete_dbLayer) {
    dbLayer *arg0 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: delete_dbLayer(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_dbLayer) < 0) {
        croak("Type error in argument 1 of delete_dbLayer. Expected %s", SWIGTYPE_p_dbLayer->name);
        XSRETURN(1);
    }
    delete arg0;
    XSRETURN(argvi);
}


XS(_wrap_dbLayer_getName) {
    dbLayer *arg0 ;
    int argvi = 0;
    char *result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: dbLayer_getName(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_dbLayer) < 0) {
        croak("Type error in argument 1 of dbLayer_getName. Expected %s", SWIGTYPE_p_dbLayer->name);
        XSRETURN(1);
    }
    result = (char *)arg0->getName();
    ST(argvi) = sv_newmortal();
    sv_setpv((SV*)ST(argvi++),(char *) result);
    XSRETURN(argvi);
}


XS(_wrap_dbLayer_getType) {
    dbLayer *arg0 ;
    int argvi = 0;
    int result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: dbLayer_getType(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_dbLayer) < 0) {
        croak("Type error in argument 1 of dbLayer_getType. Expected %s", SWIGTYPE_p_dbLayer->name);
        XSRETURN(1);
    }
    result = (int )arg0->getType();
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) result);
    XSRETURN(argvi);
}


XS(_wrap_dbLayer_getDirection) {
    dbLayer *arg0 ;
    int argvi = 0;
    int result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: dbLayer_getDirection(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_dbLayer) < 0) {
        croak("Type error in argument 1 of dbLayer_getDirection. Expected %s", SWIGTYPE_p_dbLayer->name);
        XSRETURN(1);
    }
    result = (int )arg0->getDirection();
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) result);
    XSRETURN(argvi);
}


XS(_wrap_dbLayer_getPitch) {
    dbLayer *arg0 ;
    int argvi = 0;
    unsigned int result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: dbLayer_getPitch(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_dbLayer) < 0) {
        croak("Type error in argument 1 of dbLayer_getPitch. Expected %s", SWIGTYPE_p_dbLayer->name);
        XSRETURN(1);
    }
    result = (unsigned int )arg0->getPitch();
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) result);
    XSRETURN(argvi);
}


XS(_wrap_dbLayer_getHeight) {
    dbLayer *arg0 ;
    int argvi = 0;
    unsigned int result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: dbLayer_getHeight(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_dbLayer) < 0) {
        croak("Type error in argument 1 of dbLayer_getHeight. Expected %s", SWIGTYPE_p_dbLayer->name);
        XSRETURN(1);
    }
    result = (unsigned int )arg0->getHeight();
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) result);
    XSRETURN(argvi);
}


XS(_wrap_dbLayer_getThickness) {
    dbLayer *arg0 ;
    int argvi = 0;
    unsigned int result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: dbLayer_getThickness(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_dbLayer) < 0) {
        croak("Type error in argument 1 of dbLayer_getThickness. Expected %s", SWIGTYPE_p_dbLayer->name);
        XSRETURN(1);
    }
    result = (unsigned int )arg0->getThickness();
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) result);
    XSRETURN(argvi);
}


XS(_wrap_dbLayer_getShrinkage) {
    dbLayer *arg0 ;
    int argvi = 0;
    unsigned int result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: dbLayer_getShrinkage(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_dbLayer) < 0) {
        croak("Type error in argument 1 of dbLayer_getShrinkage. Expected %s", SWIGTYPE_p_dbLayer->name);
        XSRETURN(1);
    }
    result = (unsigned int )arg0->getShrinkage();
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) result);
    XSRETURN(argvi);
}


XS(_wrap_dbLayer_getCapMult) {
    dbLayer *arg0 ;
    int argvi = 0;
    double result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: dbLayer_getCapMult(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_dbLayer) < 0) {
        croak("Type error in argument 1 of dbLayer_getCapMult. Expected %s", SWIGTYPE_p_dbLayer->name);
        XSRETURN(1);
    }
    result = (double )arg0->getCapMult();
    ST(argvi) = sv_newmortal();
    sv_setnv(ST(argvi++), (double) result);
    XSRETURN(argvi);
}


XS(_wrap_dbLayer_getEdgeCap) {
    dbLayer *arg0 ;
    int argvi = 0;
    double result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: dbLayer_getEdgeCap(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_dbLayer) < 0) {
        croak("Type error in argument 1 of dbLayer_getEdgeCap. Expected %s", SWIGTYPE_p_dbLayer->name);
        XSRETURN(1);
    }
    result = (double )arg0->getEdgeCap();
    ST(argvi) = sv_newmortal();
    sv_setnv(ST(argvi++), (double) result);
    XSRETURN(argvi);
}


XS(_wrap_dbLayer_getWidth) {
    dbLayer *arg0 ;
    int argvi = 0;
    unsigned int result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: dbLayer_getWidth(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_dbLayer) < 0) {
        croak("Type error in argument 1 of dbLayer_getWidth. Expected %s", SWIGTYPE_p_dbLayer->name);
        XSRETURN(1);
    }
    result = (unsigned int )arg0->getWidth();
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) result);
    XSRETURN(argvi);
}


XS(_wrap_dbLayer_getSpacing) {
    dbLayer *arg0 ;
    int argvi = 0;
    unsigned int result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: dbLayer_getSpacing(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_dbLayer) < 0) {
        croak("Type error in argument 1 of dbLayer_getSpacing. Expected %s", SWIGTYPE_p_dbLayer->name);
        XSRETURN(1);
    }
    result = (unsigned int )arg0->getSpacing();
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) result);
    XSRETURN(argvi);
}


XS(_wrap_dbLayer_getUnitRes) {
    dbLayer *arg0 ;
    int argvi = 0;
    double result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: dbLayer_getUnitRes(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_dbLayer) < 0) {
        croak("Type error in argument 1 of dbLayer_getUnitRes. Expected %s", SWIGTYPE_p_dbLayer->name);
        XSRETURN(1);
    }
    result = (double )arg0->getUnitRes();
    ST(argvi) = sv_newmortal();
    sv_setnv(ST(argvi++), (double) result);
    XSRETURN(argvi);
}


XS(_wrap_dbLayer_getUnitCap) {
    dbLayer *arg0 ;
    int argvi = 0;
    double result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: dbLayer_getUnitCap(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_dbLayer) < 0) {
        croak("Type error in argument 1 of dbLayer_getUnitCap. Expected %s", SWIGTYPE_p_dbLayer->name);
        XSRETURN(1);
    }
    result = (double )arg0->getUnitCap();
    ST(argvi) = sv_newmortal();
    sv_setnv(ST(argvi++), (double) result);
    XSRETURN(argvi);
}


XS(_wrap_dbLayer_getNumTracks) {
    dbLayer *arg0 ;
    int argvi = 0;
    unsigned int result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: dbLayer_getNumTracks(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_dbLayer) < 0) {
        croak("Type error in argument 1 of dbLayer_getNumTracks. Expected %s", SWIGTYPE_p_dbLayer->name);
        XSRETURN(1);
    }
    result = (unsigned int )arg0->getNumTracks();
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) result);
    XSRETURN(argvi);
}


XS(_wrap_dbLayer_getIndex) {
    dbLayer *arg0 ;
    int argvi = 0;
    unsigned int result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: dbLayer_getIndex(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_dbLayer) < 0) {
        croak("Type error in argument 1 of dbLayer_getIndex. Expected %s", SWIGTYPE_p_dbLayer->name);
        XSRETURN(1);
    }
    result = (unsigned int )arg0->getIndex();
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) result);
    XSRETURN(argvi);
}


XS(_wrap_new_dbRow) {
    dbSite *arg0 ;
    Point *arg1 ;
    int arg2 ;
    unsigned int arg3 ;
    unsigned int arg4 ;
    char *arg5 ;
    Orient *arg6 ;
    int argvi = 0;
    dbRow *result ;
    dXSARGS;
    
    if ((items < 7) || (items > 7)) 
    croak("Usage: new_dbRow(s,orig,dir,spc,n,name,ori);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_dbSite) < 0) {
        croak("Type error in argument 1 of new_dbRow. Expected %s", SWIGTYPE_p_dbSite->name);
        XSRETURN(1);
    }
    if (SWIG_ConvertPtr(ST(1),(void **) &arg1,SWIGTYPE_p_Point) < 0) {
        croak("Type error in argument 2 of new_dbRow. Expected %s", SWIGTYPE_p_Point->name);
        XSRETURN(1);
    }
    arg2 = (int )SvIV(ST(2));
    arg3 = (unsigned int )SvIV(ST(3));
    arg4 = (unsigned int )SvIV(ST(4));
    if (! SvOK((SV*) ST(5))) {
        arg5 = 0; 
    }
    else {
        arg5 = (char *) SvPV(ST(5),PL_na); 
    }
    if (SWIG_ConvertPtr(ST(6),(void **) &arg6,SWIGTYPE_p_Orient) < 0) {
        croak("Type error in argument 7 of new_dbRow. Expected %s", SWIGTYPE_p_Orient->name);
        XSRETURN(1);
    }
    result = (dbRow *)new dbRow(*arg0,*arg1,(dbRow::Dir )arg2,arg3,arg4,(char const *)arg5,*arg6);
    ST(argvi) = sv_newmortal();
    SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_dbRow);
    XSRETURN(argvi);
}


XS(_wrap_delete_dbRow) {
    dbRow *arg0 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: delete_dbRow(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_dbRow) < 0) {
        croak("Type error in argument 1 of delete_dbRow. Expected %s", SWIGTYPE_p_dbRow->name);
        XSRETURN(1);
    }
    delete arg0;
    XSRETURN(argvi);
}


XS(_wrap_dbRow_getSite) {
    dbRow *arg0 ;
    int argvi = 0;
    dbSite *result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: dbRow_getSite(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_dbRow) < 0) {
        croak("Type error in argument 1 of dbRow_getSite. Expected %s", SWIGTYPE_p_dbRow->name);
        XSRETURN(1);
    }
    dbSite const &_result_ref = arg0->getSite();
    result = (dbSite *) &_result_ref;
    ST(argvi) = sv_newmortal();
    SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_dbSite);
    XSRETURN(argvi);
}


XS(_wrap_dbRow_getOrigin) {
    dbRow *arg0 ;
    int argvi = 0;
    Point *result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: dbRow_getOrigin(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_dbRow) < 0) {
        croak("Type error in argument 1 of dbRow_getOrigin. Expected %s", SWIGTYPE_p_dbRow->name);
        XSRETURN(1);
    }
    result = new Point (arg0->getOrigin());    ST(argvi) = sv_newmortal();
    SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_Point);
    XSRETURN(argvi);
}


XS(_wrap_dbRow_getDirection) {
    dbRow *arg0 ;
    int argvi = 0;
    int result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: dbRow_getDirection(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_dbRow) < 0) {
        croak("Type error in argument 1 of dbRow_getDirection. Expected %s", SWIGTYPE_p_dbRow->name);
        XSRETURN(1);
    }
    result = (int )arg0->getDirection();
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) result);
    XSRETURN(argvi);
}


XS(_wrap_dbRow_getSpacing) {
    dbRow *arg0 ;
    int argvi = 0;
    unsigned int result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: dbRow_getSpacing(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_dbRow) < 0) {
        croak("Type error in argument 1 of dbRow_getSpacing. Expected %s", SWIGTYPE_p_dbRow->name);
        XSRETURN(1);
    }
    result = (unsigned int )arg0->getSpacing();
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) result);
    XSRETURN(argvi);
}


XS(_wrap_dbRow_getOrientation) {
    dbRow *arg0 ;
    int argvi = 0;
    Orient *result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: dbRow_getOrientation(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_dbRow) < 0) {
        croak("Type error in argument 1 of dbRow_getOrientation. Expected %s", SWIGTYPE_p_dbRow->name);
        XSRETURN(1);
    }
    result = new Orient (arg0->getOrientation());    ST(argvi) = sv_newmortal();
    SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_Orient);
    XSRETURN(argvi);
}


XS(_wrap_dbRow_getNumSites) {
    dbRow *arg0 ;
    int argvi = 0;
    unsigned int result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: dbRow_getNumSites(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_dbRow) < 0) {
        croak("Type error in argument 1 of dbRow_getNumSites. Expected %s", SWIGTYPE_p_dbRow->name);
        XSRETURN(1);
    }
    result = (unsigned int )arg0->getNumSites();
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) result);
    XSRETURN(argvi);
}


XS(_wrap_dbRow_getName) {
    dbRow *arg0 ;
    int argvi = 0;
    char *result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: dbRow_getName(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_dbRow) < 0) {
        croak("Type error in argument 1 of dbRow_getName. Expected %s", SWIGTYPE_p_dbRow->name);
        XSRETURN(1);
    }
    result = (char *)arg0->getName();
    ST(argvi) = sv_newmortal();
    sv_setpv((SV*)ST(argvi++),(char *) result);
    XSRETURN(argvi);
}


XS(_wrap_dbRow_getLength) {
    dbRow *arg0 ;
    int argvi = 0;
    double result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: dbRow_getLength(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_dbRow) < 0) {
        croak("Type error in argument 1 of dbRow_getLength. Expected %s", SWIGTYPE_p_dbRow->name);
        XSRETURN(1);
    }
    result = (double )arg0->getLength();
    ST(argvi) = sv_newmortal();
    sv_setnv(ST(argvi++), (double) result);
    XSRETURN(argvi);
}


XS(_wrap_dbTrack_layer_get) {
    dbTrack *arg0 ;
    int argvi = 0;
    dbLayer *result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: dbTrack_layer_get(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_dbTrack) < 0) {
        croak("Type error in argument 1 of dbTrack_layer_get. Expected %s", SWIGTYPE_p_dbTrack->name);
        XSRETURN(1);
    }
    result = (dbLayer *)(dbLayer *)& (arg0->layer);
    ST(argvi) = sv_newmortal();
    SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_dbLayer);
    XSRETURN(argvi);
}


XS(_wrap_dbTrack_horizontal_set) {
    dbTrack *arg0 ;
    bool arg1 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) 
    croak("Usage: dbTrack_horizontal_set(self,value);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_dbTrack) < 0) {
        croak("Type error in argument 1 of dbTrack_horizontal_set. Expected %s", SWIGTYPE_p_dbTrack->name);
        XSRETURN(1);
    }
    arg1 = (bool )SvIV(ST(1));
    arg0->horizontal = arg1;
    XSRETURN(argvi);
}


XS(_wrap_dbTrack_horizontal_get) {
    dbTrack *arg0 ;
    int argvi = 0;
    bool result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: dbTrack_horizontal_get(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_dbTrack) < 0) {
        croak("Type error in argument 1 of dbTrack_horizontal_get. Expected %s", SWIGTYPE_p_dbTrack->name);
        XSRETURN(1);
    }
    result = (bool ) (arg0->horizontal);
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) result);
    XSRETURN(argvi);
}


XS(_wrap_dbTrack_start_set) {
    dbTrack *arg0 ;
    double arg1 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) 
    croak("Usage: dbTrack_start_set(self,value);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_dbTrack) < 0) {
        croak("Type error in argument 1 of dbTrack_start_set. Expected %s", SWIGTYPE_p_dbTrack->name);
        XSRETURN(1);
    }
    arg1 = (double )SvNV(ST(1));
    arg0->start = arg1;
    XSRETURN(argvi);
}


XS(_wrap_dbTrack_start_get) {
    dbTrack *arg0 ;
    int argvi = 0;
    double result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: dbTrack_start_get(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_dbTrack) < 0) {
        croak("Type error in argument 1 of dbTrack_start_get. Expected %s", SWIGTYPE_p_dbTrack->name);
        XSRETURN(1);
    }
    result = (double ) (arg0->start);
    ST(argvi) = sv_newmortal();
    sv_setnv(ST(argvi++), (double) result);
    XSRETURN(argvi);
}


XS(_wrap_dbTrack_numTracks_set) {
    dbTrack *arg0 ;
    unsigned int arg1 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) 
    croak("Usage: dbTrack_numTracks_set(self,value);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_dbTrack) < 0) {
        croak("Type error in argument 1 of dbTrack_numTracks_set. Expected %s", SWIGTYPE_p_dbTrack->name);
        XSRETURN(1);
    }
    arg1 = (unsigned int )SvIV(ST(1));
    arg0->numTracks = arg1;
    XSRETURN(argvi);
}


XS(_wrap_dbTrack_numTracks_get) {
    dbTrack *arg0 ;
    int argvi = 0;
    unsigned int result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: dbTrack_numTracks_get(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_dbTrack) < 0) {
        croak("Type error in argument 1 of dbTrack_numTracks_get. Expected %s", SWIGTYPE_p_dbTrack->name);
        XSRETURN(1);
    }
    result = (unsigned int ) (arg0->numTracks);
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) result);
    XSRETURN(argvi);
}


XS(_wrap_dbTrack_spacing_set) {
    dbTrack *arg0 ;
    double arg1 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) 
    croak("Usage: dbTrack_spacing_set(self,value);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_dbTrack) < 0) {
        croak("Type error in argument 1 of dbTrack_spacing_set. Expected %s", SWIGTYPE_p_dbTrack->name);
        XSRETURN(1);
    }
    arg1 = (double )SvNV(ST(1));
    arg0->spacing = arg1;
    XSRETURN(argvi);
}


XS(_wrap_dbTrack_spacing_get) {
    dbTrack *arg0 ;
    int argvi = 0;
    double result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: dbTrack_spacing_get(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_dbTrack) < 0) {
        croak("Type error in argument 1 of dbTrack_spacing_get. Expected %s", SWIGTYPE_p_dbTrack->name);
        XSRETURN(1);
    }
    result = (double ) (arg0->spacing);
    ST(argvi) = sv_newmortal();
    sv_setnv(ST(argvi++), (double) result);
    XSRETURN(argvi);
}


XS(_wrap_new_dbTrack) {
    dbLayer *arg0 ;
    bool arg1 ;
    double arg2 ;
    unsigned int arg3 ;
    double arg4 ;
    int argvi = 0;
    dbTrack *result ;
    dXSARGS;
    
    if ((items < 5) || (items > 5)) 
    croak("Usage: new_dbTrack(layr,horiz,strt,nTracks,spac);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_dbLayer) < 0) {
        croak("Type error in argument 1 of new_dbTrack. Expected %s", SWIGTYPE_p_dbLayer->name);
        XSRETURN(1);
    }
    arg1 = (bool )SvIV(ST(1));
    arg2 = (double )SvNV(ST(2));
    arg3 = (unsigned int )SvIV(ST(3));
    arg4 = (double )SvNV(ST(4));
    result = (dbTrack *)new dbTrack((dbLayer const &)*arg0,arg1,arg2,arg3,arg4);
    ST(argvi) = sv_newmortal();
    SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_dbTrack);
    XSRETURN(argvi);
}


XS(_wrap_dbGCellGrid_horizontal_set) {
    dbGCellGrid *arg0 ;
    bool arg1 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) 
    croak("Usage: dbGCellGrid_horizontal_set(self,value);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_dbGCellGrid) < 0) {
        croak("Type error in argument 1 of dbGCellGrid_horizontal_set. Expected %s", SWIGTYPE_p_dbGCellGrid->name);
        XSRETURN(1);
    }
    arg1 = (bool )SvIV(ST(1));
    arg0->horizontal = arg1;
    XSRETURN(argvi);
}


XS(_wrap_dbGCellGrid_horizontal_get) {
    dbGCellGrid *arg0 ;
    int argvi = 0;
    bool result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: dbGCellGrid_horizontal_get(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_dbGCellGrid) < 0) {
        croak("Type error in argument 1 of dbGCellGrid_horizontal_get. Expected %s", SWIGTYPE_p_dbGCellGrid->name);
        XSRETURN(1);
    }
    result = (bool ) (arg0->horizontal);
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) result);
    XSRETURN(argvi);
}


XS(_wrap_dbGCellGrid_start_set) {
    dbGCellGrid *arg0 ;
    double arg1 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) 
    croak("Usage: dbGCellGrid_start_set(self,value);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_dbGCellGrid) < 0) {
        croak("Type error in argument 1 of dbGCellGrid_start_set. Expected %s", SWIGTYPE_p_dbGCellGrid->name);
        XSRETURN(1);
    }
    arg1 = (double )SvNV(ST(1));
    arg0->start = arg1;
    XSRETURN(argvi);
}


XS(_wrap_dbGCellGrid_start_get) {
    dbGCellGrid *arg0 ;
    int argvi = 0;
    double result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: dbGCellGrid_start_get(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_dbGCellGrid) < 0) {
        croak("Type error in argument 1 of dbGCellGrid_start_get. Expected %s", SWIGTYPE_p_dbGCellGrid->name);
        XSRETURN(1);
    }
    result = (double ) (arg0->start);
    ST(argvi) = sv_newmortal();
    sv_setnv(ST(argvi++), (double) result);
    XSRETURN(argvi);
}


XS(_wrap_dbGCellGrid_numDivisions_set) {
    dbGCellGrid *arg0 ;
    unsigned int arg1 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) 
    croak("Usage: dbGCellGrid_numDivisions_set(self,value);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_dbGCellGrid) < 0) {
        croak("Type error in argument 1 of dbGCellGrid_numDivisions_set. Expected %s", SWIGTYPE_p_dbGCellGrid->name);
        XSRETURN(1);
    }
    arg1 = (unsigned int )SvIV(ST(1));
    arg0->numDivisions = arg1;
    XSRETURN(argvi);
}


XS(_wrap_dbGCellGrid_numDivisions_get) {
    dbGCellGrid *arg0 ;
    int argvi = 0;
    unsigned int result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: dbGCellGrid_numDivisions_get(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_dbGCellGrid) < 0) {
        croak("Type error in argument 1 of dbGCellGrid_numDivisions_get. Expected %s", SWIGTYPE_p_dbGCellGrid->name);
        XSRETURN(1);
    }
    result = (unsigned int ) (arg0->numDivisions);
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) result);
    XSRETURN(argvi);
}


XS(_wrap_dbGCellGrid_spacing_set) {
    dbGCellGrid *arg0 ;
    double arg1 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) 
    croak("Usage: dbGCellGrid_spacing_set(self,value);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_dbGCellGrid) < 0) {
        croak("Type error in argument 1 of dbGCellGrid_spacing_set. Expected %s", SWIGTYPE_p_dbGCellGrid->name);
        XSRETURN(1);
    }
    arg1 = (double )SvNV(ST(1));
    arg0->spacing = arg1;
    XSRETURN(argvi);
}


XS(_wrap_dbGCellGrid_spacing_get) {
    dbGCellGrid *arg0 ;
    int argvi = 0;
    double result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: dbGCellGrid_spacing_get(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_dbGCellGrid) < 0) {
        croak("Type error in argument 1 of dbGCellGrid_spacing_get. Expected %s", SWIGTYPE_p_dbGCellGrid->name);
        XSRETURN(1);
    }
    result = (double ) (arg0->spacing);
    ST(argvi) = sv_newmortal();
    sv_setnv(ST(argvi++), (double) result);
    XSRETURN(argvi);
}


XS(_wrap_new_dbGCellGrid) {
    bool arg0 ;
    double arg1 ;
    unsigned int arg2 ;
    double arg3 ;
    int argvi = 0;
    dbGCellGrid *result ;
    dXSARGS;
    
    if ((items < 4) || (items > 4)) 
    croak("Usage: new_dbGCellGrid(horiz,strt,nDivs,spac);");
    arg0 = (bool )SvIV(ST(0));
    arg1 = (double )SvNV(ST(1));
    arg2 = (unsigned int )SvIV(ST(2));
    arg3 = (double )SvNV(ST(3));
    result = (dbGCellGrid *)new dbGCellGrid(arg0,arg1,arg2,arg3);
    ST(argvi) = sv_newmortal();
    SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_dbGCellGrid);
    XSRETURN(argvi);
}


XS(_wrap_new_dbMasterCell) {
    char *arg0 ;
    char *arg1 ;
    char *arg2 ;
    double arg3 ;
    double arg4 ;
    Point *arg5 ;
    ctainerMasterPinsLocal *arg6 ;
    Symmetry *arg7 ;
    dbSite *arg8 ;
    int argvi = 0;
    dbMasterCell *result ;
    dXSARGS;
    
    if ((items < 9) || (items > 9)) 
    croak("Usage: new_dbMasterCell(name,type,sType,wth,ht,orig,pns,sym,site);");
    if (! SvOK((SV*) ST(0))) {
        arg0 = 0; 
    }
    else {
        arg0 = (char *) SvPV(ST(0),PL_na); 
    }
    if (! SvOK((SV*) ST(1))) {
        arg1 = 0; 
    }
    else {
        arg1 = (char *) SvPV(ST(1),PL_na); 
    }
    if (! SvOK((SV*) ST(2))) {
        arg2 = 0; 
    }
    else {
        arg2 = (char *) SvPV(ST(2),PL_na); 
    }
    arg3 = (double )SvNV(ST(3));
    arg4 = (double )SvNV(ST(4));
    if (SWIG_ConvertPtr(ST(5),(void **) &arg5,SWIGTYPE_p_Point) < 0) {
        croak("Type error in argument 6 of new_dbMasterCell. Expected %s", SWIGTYPE_p_Point->name);
        XSRETURN(1);
    }
    if (SWIG_ConvertPtr(ST(6),(void **) &arg6,SWIGTYPE_r_q_const__ctainerMasterPinsLocal) < 0) {
        croak("Type error in argument 7 of new_dbMasterCell. Expected %s", SWIGTYPE_r_q_const__ctainerMasterPinsLocal->name);
        XSRETURN(1);
    }
    if (SWIG_ConvertPtr(ST(7),(void **) &arg7,SWIGTYPE_p_Symmetry) < 0) {
        croak("Type error in argument 8 of new_dbMasterCell. Expected %s", SWIGTYPE_p_Symmetry->name);
        XSRETURN(1);
    }
    if (SWIG_ConvertPtr(ST(8),(void **) &arg8,SWIGTYPE_p_dbSite) < 0) {
        croak("Type error in argument 9 of new_dbMasterCell. Expected %s", SWIGTYPE_p_dbSite->name);
        XSRETURN(1);
    }
    result = (dbMasterCell *)new dbMasterCell(arg0,arg1,arg2,arg3,arg4,*arg5,(ctainerMasterPinsLocal const &)*arg6,*arg7,(dbSite const &)*arg8);
    ST(argvi) = sv_newmortal();
    SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_dbMasterCell);
    XSRETURN(argvi);
}


XS(_wrap_delete_dbMasterCell) {
    dbMasterCell *arg0 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: delete_dbMasterCell(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_dbMasterCell) < 0) {
        croak("Type error in argument 1 of delete_dbMasterCell. Expected %s", SWIGTYPE_p_dbMasterCell->name);
        XSRETURN(1);
    }
    delete arg0;
    XSRETURN(argvi);
}


XS(_wrap_dbMasterCell_pinsBegin) {
    dbMasterCell *arg0 ;
    int argvi = 0;
    itMasterPinLocal *result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: dbMasterCell_pinsBegin(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_dbMasterCell) < 0) {
        croak("Type error in argument 1 of dbMasterCell_pinsBegin. Expected %s", SWIGTYPE_p_dbMasterCell->name);
        XSRETURN(1);
    }
    result = new itMasterPinLocal (arg0->pinsBegin());    ST(argvi) = sv_newmortal();
    SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_itMasterPinLocal);
    XSRETURN(argvi);
}


XS(_wrap_dbMasterCell_pinsEnd) {
    dbMasterCell *arg0 ;
    int argvi = 0;
    itMasterPinLocal *result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: dbMasterCell_pinsEnd(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_dbMasterCell) < 0) {
        croak("Type error in argument 1 of dbMasterCell_pinsEnd. Expected %s", SWIGTYPE_p_dbMasterCell->name);
        XSRETURN(1);
    }
    result = new itMasterPinLocal (arg0->pinsEnd());    ST(argvi) = sv_newmortal();
    SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_itMasterPinLocal);
    XSRETURN(argvi);
}


XS(_wrap_dbMasterCell_getNumPins) {
    dbMasterCell *arg0 ;
    int argvi = 0;
    unsigned int result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: dbMasterCell_getNumPins(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_dbMasterCell) < 0) {
        croak("Type error in argument 1 of dbMasterCell_getNumPins. Expected %s", SWIGTYPE_p_dbMasterCell->name);
        XSRETURN(1);
    }
    result = (unsigned int )arg0->getNumPins();
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) result);
    XSRETURN(argvi);
}


XS(_wrap_dbMasterCell_getName) {
    dbMasterCell *arg0 ;
    int argvi = 0;
    char *result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: dbMasterCell_getName(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_dbMasterCell) < 0) {
        croak("Type error in argument 1 of dbMasterCell_getName. Expected %s", SWIGTYPE_p_dbMasterCell->name);
        XSRETURN(1);
    }
    result = (char *)arg0->getName();
    ST(argvi) = sv_newmortal();
    sv_setpv((SV*)ST(argvi++),(char *) result);
    XSRETURN(argvi);
}


XS(_wrap_dbMasterCell_getHeight) {
    dbMasterCell *arg0 ;
    int argvi = 0;
    double result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: dbMasterCell_getHeight(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_dbMasterCell) < 0) {
        croak("Type error in argument 1 of dbMasterCell_getHeight. Expected %s", SWIGTYPE_p_dbMasterCell->name);
        XSRETURN(1);
    }
    result = (double )arg0->getHeight();
    ST(argvi) = sv_newmortal();
    sv_setnv(ST(argvi++), (double) result);
    XSRETURN(argvi);
}


XS(_wrap_dbMasterCell_getWidth) {
    dbMasterCell *arg0 ;
    int argvi = 0;
    double result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: dbMasterCell_getWidth(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_dbMasterCell) < 0) {
        croak("Type error in argument 1 of dbMasterCell_getWidth. Expected %s", SWIGTYPE_p_dbMasterCell->name);
        XSRETURN(1);
    }
    result = (double )arg0->getWidth();
    ST(argvi) = sv_newmortal();
    sv_setnv(ST(argvi++), (double) result);
    XSRETURN(argvi);
}


XS(_wrap_dbMasterCell_getIndegree) {
    dbMasterCell *arg0 ;
    int argvi = 0;
    unsigned int result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: dbMasterCell_getIndegree(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_dbMasterCell) < 0) {
        croak("Type error in argument 1 of dbMasterCell_getIndegree. Expected %s", SWIGTYPE_p_dbMasterCell->name);
        XSRETURN(1);
    }
    result = (unsigned int )arg0->getIndegree();
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) result);
    XSRETURN(argvi);
}


XS(_wrap_dbMasterCell_getOutdegree) {
    dbMasterCell *arg0 ;
    int argvi = 0;
    unsigned int result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: dbMasterCell_getOutdegree(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_dbMasterCell) < 0) {
        croak("Type error in argument 1 of dbMasterCell_getOutdegree. Expected %s", SWIGTYPE_p_dbMasterCell->name);
        XSRETURN(1);
    }
    result = (unsigned int )arg0->getOutdegree();
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) result);
    XSRETURN(argvi);
}


XS(_wrap_dbMasterCell_getType) {
    dbMasterCell *arg0 ;
    int argvi = 0;
    dbMasterCellType *result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: dbMasterCell_getType(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_dbMasterCell) < 0) {
        croak("Type error in argument 1 of dbMasterCell_getType. Expected %s", SWIGTYPE_p_dbMasterCell->name);
        XSRETURN(1);
    }
    result = new dbMasterCellType (arg0->getType());    ST(argvi) = sv_newmortal();
    SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_dbMasterCellType);
    XSRETURN(argvi);
}


XS(_wrap_dbMasterCell_getObstacles) {
    dbMasterCell *arg0 ;
    int argvi = 0;
    ctainerLayerGeoms *result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: dbMasterCell_getObstacles(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_dbMasterCell) < 0) {
        croak("Type error in argument 1 of dbMasterCell_getObstacles. Expected %s", SWIGTYPE_p_dbMasterCell->name);
        XSRETURN(1);
    }
    ctainerLayerGeoms const &_result_ref = arg0->getObstacles();
    result = (ctainerLayerGeoms *) &_result_ref;
    ST(argvi) = sv_newmortal();
    SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_r_q_const__ctainerLayerGeoms);
    XSRETURN(argvi);
}


XS(_wrap_dbMasterCell_getSymmetry) {
    dbMasterCell *arg0 ;
    int argvi = 0;
    Symmetry *result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: dbMasterCell_getSymmetry(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_dbMasterCell) < 0) {
        croak("Type error in argument 1 of dbMasterCell_getSymmetry. Expected %s", SWIGTYPE_p_dbMasterCell->name);
        XSRETURN(1);
    }
    result = new Symmetry (arg0->getSymmetry());    ST(argvi) = sv_newmortal();
    SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_Symmetry);
    XSRETURN(argvi);
}


XS(_wrap_dbMasterCell_getSite) {
    dbMasterCell *arg0 ;
    int argvi = 0;
    dbSite *result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: dbMasterCell_getSite(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_dbMasterCell) < 0) {
        croak("Type error in argument 1 of dbMasterCell_getSite. Expected %s", SWIGTYPE_p_dbMasterCell->name);
        XSRETURN(1);
    }
    dbSite const &_result_ref = arg0->getSite();
    result = (dbSite *) &_result_ref;
    ST(argvi) = sv_newmortal();
    SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_dbSite);
    XSRETURN(argvi);
}


XS(_wrap_dbMasterCell_isCover) {
    dbMasterCell *arg0 ;
    int argvi = 0;
    bool result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: dbMasterCell_isCover(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_dbMasterCell) < 0) {
        croak("Type error in argument 1 of dbMasterCell_isCover. Expected %s", SWIGTYPE_p_dbMasterCell->name);
        XSRETURN(1);
    }
    result = (bool )arg0->isCover();
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) result);
    XSRETURN(argvi);
}


XS(_wrap_dbMasterCell_isRing) {
    dbMasterCell *arg0 ;
    int argvi = 0;
    bool result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: dbMasterCell_isRing(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_dbMasterCell) < 0) {
        croak("Type error in argument 1 of dbMasterCell_isRing. Expected %s", SWIGTYPE_p_dbMasterCell->name);
        XSRETURN(1);
    }
    result = (bool )arg0->isRing();
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) result);
    XSRETURN(argvi);
}


XS(_wrap_dbMasterCell_isBlock) {
    dbMasterCell *arg0 ;
    int argvi = 0;
    bool result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: dbMasterCell_isBlock(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_dbMasterCell) < 0) {
        croak("Type error in argument 1 of dbMasterCell_isBlock. Expected %s", SWIGTYPE_p_dbMasterCell->name);
        XSRETURN(1);
    }
    result = (bool )arg0->isBlock();
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) result);
    XSRETURN(argvi);
}


XS(_wrap_dbMasterCell_isCore) {
    dbMasterCell *arg0 ;
    int argvi = 0;
    bool result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: dbMasterCell_isCore(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_dbMasterCell) < 0) {
        croak("Type error in argument 1 of dbMasterCell_isCore. Expected %s", SWIGTYPE_p_dbMasterCell->name);
        XSRETURN(1);
    }
    result = (bool )arg0->isCore();
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) result);
    XSRETURN(argvi);
}


XS(_wrap_dbMasterCell_isPad) {
    dbMasterCell *arg0 ;
    int argvi = 0;
    bool result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: dbMasterCell_isPad(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_dbMasterCell) < 0) {
        croak("Type error in argument 1 of dbMasterCell_isPad. Expected %s", SWIGTYPE_p_dbMasterCell->name);
        XSRETURN(1);
    }
    result = (bool )arg0->isPad();
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) result);
    XSRETURN(argvi);
}


XS(_wrap_dbMasterCell_isEndCap) {
    dbMasterCell *arg0 ;
    int argvi = 0;
    bool result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: dbMasterCell_isEndCap(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_dbMasterCell) < 0) {
        croak("Type error in argument 1 of dbMasterCell_isEndCap. Expected %s", SWIGTYPE_p_dbMasterCell->name);
        XSRETURN(1);
    }
    result = (bool )arg0->isEndCap();
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) result);
    XSRETURN(argvi);
}


XS(_wrap_dbMasterCell_isExtPin) {
    dbMasterCell *arg0 ;
    int argvi = 0;
    bool result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: dbMasterCell_isExtPin(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_dbMasterCell) < 0) {
        croak("Type error in argument 1 of dbMasterCell_isExtPin. Expected %s", SWIGTYPE_p_dbMasterCell->name);
        XSRETURN(1);
    }
    result = (bool )arg0->isExtPin();
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) result);
    XSRETURN(argvi);
}


XS(_wrap_dbMasterCell_isUnknown) {
    dbMasterCell *arg0 ;
    int argvi = 0;
    bool result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: dbMasterCell_isUnknown(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_dbMasterCell) < 0) {
        croak("Type error in argument 1 of dbMasterCell_isUnknown. Expected %s", SWIGTYPE_p_dbMasterCell->name);
        XSRETURN(1);
    }
    result = (bool )arg0->isUnknown();
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) result);
    XSRETURN(argvi);
}


XS(_wrap_dbMasterCell_isFlipFlop) {
    dbMasterCell *arg0 ;
    int argvi = 0;
    bool result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: dbMasterCell_isFlipFlop(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_dbMasterCell) < 0) {
        croak("Type error in argument 1 of dbMasterCell_isFlipFlop. Expected %s", SWIGTYPE_p_dbMasterCell->name);
        XSRETURN(1);
    }
    result = (bool )arg0->isFlipFlop();
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) result);
    XSRETURN(argvi);
}


XS(_wrap_dbMasterCell_isLatch) {
    dbMasterCell *arg0 ;
    int argvi = 0;
    bool result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: dbMasterCell_isLatch(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_dbMasterCell) < 0) {
        croak("Type error in argument 1 of dbMasterCell_isLatch. Expected %s", SWIGTYPE_p_dbMasterCell->name);
        XSRETURN(1);
    }
    result = (bool )arg0->isLatch();
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) result);
    XSRETURN(argvi);
}


XS(_wrap_dbMasterCell_isInverter) {
    dbMasterCell *arg0 ;
    int argvi = 0;
    bool result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: dbMasterCell_isInverter(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_dbMasterCell) < 0) {
        croak("Type error in argument 1 of dbMasterCell_isInverter. Expected %s", SWIGTYPE_p_dbMasterCell->name);
        XSRETURN(1);
    }
    result = (bool )arg0->isInverter();
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) result);
    XSRETURN(argvi);
}


XS(_wrap_dbMasterCell_isBuffer) {
    dbMasterCell *arg0 ;
    int argvi = 0;
    bool result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: dbMasterCell_isBuffer(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_dbMasterCell) < 0) {
        croak("Type error in argument 1 of dbMasterCell_isBuffer. Expected %s", SWIGTYPE_p_dbMasterCell->name);
        XSRETURN(1);
    }
    result = (bool )arg0->isBuffer();
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) result);
    XSRETURN(argvi);
}


XS(_wrap_dbMasterCell_isNAND) {
    dbMasterCell *arg0 ;
    int argvi = 0;
    bool result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: dbMasterCell_isNAND(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_dbMasterCell) < 0) {
        croak("Type error in argument 1 of dbMasterCell_isNAND. Expected %s", SWIGTYPE_p_dbMasterCell->name);
        XSRETURN(1);
    }
    result = (bool )arg0->isNAND();
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) result);
    XSRETURN(argvi);
}


XS(_wrap_dbMasterCell_isNOR) {
    dbMasterCell *arg0 ;
    int argvi = 0;
    bool result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: dbMasterCell_isNOR(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_dbMasterCell) < 0) {
        croak("Type error in argument 1 of dbMasterCell_isNOR. Expected %s", SWIGTYPE_p_dbMasterCell->name);
        XSRETURN(1);
    }
    result = (bool )arg0->isNOR();
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) result);
    XSRETURN(argvi);
}


XS(_wrap_dbMasterCell_isCoreUnknown) {
    dbMasterCell *arg0 ;
    int argvi = 0;
    bool result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: dbMasterCell_isCoreUnknown(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_dbMasterCell) < 0) {
        croak("Type error in argument 1 of dbMasterCell_isCoreUnknown. Expected %s", SWIGTYPE_p_dbMasterCell->name);
        XSRETURN(1);
    }
    result = (bool )arg0->isCoreUnknown();
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) result);
    XSRETURN(argvi);
}


XS(_wrap_dbMasterCell_isPI) {
    dbMasterCell *arg0 ;
    int argvi = 0;
    bool result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: dbMasterCell_isPI(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_dbMasterCell) < 0) {
        croak("Type error in argument 1 of dbMasterCell_isPI. Expected %s", SWIGTYPE_p_dbMasterCell->name);
        XSRETURN(1);
    }
    result = (bool )arg0->isPI();
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) result);
    XSRETURN(argvi);
}


XS(_wrap_dbMasterCell_isPO) {
    dbMasterCell *arg0 ;
    int argvi = 0;
    bool result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: dbMasterCell_isPO(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_dbMasterCell) < 0) {
        croak("Type error in argument 1 of dbMasterCell_isPO. Expected %s", SWIGTYPE_p_dbMasterCell->name);
        XSRETURN(1);
    }
    result = (bool )arg0->isPO();
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) result);
    XSRETURN(argvi);
}


XS(_wrap_dbMasterCell_isPIO) {
    dbMasterCell *arg0 ;
    int argvi = 0;
    bool result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: dbMasterCell_isPIO(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_dbMasterCell) < 0) {
        croak("Type error in argument 1 of dbMasterCell_isPIO. Expected %s", SWIGTYPE_p_dbMasterCell->name);
        XSRETURN(1);
    }
    result = (bool )arg0->isPIO();
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) result);
    XSRETURN(argvi);
}


XS(_wrap_dbMasterCell_isPPower) {
    dbMasterCell *arg0 ;
    int argvi = 0;
    bool result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: dbMasterCell_isPPower(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_dbMasterCell) < 0) {
        croak("Type error in argument 1 of dbMasterCell_isPPower. Expected %s", SWIGTYPE_p_dbMasterCell->name);
        XSRETURN(1);
    }
    result = (bool )arg0->isPPower();
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) result);
    XSRETURN(argvi);
}


XS(_wrap_dbMasterCell_isPSpacer) {
    dbMasterCell *arg0 ;
    int argvi = 0;
    bool result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: dbMasterCell_isPSpacer(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_dbMasterCell) < 0) {
        croak("Type error in argument 1 of dbMasterCell_isPSpacer. Expected %s", SWIGTYPE_p_dbMasterCell->name);
        XSRETURN(1);
    }
    result = (bool )arg0->isPSpacer();
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) result);
    XSRETURN(argvi);
}


XS(_wrap_dbMasterCell_isPUnknown) {
    dbMasterCell *arg0 ;
    int argvi = 0;
    bool result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: dbMasterCell_isPUnknown(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_dbMasterCell) < 0) {
        croak("Type error in argument 1 of dbMasterCell_isPUnknown. Expected %s", SWIGTYPE_p_dbMasterCell->name);
        XSRETURN(1);
    }
    result = (bool )arg0->isPUnknown();
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) result);
    XSRETURN(argvi);
}


XS(_wrap_dbMasterCell_getRiseDelay) {
    dbMasterCell *arg0 ;
    int argvi = 0;
    double result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: dbMasterCell_getRiseDelay(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_dbMasterCell) < 0) {
        croak("Type error in argument 1 of dbMasterCell_getRiseDelay. Expected %s", SWIGTYPE_p_dbMasterCell->name);
        XSRETURN(1);
    }
    result = (double )arg0->getRiseDelay();
    ST(argvi) = sv_newmortal();
    sv_setnv(ST(argvi++), (double) result);
    XSRETURN(argvi);
}


XS(_wrap_dbMasterCell_getFallDelay) {
    dbMasterCell *arg0 ;
    int argvi = 0;
    double result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: dbMasterCell_getFallDelay(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_dbMasterCell) < 0) {
        croak("Type error in argument 1 of dbMasterCell_getFallDelay. Expected %s", SWIGTYPE_p_dbMasterCell->name);
        XSRETURN(1);
    }
    result = (double )arg0->getFallDelay();
    ST(argvi) = sv_newmortal();
    sv_setnv(ST(argvi++), (double) result);
    XSRETURN(argvi);
}


XS(_wrap_dbMasterCell_reOrientRec) {
    dbMasterCell *arg0 ;
    Rectangle *arg1 ;
    Orientation *arg2 ;
    int argvi = 0;
    Rectangle *result ;
    dXSARGS;
    
    if ((items < 3) || (items > 3)) 
    croak("Usage: dbMasterCell_reOrientRec(self,rec,orien);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_dbMasterCell) < 0) {
        croak("Type error in argument 1 of dbMasterCell_reOrientRec. Expected %s", SWIGTYPE_p_dbMasterCell->name);
        XSRETURN(1);
    }
    if (SWIG_ConvertPtr(ST(1),(void **) &arg1,SWIGTYPE_p_Rectangle) < 0) {
        croak("Type error in argument 2 of dbMasterCell_reOrientRec. Expected %s", SWIGTYPE_p_Rectangle->name);
        XSRETURN(1);
    }
    if (SWIG_ConvertPtr(ST(2),(void **) &arg2,SWIGTYPE_p_Orientation) < 0) {
        croak("Type error in argument 3 of dbMasterCell_reOrientRec. Expected %s", SWIGTYPE_p_Orientation->name);
        XSRETURN(1);
    }
    result = new Rectangle (arg0->reOrientRec((Rectangle const &)*arg1,(Orientation const &)*arg2));    ST(argvi) = sv_newmortal();
    SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_Rectangle);
    XSRETURN(argvi);
}


XS(_wrap_new_dbCell) {
    char *arg0 ;
    unsigned int arg1 ;
    dbMasterCell *arg2 ;
    ctainerPinsLocal *arg3 ;
    int argvi = 0;
    dbCell *result ;
    dXSARGS;
    
    if ((items < 4) || (items > 4)) 
    croak("Usage: new_dbCell(name,index,master,pins);");
    if (! SvOK((SV*) ST(0))) {
        arg0 = 0; 
    }
    else {
        arg0 = (char *) SvPV(ST(0),PL_na); 
    }
    arg1 = (unsigned int )SvIV(ST(1));
    if (SWIG_ConvertPtr(ST(2),(void **) &arg2,SWIGTYPE_p_dbMasterCell) < 0) {
        croak("Type error in argument 3 of new_dbCell. Expected %s", SWIGTYPE_p_dbMasterCell->name);
        XSRETURN(1);
    }
    if (SWIG_ConvertPtr(ST(3),(void **) &arg3,SWIGTYPE_r_ctainerPinsLocal) < 0) {
        croak("Type error in argument 4 of new_dbCell. Expected %s", SWIGTYPE_r_ctainerPinsLocal->name);
        XSRETURN(1);
    }
    result = (dbCell *)new dbCell((char const *)arg0,arg1,(dbMasterCell const &)*arg2,*arg3);
    ST(argvi) = sv_newmortal();
    SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_dbCell);
    XSRETURN(argvi);
}


XS(_wrap_delete_dbCell) {
    dbCell *arg0 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: delete_dbCell(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_dbCell) < 0) {
        croak("Type error in argument 1 of delete_dbCell. Expected %s", SWIGTYPE_p_dbCell->name);
        XSRETURN(1);
    }
    delete arg0;
    XSRETURN(argvi);
}


XS(_wrap_dbCell_pinsBegin) {
    dbCell *arg0 ;
    int argvi = 0;
    itPinLocal *result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: dbCell_pinsBegin(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_dbCell) < 0) {
        croak("Type error in argument 1 of dbCell_pinsBegin. Expected %s", SWIGTYPE_p_dbCell->name);
        XSRETURN(1);
    }
    result = new itPinLocal (arg0->pinsBegin());    ST(argvi) = sv_newmortal();
    SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_itPinLocal);
    XSRETURN(argvi);
}


XS(_wrap_dbCell_pinsEnd) {
    dbCell *arg0 ;
    int argvi = 0;
    itPinLocal *result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: dbCell_pinsEnd(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_dbCell) < 0) {
        croak("Type error in argument 1 of dbCell_pinsEnd. Expected %s", SWIGTYPE_p_dbCell->name);
        XSRETURN(1);
    }
    result = new itPinLocal (arg0->pinsEnd());    ST(argvi) = sv_newmortal();
    SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_itPinLocal);
    XSRETURN(argvi);
}


XS(_wrap_dbCell_netsBegin) {
    dbCell *arg0 ;
    int argvi = 0;
    itNetLocal *result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: dbCell_netsBegin(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_dbCell) < 0) {
        croak("Type error in argument 1 of dbCell_netsBegin. Expected %s", SWIGTYPE_p_dbCell->name);
        XSRETURN(1);
    }
    result = new itNetLocal (arg0->netsBegin());    ST(argvi) = sv_newmortal();
    SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_itNetLocal);
    XSRETURN(argvi);
}


XS(_wrap_dbCell_netsEnd) {
    dbCell *arg0 ;
    int argvi = 0;
    itNetLocal *result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: dbCell_netsEnd(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_dbCell) < 0) {
        croak("Type error in argument 1 of dbCell_netsEnd. Expected %s", SWIGTYPE_p_dbCell->name);
        XSRETURN(1);
    }
    result = new itNetLocal (arg0->netsEnd());    ST(argvi) = sv_newmortal();
    SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_itNetLocal);
    XSRETURN(argvi);
}


XS(_wrap_dbCell_loopPinsBegin) {
    dbCell *arg0 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: dbCell_loopPinsBegin(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_dbCell) < 0) {
        croak("Type error in argument 1 of dbCell_loopPinsBegin. Expected %s", SWIGTYPE_p_dbCell->name);
        XSRETURN(1);
    }
    arg0->loopPinsBegin();
    XSRETURN(argvi);
}


XS(_wrap_dbCell_loopPinsEnd) {
    dbCell *arg0 ;
    itPinLocal *arg1 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) 
    croak("Usage: dbCell_loopPinsEnd(self,itr);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_dbCell) < 0) {
        croak("Type error in argument 1 of dbCell_loopPinsEnd. Expected %s", SWIGTYPE_p_dbCell->name);
        XSRETURN(1);
    }
    if (SWIG_ConvertPtr(ST(1),(void **) &arg1,SWIGTYPE_p_itPinLocal) < 0) {
        croak("Type error in argument 2 of dbCell_loopPinsEnd. Expected %s", SWIGTYPE_p_itPinLocal->name);
        XSRETURN(1);
    }
    arg0->loopPinsEnd(*arg1);
    XSRETURN(argvi);
}


XS(_wrap_dbCell_loopNetsBegin) {
    dbCell *arg0 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: dbCell_loopNetsBegin(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_dbCell) < 0) {
        croak("Type error in argument 1 of dbCell_loopNetsBegin. Expected %s", SWIGTYPE_p_dbCell->name);
        XSRETURN(1);
    }
    arg0->loopNetsBegin();
    XSRETURN(argvi);
}


XS(_wrap_dbCell_loopNetsEnd) {
    dbCell *arg0 ;
    itNetLocal *arg1 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) 
    croak("Usage: dbCell_loopNetsEnd(self,itr);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_dbCell) < 0) {
        croak("Type error in argument 1 of dbCell_loopNetsEnd. Expected %s", SWIGTYPE_p_dbCell->name);
        XSRETURN(1);
    }
    if (SWIG_ConvertPtr(ST(1),(void **) &arg1,SWIGTYPE_p_itNetLocal) < 0) {
        croak("Type error in argument 2 of dbCell_loopNetsEnd. Expected %s", SWIGTYPE_p_itNetLocal->name);
        XSRETURN(1);
    }
    arg0->loopNetsEnd(*arg1);
    XSRETURN(argvi);
}


XS(_wrap_dbCell_getMaster) {
    dbCell *arg0 ;
    int argvi = 0;
    dbMasterCell *result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: dbCell_getMaster(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_dbCell) < 0) {
        croak("Type error in argument 1 of dbCell_getMaster. Expected %s", SWIGTYPE_p_dbCell->name);
        XSRETURN(1);
    }
    dbMasterCell const &_result_ref = arg0->getMaster();
    result = (dbMasterCell *) &_result_ref;
    ST(argvi) = sv_newmortal();
    SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_dbMasterCell);
    XSRETURN(argvi);
}


XS(_wrap_dbCell_getIndex) {
    dbCell *arg0 ;
    int argvi = 0;
    unsigned int result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: dbCell_getIndex(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_dbCell) < 0) {
        croak("Type error in argument 1 of dbCell_getIndex. Expected %s", SWIGTYPE_p_dbCell->name);
        XSRETURN(1);
    }
    result = (unsigned int )arg0->getIndex();
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) result);
    XSRETURN(argvi);
}


XS(_wrap_dbCell_getName) {
    dbCell *arg0 ;
    int argvi = 0;
    char *result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: dbCell_getName(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_dbCell) < 0) {
        croak("Type error in argument 1 of dbCell_getName. Expected %s", SWIGTYPE_p_dbCell->name);
        XSRETURN(1);
    }
    result = (char *)arg0->getName();
    ST(argvi) = sv_newmortal();
    sv_setpv((SV*)ST(argvi++),(char *) result);
    XSRETURN(argvi);
}


XS(_wrap_dbCell_getType) {
    dbCell *arg0 ;
    int argvi = 0;
    dbCellType *result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: dbCell_getType(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_dbCell) < 0) {
        croak("Type error in argument 1 of dbCell_getType. Expected %s", SWIGTYPE_p_dbCell->name);
        XSRETURN(1);
    }
    result = new dbCellType (arg0->getType());    ST(argvi) = sv_newmortal();
    SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_dbCellType);
    XSRETURN(argvi);
}


XS(_wrap_dbCell_getHeight) {
    dbCell *arg0 ;
    int argvi = 0;
    double result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: dbCell_getHeight(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_dbCell) < 0) {
        croak("Type error in argument 1 of dbCell_getHeight. Expected %s", SWIGTYPE_p_dbCell->name);
        XSRETURN(1);
    }
    result = (double )arg0->getHeight();
    ST(argvi) = sv_newmortal();
    sv_setnv(ST(argvi++), (double) result);
    XSRETURN(argvi);
}


XS(_wrap_dbCell_getWidth) {
    dbCell *arg0 ;
    int argvi = 0;
    double result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: dbCell_getWidth(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_dbCell) < 0) {
        croak("Type error in argument 1 of dbCell_getWidth. Expected %s", SWIGTYPE_p_dbCell->name);
        XSRETURN(1);
    }
    result = (double )arg0->getWidth();
    ST(argvi) = sv_newmortal();
    sv_setnv(ST(argvi++), (double) result);
    XSRETURN(argvi);
}


XS(_wrap_dbCell_getIndegree) {
    dbCell *arg0 ;
    int argvi = 0;
    unsigned int result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: dbCell_getIndegree(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_dbCell) < 0) {
        croak("Type error in argument 1 of dbCell_getIndegree. Expected %s", SWIGTYPE_p_dbCell->name);
        XSRETURN(1);
    }
    result = (unsigned int )arg0->getIndegree();
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) result);
    XSRETURN(argvi);
}


XS(_wrap_dbCell_getOutdegree) {
    dbCell *arg0 ;
    int argvi = 0;
    unsigned int result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: dbCell_getOutdegree(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_dbCell) < 0) {
        croak("Type error in argument 1 of dbCell_getOutdegree. Expected %s", SWIGTYPE_p_dbCell->name);
        XSRETURN(1);
    }
    result = (unsigned int )arg0->getOutdegree();
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) result);
    XSRETURN(argvi);
}


XS(_wrap_dbCell_getNumNets) {
    dbCell *arg0 ;
    int argvi = 0;
    unsigned int result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: dbCell_getNumNets(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_dbCell) < 0) {
        croak("Type error in argument 1 of dbCell_getNumNets. Expected %s", SWIGTYPE_p_dbCell->name);
        XSRETURN(1);
    }
    result = (unsigned int )arg0->getNumNets();
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) result);
    XSRETURN(argvi);
}


XS(_wrap_dbCell_getNumPins) {
    dbCell *arg0 ;
    int argvi = 0;
    unsigned int result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: dbCell_getNumPins(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_dbCell) < 0) {
        croak("Type error in argument 1 of dbCell_getNumPins. Expected %s", SWIGTYPE_p_dbCell->name);
        XSRETURN(1);
    }
    result = (unsigned int )arg0->getNumPins();
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) result);
    XSRETURN(argvi);
}


XS(_wrap_dbCell_isIO) {
    dbCell *arg0 ;
    int argvi = 0;
    bool result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: dbCell_isIO(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_dbCell) < 0) {
        croak("Type error in argument 1 of dbCell_isIO. Expected %s", SWIGTYPE_p_dbCell->name);
        XSRETURN(1);
    }
    result = (bool )arg0->isIO();
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) result);
    XSRETURN(argvi);
}


XS(_wrap_dbCell_isBlock) {
    dbCell *arg0 ;
    int argvi = 0;
    bool result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: dbCell_isBlock(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_dbCell) < 0) {
        croak("Type error in argument 1 of dbCell_isBlock. Expected %s", SWIGTYPE_p_dbCell->name);
        XSRETURN(1);
    }
    result = (bool )arg0->isBlock();
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) result);
    XSRETURN(argvi);
}


XS(_wrap_dbCell_isCore) {
    dbCell *arg0 ;
    int argvi = 0;
    bool result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: dbCell_isCore(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_dbCell) < 0) {
        croak("Type error in argument 1 of dbCell_isCore. Expected %s", SWIGTYPE_p_dbCell->name);
        XSRETURN(1);
    }
    result = (bool )arg0->isCore();
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) result);
    XSRETURN(argvi);
}


XS(_wrap_dbCell_isOther) {
    dbCell *arg0 ;
    int argvi = 0;
    bool result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: dbCell_isOther(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_dbCell) < 0) {
        croak("Type error in argument 1 of dbCell_isOther. Expected %s", SWIGTYPE_p_dbCell->name);
        XSRETURN(1);
    }
    result = (bool )arg0->isOther();
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) result);
    XSRETURN(argvi);
}


XS(_wrap_dbCell_isUnknown) {
    dbCell *arg0 ;
    int argvi = 0;
    bool result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: dbCell_isUnknown(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_dbCell) < 0) {
        croak("Type error in argument 1 of dbCell_isUnknown. Expected %s", SWIGTYPE_p_dbCell->name);
        XSRETURN(1);
    }
    result = (bool )arg0->isUnknown();
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) result);
    XSRETURN(argvi);
}


XS(_wrap_dbCell_isPI) {
    dbCell *arg0 ;
    int argvi = 0;
    bool result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: dbCell_isPI(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_dbCell) < 0) {
        croak("Type error in argument 1 of dbCell_isPI. Expected %s", SWIGTYPE_p_dbCell->name);
        XSRETURN(1);
    }
    result = (bool )arg0->isPI();
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) result);
    XSRETURN(argvi);
}


XS(_wrap_dbCell_isPO) {
    dbCell *arg0 ;
    int argvi = 0;
    bool result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: dbCell_isPO(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_dbCell) < 0) {
        croak("Type error in argument 1 of dbCell_isPO. Expected %s", SWIGTYPE_p_dbCell->name);
        XSRETURN(1);
    }
    result = (bool )arg0->isPO();
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) result);
    XSRETURN(argvi);
}


XS(_wrap_dbCell_isPIO) {
    dbCell *arg0 ;
    int argvi = 0;
    bool result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: dbCell_isPIO(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_dbCell) < 0) {
        croak("Type error in argument 1 of dbCell_isPIO. Expected %s", SWIGTYPE_p_dbCell->name);
        XSRETURN(1);
    }
    result = (bool )arg0->isPIO();
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) result);
    XSRETURN(argvi);
}


XS(_wrap_dbCell_isPOther) {
    dbCell *arg0 ;
    int argvi = 0;
    bool result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: dbCell_isPOther(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_dbCell) < 0) {
        croak("Type error in argument 1 of dbCell_isPOther. Expected %s", SWIGTYPE_p_dbCell->name);
        XSRETURN(1);
    }
    result = (bool )arg0->isPOther();
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) result);
    XSRETURN(argvi);
}


XS(_wrap_dbCell_isPUnknown) {
    dbCell *arg0 ;
    int argvi = 0;
    bool result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: dbCell_isPUnknown(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_dbCell) < 0) {
        croak("Type error in argument 1 of dbCell_isPUnknown. Expected %s", SWIGTYPE_p_dbCell->name);
        XSRETURN(1);
    }
    result = (bool )arg0->isPUnknown();
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) result);
    XSRETURN(argvi);
}


XS(_wrap_dbCell_isCC) {
    dbCell *arg0 ;
    int argvi = 0;
    bool result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: dbCell_isCC(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_dbCell) < 0) {
        croak("Type error in argument 1 of dbCell_isCC. Expected %s", SWIGTYPE_p_dbCell->name);
        XSRETURN(1);
    }
    result = (bool )arg0->isCC();
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) result);
    XSRETURN(argvi);
}


XS(_wrap_dbCell_isSC) {
    dbCell *arg0 ;
    int argvi = 0;
    bool result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: dbCell_isSC(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_dbCell) < 0) {
        croak("Type error in argument 1 of dbCell_isSC. Expected %s", SWIGTYPE_p_dbCell->name);
        XSRETURN(1);
    }
    result = (bool )arg0->isSC();
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) result);
    XSRETURN(argvi);
}


XS(_wrap_dbCell_isCoreOther) {
    dbCell *arg0 ;
    int argvi = 0;
    bool result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: dbCell_isCoreOther(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_dbCell) < 0) {
        croak("Type error in argument 1 of dbCell_isCoreOther. Expected %s", SWIGTYPE_p_dbCell->name);
        XSRETURN(1);
    }
    result = (bool )arg0->isCoreOther();
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) result);
    XSRETURN(argvi);
}


XS(_wrap_dbCell_isTimingNode) {
    dbCell *arg0 ;
    int argvi = 0;
    bool result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: dbCell_isTimingNode(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_dbCell) < 0) {
        croak("Type error in argument 1 of dbCell_isTimingNode. Expected %s", SWIGTYPE_p_dbCell->name);
        XSRETURN(1);
    }
    result = (bool )arg0->isTimingNode();
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) result);
    XSRETURN(argvi);
}


XS(_wrap_dbCell_isLatchNode) {
    dbCell *arg0 ;
    int argvi = 0;
    bool result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: dbCell_isLatchNode(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_dbCell) < 0) {
        croak("Type error in argument 1 of dbCell_isLatchNode. Expected %s", SWIGTYPE_p_dbCell->name);
        XSRETURN(1);
    }
    result = (bool )arg0->isLatchNode();
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) result);
    XSRETURN(argvi);
}


XS(_wrap_dbCell_isIgnoredTimingNode) {
    dbCell *arg0 ;
    int argvi = 0;
    bool result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: dbCell_isIgnoredTimingNode(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_dbCell) < 0) {
        croak("Type error in argument 1 of dbCell_isIgnoredTimingNode. Expected %s", SWIGTYPE_p_dbCell->name);
        XSRETURN(1);
    }
    result = (bool )arg0->isIgnoredTimingNode();
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) result);
    XSRETURN(argvi);
}


XS(_wrap_dbCell_getRiseDelay) {
    dbCell *arg0 ;
    int argvi = 0;
    double result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: dbCell_getRiseDelay(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_dbCell) < 0) {
        croak("Type error in argument 1 of dbCell_getRiseDelay. Expected %s", SWIGTYPE_p_dbCell->name);
        XSRETURN(1);
    }
    result = (double )arg0->getRiseDelay();
    ST(argvi) = sv_newmortal();
    sv_setnv(ST(argvi++), (double) result);
    XSRETURN(argvi);
}


XS(_wrap_dbCell_getFallDelay) {
    dbCell *arg0 ;
    int argvi = 0;
    double result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: dbCell_getFallDelay(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_dbCell) < 0) {
        croak("Type error in argument 1 of dbCell_getFallDelay. Expected %s", SWIGTYPE_p_dbCell->name);
        XSRETURN(1);
    }
    result = (double )arg0->getFallDelay();
    ST(argvi) = sv_newmortal();
    sv_setnv(ST(argvi++), (double) result);
    XSRETURN(argvi);
}


XS(_wrap_dbCell_commonPin) {
    dbCell *arg0 ;
    dbNet *arg1 ;
    int argvi = 0;
    dbPin *result ;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) 
    croak("Usage: dbCell_commonPin(self,net);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_dbCell) < 0) {
        croak("Type error in argument 1 of dbCell_commonPin. Expected %s", SWIGTYPE_p_dbCell->name);
        XSRETURN(1);
    }
    if (SWIG_ConvertPtr(ST(1),(void **) &arg1,SWIGTYPE_p_dbNet) < 0) {
        croak("Type error in argument 2 of dbCell_commonPin. Expected %s", SWIGTYPE_p_dbNet->name);
        XSRETURN(1);
    }
    result = (dbPin *)arg0->commonPin((dbNet const *)arg1);
    ST(argvi) = sv_newmortal();
    SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_dbPin);
    XSRETURN(argvi);
}


XS(_wrap_dbCell_commonPinIsCellInput) {
    dbCell *arg0 ;
    dbNet *arg1 ;
    int argvi = 0;
    bool result ;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) 
    croak("Usage: dbCell_commonPinIsCellInput(self,net);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_dbCell) < 0) {
        croak("Type error in argument 1 of dbCell_commonPinIsCellInput. Expected %s", SWIGTYPE_p_dbCell->name);
        XSRETURN(1);
    }
    if (SWIG_ConvertPtr(ST(1),(void **) &arg1,SWIGTYPE_p_dbNet) < 0) {
        croak("Type error in argument 2 of dbCell_commonPinIsCellInput. Expected %s", SWIGTYPE_p_dbNet->name);
        XSRETURN(1);
    }
    result = (bool )arg0->commonPinIsCellInput((dbNet const *)arg1);
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) result);
    XSRETURN(argvi);
}


XS(_wrap_dbCell_commonPinIsCellOutput) {
    dbCell *arg0 ;
    dbNet *arg1 ;
    int argvi = 0;
    bool result ;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) 
    croak("Usage: dbCell_commonPinIsCellOutput(self,net);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_dbCell) < 0) {
        croak("Type error in argument 1 of dbCell_commonPinIsCellOutput. Expected %s", SWIGTYPE_p_dbCell->name);
        XSRETURN(1);
    }
    if (SWIG_ConvertPtr(ST(1),(void **) &arg1,SWIGTYPE_p_dbNet) < 0) {
        croak("Type error in argument 2 of dbCell_commonPinIsCellOutput. Expected %s", SWIGTYPE_p_dbNet->name);
        XSRETURN(1);
    }
    result = (bool )arg0->commonPinIsCellOutput((dbNet const *)arg1);
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) result);
    XSRETURN(argvi);
}


XS(_wrap_dbCell_isInputPad) {
    dbCell *arg0 ;
    int argvi = 0;
    bool result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: dbCell_isInputPad(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_dbCell) < 0) {
        croak("Type error in argument 1 of dbCell_isInputPad. Expected %s", SWIGTYPE_p_dbCell->name);
        XSRETURN(1);
    }
    result = (bool )arg0->isInputPad();
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) result);
    XSRETURN(argvi);
}


XS(_wrap_dbCell_isOutputPad) {
    dbCell *arg0 ;
    int argvi = 0;
    bool result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: dbCell_isOutputPad(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_dbCell) < 0) {
        croak("Type error in argument 1 of dbCell_isOutputPad. Expected %s", SWIGTYPE_p_dbCell->name);
        XSRETURN(1);
    }
    result = (bool )arg0->isOutputPad();
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) result);
    XSRETURN(argvi);
}


XS(_wrap_new_CompareCellsByName) {
    int argvi = 0;
    CompareCellsByName *result ;
    dXSARGS;
    
    if ((items < 0) || (items > 0)) 
    croak("Usage: new_CompareCellsByName();");
    result = (CompareCellsByName *)new CompareCellsByName();
    ST(argvi) = sv_newmortal();
    SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_CompareCellsByName);
    XSRETURN(argvi);
}


XS(_wrap_new_CompareCellsByStatus) {
    int argvi = 0;
    CompareCellsByStatus *result ;
    dXSARGS;
    
    if ((items < 0) || (items > 0)) 
    croak("Usage: new_CompareCellsByStatus();");
    result = (CompareCellsByStatus *)new CompareCellsByStatus();
    ST(argvi) = sv_newmortal();
    SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_CompareCellsByStatus);
    XSRETURN(argvi);
}


XS(_wrap_new_CompareMCsByName) {
    int argvi = 0;
    CompareMCsByName *result ;
    dXSARGS;
    
    if ((items < 0) || (items > 0)) 
    croak("Usage: new_CompareMCsByName();");
    result = (CompareMCsByName *)new CompareMCsByName();
    ST(argvi) = sv_newmortal();
    SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_CompareMCsByName);
    XSRETURN(argvi);
}


XS(_wrap_new_CompareCellsByCellIndex) {
    int argvi = 0;
    CompareCellsByCellIndex *result ;
    dXSARGS;
    
    if ((items < 0) || (items > 0)) 
    croak("Usage: new_CompareCellsByCellIndex();");
    result = (CompareCellsByCellIndex *)new CompareCellsByCellIndex();
    ST(argvi) = sv_newmortal();
    SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_CompareCellsByCellIndex);
    XSRETURN(argvi);
}


XS(_wrap_new_CompareCellsByDir) {
    dbNet *arg0 ;
    int argvi = 0;
    CompareCellsByDir *result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: new_CompareCellsByDir(curNet);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_dbNet) < 0) {
        croak("Type error in argument 1 of new_CompareCellsByDir. Expected %s", SWIGTYPE_p_dbNet->name);
        XSRETURN(1);
    }
    result = (CompareCellsByDir *)new CompareCellsByDir(arg0);
    ST(argvi) = sv_newmortal();
    SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_CompareCellsByDir);
    XSRETURN(argvi);
}


XS(_wrap_new_CompareObstaclesByXmin) {
    int argvi = 0;
    CompareObstaclesByXmin *result ;
    dXSARGS;
    
    if ((items < 0) || (items > 0)) 
    croak("Usage: new_CompareObstaclesByXmin();");
    result = (CompareObstaclesByXmin *)new CompareObstaclesByXmin();
    ST(argvi) = sv_newmortal();
    SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_CompareObstaclesByXmin);
    XSRETURN(argvi);
}


XS(_wrap_new_dbMasterPin) {
    char *arg0 ;
    char *arg1 ;
    char *arg2 ;
    char *arg3 ;
    BBox *arg4 ;
    Point *arg5 ;
    int argvi = 0;
    dbMasterPin *result ;
    dXSARGS;
    
    if ((items < 6) || (items > 6)) 
    croak("Usage: new_dbMasterPin(name,dir,use,shape,bbox,center);");
    if (! SvOK((SV*) ST(0))) {
        arg0 = 0; 
    }
    else {
        arg0 = (char *) SvPV(ST(0),PL_na); 
    }
    if (! SvOK((SV*) ST(1))) {
        arg1 = 0; 
    }
    else {
        arg1 = (char *) SvPV(ST(1),PL_na); 
    }
    if (! SvOK((SV*) ST(2))) {
        arg2 = 0; 
    }
    else {
        arg2 = (char *) SvPV(ST(2),PL_na); 
    }
    if (! SvOK((SV*) ST(3))) {
        arg3 = 0; 
    }
    else {
        arg3 = (char *) SvPV(ST(3),PL_na); 
    }
    if (SWIG_ConvertPtr(ST(4),(void **) &arg4,SWIGTYPE_p_BBox) < 0) {
        croak("Type error in argument 5 of new_dbMasterPin. Expected %s", SWIGTYPE_p_BBox->name);
        XSRETURN(1);
    }
    if (SWIG_ConvertPtr(ST(5),(void **) &arg5,SWIGTYPE_p_Point) < 0) {
        croak("Type error in argument 6 of new_dbMasterPin. Expected %s", SWIGTYPE_p_Point->name);
        XSRETURN(1);
    }
    result = (dbMasterPin *)new dbMasterPin((char const *)arg0,(char const *)arg1,(char const *)arg2,(char const *)arg3,*arg4,*arg5);
    ST(argvi) = sv_newmortal();
    SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_dbMasterPin);
    XSRETURN(argvi);
}


XS(_wrap_delete_dbMasterPin) {
    dbMasterPin *arg0 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: delete_dbMasterPin(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_dbMasterPin) < 0) {
        croak("Type error in argument 1 of delete_dbMasterPin. Expected %s", SWIGTYPE_p_dbMasterPin->name);
        XSRETURN(1);
    }
    delete arg0;
    XSRETURN(argvi);
}


XS(_wrap_dbMasterPin_setMasterCell) {
    dbMasterPin *arg0 ;
    dbMasterCell *arg1 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) 
    croak("Usage: dbMasterPin_setMasterCell(self,nCell);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_dbMasterPin) < 0) {
        croak("Type error in argument 1 of dbMasterPin_setMasterCell. Expected %s", SWIGTYPE_p_dbMasterPin->name);
        XSRETURN(1);
    }
    if (SWIG_ConvertPtr(ST(1),(void **) &arg1,SWIGTYPE_p_dbMasterCell) < 0) {
        croak("Type error in argument 2 of dbMasterPin_setMasterCell. Expected %s", SWIGTYPE_p_dbMasterCell->name);
        XSRETURN(1);
    }
    arg0->setMasterCell((dbMasterCell const &)*arg1);
    XSRETURN(argvi);
}


XS(_wrap_dbMasterPin_getCell) {
    dbMasterPin *arg0 ;
    int argvi = 0;
    dbMasterCell *result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: dbMasterPin_getCell(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_dbMasterPin) < 0) {
        croak("Type error in argument 1 of dbMasterPin_getCell. Expected %s", SWIGTYPE_p_dbMasterPin->name);
        XSRETURN(1);
    }
    dbMasterCell const &_result_ref = arg0->getCell();
    result = (dbMasterCell *) &_result_ref;
    ST(argvi) = sv_newmortal();
    SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_dbMasterCell);
    XSRETURN(argvi);
}


XS(_wrap_dbMasterPin_getName) {
    dbMasterPin *arg0 ;
    int argvi = 0;
    char *result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: dbMasterPin_getName(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_dbMasterPin) < 0) {
        croak("Type error in argument 1 of dbMasterPin_getName. Expected %s", SWIGTYPE_p_dbMasterPin->name);
        XSRETURN(1);
    }
    result = (char *)arg0->getName();
    ST(argvi) = sv_newmortal();
    sv_setpv((SV*)ST(argvi++),(char *) result);
    XSRETURN(argvi);
}


XS(_wrap_dbMasterPin_getCenter) {
    dbMasterPin *arg0 ;
    int argvi = 0;
    Point *result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: dbMasterPin_getCenter(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_dbMasterPin) < 0) {
        croak("Type error in argument 1 of dbMasterPin_getCenter. Expected %s", SWIGTYPE_p_dbMasterPin->name);
        XSRETURN(1);
    }
    result = new Point (arg0->getCenter());    ST(argvi) = sv_newmortal();
    SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_Point);
    XSRETURN(argvi);
}


XS(_wrap_dbMasterPin_getBBox) {
    dbMasterPin *arg0 ;
    int argvi = 0;
    BBox *result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: dbMasterPin_getBBox(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_dbMasterPin) < 0) {
        croak("Type error in argument 1 of dbMasterPin_getBBox. Expected %s", SWIGTYPE_p_dbMasterPin->name);
        XSRETURN(1);
    }
    result = new BBox (arg0->getBBox());    ST(argvi) = sv_newmortal();
    SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_BBox);
    XSRETURN(argvi);
}


XS(_wrap_dbMasterPin_getPorts) {
    dbMasterPin *arg0 ;
    int argvi = 0;
    ctainerLayerGeoms *result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: dbMasterPin_getPorts(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_dbMasterPin) < 0) {
        croak("Type error in argument 1 of dbMasterPin_getPorts. Expected %s", SWIGTYPE_p_dbMasterPin->name);
        XSRETURN(1);
    }
    ctainerLayerGeoms const &_result_ref = arg0->getPorts();
    result = (ctainerLayerGeoms *) &_result_ref;
    ST(argvi) = sv_newmortal();
    SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_r_q_const__ctainerLayerGeoms);
    XSRETURN(argvi);
}


XS(_wrap_dbMasterPin_getType) {
    dbMasterPin *arg0 ;
    int argvi = 0;
    char *result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: dbMasterPin_getType(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_dbMasterPin) < 0) {
        croak("Type error in argument 1 of dbMasterPin_getType. Expected %s", SWIGTYPE_p_dbMasterPin->name);
        XSRETURN(1);
    }
    result = (char *)arg0->getType();
    ST(argvi) = sv_newmortal();
    sv_setpv((SV*)ST(argvi++),(char *) result);
    XSRETURN(argvi);
}


XS(_wrap_dbMasterPin_getRiseDelay) {
    dbMasterPin *arg0 ;
    int argvi = 0;
    double result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: dbMasterPin_getRiseDelay(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_dbMasterPin) < 0) {
        croak("Type error in argument 1 of dbMasterPin_getRiseDelay. Expected %s", SWIGTYPE_p_dbMasterPin->name);
        XSRETURN(1);
    }
    result = (double )arg0->getRiseDelay();
    ST(argvi) = sv_newmortal();
    sv_setnv(ST(argvi++), (double) result);
    XSRETURN(argvi);
}


XS(_wrap_dbMasterPin_getFallDelay) {
    dbMasterPin *arg0 ;
    int argvi = 0;
    double result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: dbMasterPin_getFallDelay(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_dbMasterPin) < 0) {
        croak("Type error in argument 1 of dbMasterPin_getFallDelay. Expected %s", SWIGTYPE_p_dbMasterPin->name);
        XSRETURN(1);
    }
    result = (double )arg0->getFallDelay();
    ST(argvi) = sv_newmortal();
    sv_setnv(ST(argvi++), (double) result);
    XSRETURN(argvi);
}


XS(_wrap_dbMasterPin_getRiseResist) {
    dbMasterPin *arg0 ;
    int argvi = 0;
    double result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: dbMasterPin_getRiseResist(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_dbMasterPin) < 0) {
        croak("Type error in argument 1 of dbMasterPin_getRiseResist. Expected %s", SWIGTYPE_p_dbMasterPin->name);
        XSRETURN(1);
    }
    result = (double )arg0->getRiseResist();
    ST(argvi) = sv_newmortal();
    sv_setnv(ST(argvi++), (double) result);
    XSRETURN(argvi);
}


XS(_wrap_dbMasterPin_getFallResist) {
    dbMasterPin *arg0 ;
    int argvi = 0;
    double result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: dbMasterPin_getFallResist(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_dbMasterPin) < 0) {
        croak("Type error in argument 1 of dbMasterPin_getFallResist. Expected %s", SWIGTYPE_p_dbMasterPin->name);
        XSRETURN(1);
    }
    result = (double )arg0->getFallResist();
    ST(argvi) = sv_newmortal();
    sv_setnv(ST(argvi++), (double) result);
    XSRETURN(argvi);
}


XS(_wrap_dbMasterPin_getInputCap) {
    dbMasterPin *arg0 ;
    int argvi = 0;
    double result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: dbMasterPin_getInputCap(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_dbMasterPin) < 0) {
        croak("Type error in argument 1 of dbMasterPin_getInputCap. Expected %s", SWIGTYPE_p_dbMasterPin->name);
        XSRETURN(1);
    }
    result = (double )arg0->getInputCap();
    ST(argvi) = sv_newmortal();
    sv_setnv(ST(argvi++), (double) result);
    XSRETURN(argvi);
}


XS(_wrap_dbMasterPin_isShapeAbutment) {
    dbMasterPin *arg0 ;
    int argvi = 0;
    bool result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: dbMasterPin_isShapeAbutment(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_dbMasterPin) < 0) {
        croak("Type error in argument 1 of dbMasterPin_isShapeAbutment. Expected %s", SWIGTYPE_p_dbMasterPin->name);
        XSRETURN(1);
    }
    result = (bool )arg0->isShapeAbutment();
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) result);
    XSRETURN(argvi);
}


XS(_wrap_dbMasterPin_isShapeFeedthrough) {
    dbMasterPin *arg0 ;
    int argvi = 0;
    bool result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: dbMasterPin_isShapeFeedthrough(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_dbMasterPin) < 0) {
        croak("Type error in argument 1 of dbMasterPin_isShapeFeedthrough. Expected %s", SWIGTYPE_p_dbMasterPin->name);
        XSRETURN(1);
    }
    result = (bool )arg0->isShapeFeedthrough();
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) result);
    XSRETURN(argvi);
}


XS(_wrap_dbMasterPin_isShapeRing) {
    dbMasterPin *arg0 ;
    int argvi = 0;
    bool result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: dbMasterPin_isShapeRing(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_dbMasterPin) < 0) {
        croak("Type error in argument 1 of dbMasterPin_isShapeRing. Expected %s", SWIGTYPE_p_dbMasterPin->name);
        XSRETURN(1);
    }
    result = (bool )arg0->isShapeRing();
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) result);
    XSRETURN(argvi);
}


XS(_wrap_dbMasterPin_isShapeUnknown) {
    dbMasterPin *arg0 ;
    int argvi = 0;
    bool result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: dbMasterPin_isShapeUnknown(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_dbMasterPin) < 0) {
        croak("Type error in argument 1 of dbMasterPin_isShapeUnknown. Expected %s", SWIGTYPE_p_dbMasterPin->name);
        XSRETURN(1);
    }
    result = (bool )arg0->isShapeUnknown();
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) result);
    XSRETURN(argvi);
}


XS(_wrap_dbMasterPin_isUseSignal) {
    dbMasterPin *arg0 ;
    int argvi = 0;
    bool result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: dbMasterPin_isUseSignal(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_dbMasterPin) < 0) {
        croak("Type error in argument 1 of dbMasterPin_isUseSignal. Expected %s", SWIGTYPE_p_dbMasterPin->name);
        XSRETURN(1);
    }
    result = (bool )arg0->isUseSignal();
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) result);
    XSRETURN(argvi);
}


XS(_wrap_dbMasterPin_isUseAnalog) {
    dbMasterPin *arg0 ;
    int argvi = 0;
    bool result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: dbMasterPin_isUseAnalog(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_dbMasterPin) < 0) {
        croak("Type error in argument 1 of dbMasterPin_isUseAnalog. Expected %s", SWIGTYPE_p_dbMasterPin->name);
        XSRETURN(1);
    }
    result = (bool )arg0->isUseAnalog();
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) result);
    XSRETURN(argvi);
}


XS(_wrap_dbMasterPin_isUsePower) {
    dbMasterPin *arg0 ;
    int argvi = 0;
    bool result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: dbMasterPin_isUsePower(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_dbMasterPin) < 0) {
        croak("Type error in argument 1 of dbMasterPin_isUsePower. Expected %s", SWIGTYPE_p_dbMasterPin->name);
        XSRETURN(1);
    }
    result = (bool )arg0->isUsePower();
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) result);
    XSRETURN(argvi);
}


XS(_wrap_dbMasterPin_isUseGround) {
    dbMasterPin *arg0 ;
    int argvi = 0;
    bool result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: dbMasterPin_isUseGround(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_dbMasterPin) < 0) {
        croak("Type error in argument 1 of dbMasterPin_isUseGround. Expected %s", SWIGTYPE_p_dbMasterPin->name);
        XSRETURN(1);
    }
    result = (bool )arg0->isUseGround();
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) result);
    XSRETURN(argvi);
}


XS(_wrap_dbMasterPin_isUseClock) {
    dbMasterPin *arg0 ;
    int argvi = 0;
    bool result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: dbMasterPin_isUseClock(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_dbMasterPin) < 0) {
        croak("Type error in argument 1 of dbMasterPin_isUseClock. Expected %s", SWIGTYPE_p_dbMasterPin->name);
        XSRETURN(1);
    }
    result = (bool )arg0->isUseClock();
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) result);
    XSRETURN(argvi);
}


XS(_wrap_dbMasterPin_isUseUnknown) {
    dbMasterPin *arg0 ;
    int argvi = 0;
    bool result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: dbMasterPin_isUseUnknown(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_dbMasterPin) < 0) {
        croak("Type error in argument 1 of dbMasterPin_isUseUnknown. Expected %s", SWIGTYPE_p_dbMasterPin->name);
        XSRETURN(1);
    }
    result = (bool )arg0->isUseUnknown();
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) result);
    XSRETURN(argvi);
}


XS(_wrap_dbMasterPin_isDirOutput) {
    dbMasterPin *arg0 ;
    int argvi = 0;
    bool result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: dbMasterPin_isDirOutput(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_dbMasterPin) < 0) {
        croak("Type error in argument 1 of dbMasterPin_isDirOutput. Expected %s", SWIGTYPE_p_dbMasterPin->name);
        XSRETURN(1);
    }
    result = (bool )arg0->isDirOutput();
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) result);
    XSRETURN(argvi);
}


XS(_wrap_dbMasterPin_isDirInput) {
    dbMasterPin *arg0 ;
    int argvi = 0;
    bool result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: dbMasterPin_isDirInput(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_dbMasterPin) < 0) {
        croak("Type error in argument 1 of dbMasterPin_isDirInput. Expected %s", SWIGTYPE_p_dbMasterPin->name);
        XSRETURN(1);
    }
    result = (bool )arg0->isDirInput();
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) result);
    XSRETURN(argvi);
}


XS(_wrap_dbMasterPin_isDirInOut) {
    dbMasterPin *arg0 ;
    int argvi = 0;
    bool result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: dbMasterPin_isDirInOut(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_dbMasterPin) < 0) {
        croak("Type error in argument 1 of dbMasterPin_isDirInOut. Expected %s", SWIGTYPE_p_dbMasterPin->name);
        XSRETURN(1);
    }
    result = (bool )arg0->isDirInOut();
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) result);
    XSRETURN(argvi);
}


XS(_wrap_dbMasterPin_isDirOutputTristate) {
    dbMasterPin *arg0 ;
    int argvi = 0;
    bool result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: dbMasterPin_isDirOutputTristate(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_dbMasterPin) < 0) {
        croak("Type error in argument 1 of dbMasterPin_isDirOutputTristate. Expected %s", SWIGTYPE_p_dbMasterPin->name);
        XSRETURN(1);
    }
    result = (bool )arg0->isDirOutputTristate();
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) result);
    XSRETURN(argvi);
}


XS(_wrap_dbMasterPin_isDirFeedthrough) {
    dbMasterPin *arg0 ;
    int argvi = 0;
    bool result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: dbMasterPin_isDirFeedthrough(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_dbMasterPin) < 0) {
        croak("Type error in argument 1 of dbMasterPin_isDirFeedthrough. Expected %s", SWIGTYPE_p_dbMasterPin->name);
        XSRETURN(1);
    }
    result = (bool )arg0->isDirFeedthrough();
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) result);
    XSRETURN(argvi);
}


XS(_wrap_dbMasterPin_isDirUnknown) {
    dbMasterPin *arg0 ;
    int argvi = 0;
    bool result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: dbMasterPin_isDirUnknown(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_dbMasterPin) < 0) {
        croak("Type error in argument 1 of dbMasterPin_isDirUnknown. Expected %s", SWIGTYPE_p_dbMasterPin->name);
        XSRETURN(1);
    }
    result = (bool )arg0->isDirUnknown();
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) result);
    XSRETURN(argvi);
}


XS(_wrap_dbMasterPin_isJoint) {
    dbMasterPin *arg0 ;
    int argvi = 0;
    bool result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: dbMasterPin_isJoint(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_dbMasterPin) < 0) {
        croak("Type error in argument 1 of dbMasterPin_isJoint. Expected %s", SWIGTYPE_p_dbMasterPin->name);
        XSRETURN(1);
    }
    result = (bool )arg0->isJoint();
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) result);
    XSRETURN(argvi);
}


XS(_wrap_dbMasterPin_getJointPins) {
    dbMasterPin *arg0 ;
    int argvi = 0;
    ctainerMasterPinsLocal *result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: dbMasterPin_getJointPins(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_dbMasterPin) < 0) {
        croak("Type error in argument 1 of dbMasterPin_getJointPins. Expected %s", SWIGTYPE_p_dbMasterPin->name);
        XSRETURN(1);
    }
    ctainerMasterPinsLocal &_result_ref = arg0->getJointPins();
    result = (ctainerMasterPinsLocal *) &_result_ref;
    ST(argvi) = sv_newmortal();
    SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_r_ctainerMasterPinsLocal);
    XSRETURN(argvi);
}


XS(_wrap_new_dbPin) {
    dbMasterPin *arg0 ;
    unsigned int arg1 ;
    int argvi = 0;
    dbPin *result ;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) 
    croak("Usage: new_dbPin(master,index);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_dbMasterPin) < 0) {
        croak("Type error in argument 1 of new_dbPin. Expected %s", SWIGTYPE_p_dbMasterPin->name);
        XSRETURN(1);
    }
    arg1 = (unsigned int )SvIV(ST(1));
    result = (dbPin *)new dbPin((dbMasterPin const &)*arg0,arg1);
    ST(argvi) = sv_newmortal();
    SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_dbPin);
    XSRETURN(argvi);
}


XS(_wrap_delete_dbPin) {
    dbPin *arg0 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: delete_dbPin(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_dbPin) < 0) {
        croak("Type error in argument 1 of delete_dbPin. Expected %s", SWIGTYPE_p_dbPin->name);
        XSRETURN(1);
    }
    delete arg0;
    XSRETURN(argvi);
}


XS(_wrap_dbPin_setCell) {
    dbPin *arg0 ;
    dbCell *arg1 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) 
    croak("Usage: dbPin_setCell(self,cell);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_dbPin) < 0) {
        croak("Type error in argument 1 of dbPin_setCell. Expected %s", SWIGTYPE_p_dbPin->name);
        XSRETURN(1);
    }
    if (SWIG_ConvertPtr(ST(1),(void **) &arg1,SWIGTYPE_p_dbCell) < 0) {
        croak("Type error in argument 2 of dbPin_setCell. Expected %s", SWIGTYPE_p_dbCell->name);
        XSRETURN(1);
    }
    arg0->setCell((dbCell const &)*arg1);
    XSRETURN(argvi);
}


XS(_wrap_dbPin_setNet) {
    dbPin *arg0 ;
    dbNet *arg1 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) 
    croak("Usage: dbPin_setNet(self,net);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_dbPin) < 0) {
        croak("Type error in argument 1 of dbPin_setNet. Expected %s", SWIGTYPE_p_dbPin->name);
        XSRETURN(1);
    }
    if (SWIG_ConvertPtr(ST(1),(void **) &arg1,SWIGTYPE_p_dbNet) < 0) {
        croak("Type error in argument 2 of dbPin_setNet. Expected %s", SWIGTYPE_p_dbNet->name);
        XSRETURN(1);
    }
    arg0->setNet((dbNet const &)*arg1);
    XSRETURN(argvi);
}


XS(_wrap_dbPin_getMasterPinName) {
    dbPin *arg0 ;
    int argvi = 0;
    char *result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: dbPin_getMasterPinName(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_dbPin) < 0) {
        croak("Type error in argument 1 of dbPin_getMasterPinName. Expected %s", SWIGTYPE_p_dbPin->name);
        XSRETURN(1);
    }
    result = (char *)arg0->getMasterPinName();
    ST(argvi) = sv_newmortal();
    sv_setpv((SV*)ST(argvi++),(char *) result);
    XSRETURN(argvi);
}


XS(_wrap_dbPin_getCell) {
    dbPin *arg0 ;
    int argvi = 0;
    dbCell *result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: dbPin_getCell(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_dbPin) < 0) {
        croak("Type error in argument 1 of dbPin_getCell. Expected %s", SWIGTYPE_p_dbPin->name);
        XSRETURN(1);
    }
    dbCell const &_result_ref = arg0->getCell();
    result = (dbCell *) &_result_ref;
    ST(argvi) = sv_newmortal();
    SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_dbCell);
    XSRETURN(argvi);
}


XS(_wrap_dbPin_getNet) {
    dbPin *arg0 ;
    int argvi = 0;
    dbNet *result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: dbPin_getNet(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_dbPin) < 0) {
        croak("Type error in argument 1 of dbPin_getNet. Expected %s", SWIGTYPE_p_dbPin->name);
        XSRETURN(1);
    }
    dbNet const &_result_ref = arg0->getNet();
    result = (dbNet *) &_result_ref;
    ST(argvi) = sv_newmortal();
    SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_dbNet);
    XSRETURN(argvi);
}


XS(_wrap_dbPin_getIndex) {
    dbPin *arg0 ;
    int argvi = 0;
    unsigned int result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: dbPin_getIndex(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_dbPin) < 0) {
        croak("Type error in argument 1 of dbPin_getIndex. Expected %s", SWIGTYPE_p_dbPin->name);
        XSRETURN(1);
    }
    result = (unsigned int )arg0->getIndex();
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) result);
    XSRETURN(argvi);
}


XS(_wrap_dbPin_getMaster) {
    dbPin *arg0 ;
    int argvi = 0;
    dbMasterPin *result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: dbPin_getMaster(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_dbPin) < 0) {
        croak("Type error in argument 1 of dbPin_getMaster. Expected %s", SWIGTYPE_p_dbPin->name);
        XSRETURN(1);
    }
    dbMasterPin const &_result_ref = arg0->getMaster();
    result = (dbMasterPin *) &_result_ref;
    ST(argvi) = sv_newmortal();
    SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_dbMasterPin);
    XSRETURN(argvi);
}


XS(_wrap_dbPin_getType) {
    dbPin *arg0 ;
    int argvi = 0;
    char *result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: dbPin_getType(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_dbPin) < 0) {
        croak("Type error in argument 1 of dbPin_getType. Expected %s", SWIGTYPE_p_dbPin->name);
        XSRETURN(1);
    }
    result = (char *)arg0->getType();
    ST(argvi) = sv_newmortal();
    sv_setpv((SV*)ST(argvi++),(char *) result);
    XSRETURN(argvi);
}


XS(_wrap_dbPin_getRiseDelay) {
    dbPin *arg0 ;
    int argvi = 0;
    double result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: dbPin_getRiseDelay(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_dbPin) < 0) {
        croak("Type error in argument 1 of dbPin_getRiseDelay. Expected %s", SWIGTYPE_p_dbPin->name);
        XSRETURN(1);
    }
    result = (double )arg0->getRiseDelay();
    ST(argvi) = sv_newmortal();
    sv_setnv(ST(argvi++), (double) result);
    XSRETURN(argvi);
}


XS(_wrap_dbPin_getFallDelay) {
    dbPin *arg0 ;
    int argvi = 0;
    double result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: dbPin_getFallDelay(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_dbPin) < 0) {
        croak("Type error in argument 1 of dbPin_getFallDelay. Expected %s", SWIGTYPE_p_dbPin->name);
        XSRETURN(1);
    }
    result = (double )arg0->getFallDelay();
    ST(argvi) = sv_newmortal();
    sv_setnv(ST(argvi++), (double) result);
    XSRETURN(argvi);
}


XS(_wrap_dbPin_getRiseResist) {
    dbPin *arg0 ;
    int argvi = 0;
    double result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: dbPin_getRiseResist(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_dbPin) < 0) {
        croak("Type error in argument 1 of dbPin_getRiseResist. Expected %s", SWIGTYPE_p_dbPin->name);
        XSRETURN(1);
    }
    result = (double )arg0->getRiseResist();
    ST(argvi) = sv_newmortal();
    sv_setnv(ST(argvi++), (double) result);
    XSRETURN(argvi);
}


XS(_wrap_dbPin_getFallResist) {
    dbPin *arg0 ;
    int argvi = 0;
    double result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: dbPin_getFallResist(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_dbPin) < 0) {
        croak("Type error in argument 1 of dbPin_getFallResist. Expected %s", SWIGTYPE_p_dbPin->name);
        XSRETURN(1);
    }
    result = (double )arg0->getFallResist();
    ST(argvi) = sv_newmortal();
    sv_setnv(ST(argvi++), (double) result);
    XSRETURN(argvi);
}


XS(_wrap_dbPin_getInputCap) {
    dbPin *arg0 ;
    int argvi = 0;
    double result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: dbPin_getInputCap(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_dbPin) < 0) {
        croak("Type error in argument 1 of dbPin_getInputCap. Expected %s", SWIGTYPE_p_dbPin->name);
        XSRETURN(1);
    }
    result = (double )arg0->getInputCap();
    ST(argvi) = sv_newmortal();
    sv_setnv(ST(argvi++), (double) result);
    XSRETURN(argvi);
}


XS(_wrap_dbPin_isShapeAbutment) {
    dbPin *arg0 ;
    int argvi = 0;
    bool result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: dbPin_isShapeAbutment(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_dbPin) < 0) {
        croak("Type error in argument 1 of dbPin_isShapeAbutment. Expected %s", SWIGTYPE_p_dbPin->name);
        XSRETURN(1);
    }
    result = (bool )arg0->isShapeAbutment();
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) result);
    XSRETURN(argvi);
}


XS(_wrap_dbPin_isShapeFeedthrough) {
    dbPin *arg0 ;
    int argvi = 0;
    bool result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: dbPin_isShapeFeedthrough(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_dbPin) < 0) {
        croak("Type error in argument 1 of dbPin_isShapeFeedthrough. Expected %s", SWIGTYPE_p_dbPin->name);
        XSRETURN(1);
    }
    result = (bool )arg0->isShapeFeedthrough();
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) result);
    XSRETURN(argvi);
}


XS(_wrap_dbPin_isShapeRing) {
    dbPin *arg0 ;
    int argvi = 0;
    bool result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: dbPin_isShapeRing(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_dbPin) < 0) {
        croak("Type error in argument 1 of dbPin_isShapeRing. Expected %s", SWIGTYPE_p_dbPin->name);
        XSRETURN(1);
    }
    result = (bool )arg0->isShapeRing();
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) result);
    XSRETURN(argvi);
}


XS(_wrap_dbPin_isShapeUnknown) {
    dbPin *arg0 ;
    int argvi = 0;
    bool result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: dbPin_isShapeUnknown(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_dbPin) < 0) {
        croak("Type error in argument 1 of dbPin_isShapeUnknown. Expected %s", SWIGTYPE_p_dbPin->name);
        XSRETURN(1);
    }
    result = (bool )arg0->isShapeUnknown();
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) result);
    XSRETURN(argvi);
}


XS(_wrap_dbPin_isUseSignal) {
    dbPin *arg0 ;
    int argvi = 0;
    bool result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: dbPin_isUseSignal(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_dbPin) < 0) {
        croak("Type error in argument 1 of dbPin_isUseSignal. Expected %s", SWIGTYPE_p_dbPin->name);
        XSRETURN(1);
    }
    result = (bool )arg0->isUseSignal();
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) result);
    XSRETURN(argvi);
}


XS(_wrap_dbPin_isUseAnalog) {
    dbPin *arg0 ;
    int argvi = 0;
    bool result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: dbPin_isUseAnalog(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_dbPin) < 0) {
        croak("Type error in argument 1 of dbPin_isUseAnalog. Expected %s", SWIGTYPE_p_dbPin->name);
        XSRETURN(1);
    }
    result = (bool )arg0->isUseAnalog();
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) result);
    XSRETURN(argvi);
}


XS(_wrap_dbPin_isUsePower) {
    dbPin *arg0 ;
    int argvi = 0;
    bool result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: dbPin_isUsePower(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_dbPin) < 0) {
        croak("Type error in argument 1 of dbPin_isUsePower. Expected %s", SWIGTYPE_p_dbPin->name);
        XSRETURN(1);
    }
    result = (bool )arg0->isUsePower();
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) result);
    XSRETURN(argvi);
}


XS(_wrap_dbPin_isUseGround) {
    dbPin *arg0 ;
    int argvi = 0;
    bool result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: dbPin_isUseGround(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_dbPin) < 0) {
        croak("Type error in argument 1 of dbPin_isUseGround. Expected %s", SWIGTYPE_p_dbPin->name);
        XSRETURN(1);
    }
    result = (bool )arg0->isUseGround();
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) result);
    XSRETURN(argvi);
}


XS(_wrap_dbPin_isUseClock) {
    dbPin *arg0 ;
    int argvi = 0;
    bool result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: dbPin_isUseClock(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_dbPin) < 0) {
        croak("Type error in argument 1 of dbPin_isUseClock. Expected %s", SWIGTYPE_p_dbPin->name);
        XSRETURN(1);
    }
    result = (bool )arg0->isUseClock();
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) result);
    XSRETURN(argvi);
}


XS(_wrap_dbPin_isUseUnknown) {
    dbPin *arg0 ;
    int argvi = 0;
    bool result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: dbPin_isUseUnknown(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_dbPin) < 0) {
        croak("Type error in argument 1 of dbPin_isUseUnknown. Expected %s", SWIGTYPE_p_dbPin->name);
        XSRETURN(1);
    }
    result = (bool )arg0->isUseUnknown();
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) result);
    XSRETURN(argvi);
}


XS(_wrap_dbPin_isDirOutput) {
    dbPin *arg0 ;
    int argvi = 0;
    bool result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: dbPin_isDirOutput(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_dbPin) < 0) {
        croak("Type error in argument 1 of dbPin_isDirOutput. Expected %s", SWIGTYPE_p_dbPin->name);
        XSRETURN(1);
    }
    result = (bool )arg0->isDirOutput();
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) result);
    XSRETURN(argvi);
}


XS(_wrap_dbPin_isDirInput) {
    dbPin *arg0 ;
    int argvi = 0;
    bool result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: dbPin_isDirInput(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_dbPin) < 0) {
        croak("Type error in argument 1 of dbPin_isDirInput. Expected %s", SWIGTYPE_p_dbPin->name);
        XSRETURN(1);
    }
    result = (bool )arg0->isDirInput();
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) result);
    XSRETURN(argvi);
}


XS(_wrap_dbPin_isDirInOut) {
    dbPin *arg0 ;
    int argvi = 0;
    bool result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: dbPin_isDirInOut(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_dbPin) < 0) {
        croak("Type error in argument 1 of dbPin_isDirInOut. Expected %s", SWIGTYPE_p_dbPin->name);
        XSRETURN(1);
    }
    result = (bool )arg0->isDirInOut();
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) result);
    XSRETURN(argvi);
}


XS(_wrap_dbPin_isDirOutputTristate) {
    dbPin *arg0 ;
    int argvi = 0;
    bool result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: dbPin_isDirOutputTristate(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_dbPin) < 0) {
        croak("Type error in argument 1 of dbPin_isDirOutputTristate. Expected %s", SWIGTYPE_p_dbPin->name);
        XSRETURN(1);
    }
    result = (bool )arg0->isDirOutputTristate();
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) result);
    XSRETURN(argvi);
}


XS(_wrap_dbPin_isDirFeedthrough) {
    dbPin *arg0 ;
    int argvi = 0;
    bool result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: dbPin_isDirFeedthrough(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_dbPin) < 0) {
        croak("Type error in argument 1 of dbPin_isDirFeedthrough. Expected %s", SWIGTYPE_p_dbPin->name);
        XSRETURN(1);
    }
    result = (bool )arg0->isDirFeedthrough();
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) result);
    XSRETURN(argvi);
}


XS(_wrap_dbPin_isDirUnknown) {
    dbPin *arg0 ;
    int argvi = 0;
    bool result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: dbPin_isDirUnknown(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_dbPin) < 0) {
        croak("Type error in argument 1 of dbPin_isDirUnknown. Expected %s", SWIGTYPE_p_dbPin->name);
        XSRETURN(1);
    }
    result = (bool )arg0->isDirUnknown();
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) result);
    XSRETURN(argvi);
}


XS(_wrap_dbPin_isConnected) {
    dbPin *arg0 ;
    int argvi = 0;
    bool result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: dbPin_isConnected(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_dbPin) < 0) {
        croak("Type error in argument 1 of dbPin_isConnected. Expected %s", SWIGTYPE_p_dbPin->name);
        XSRETURN(1);
    }
    result = (bool )arg0->isConnected();
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) result);
    XSRETURN(argvi);
}


XS(_wrap_new_ComparePinsByDirAndName) {
    int argvi = 0;
    ComparePinsByDirAndName *result ;
    dXSARGS;
    
    if ((items < 0) || (items > 0)) 
    croak("Usage: new_ComparePinsByDirAndName();");
    result = (ComparePinsByDirAndName *)new ComparePinsByDirAndName();
    ST(argvi) = sv_newmortal();
    SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_ComparePinsByDirAndName);
    XSRETURN(argvi);
}


XS(_wrap_new_ComparePinsByCellIndexAndDir) {
    int argvi = 0;
    ComparePinsByCellIndexAndDir *result ;
    dXSARGS;
    
    if ((items < 0) || (items > 0)) 
    croak("Usage: new_ComparePinsByCellIndexAndDir();");
    result = (ComparePinsByCellIndexAndDir *)new ComparePinsByCellIndexAndDir();
    ST(argvi) = sv_newmortal();
    SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_ComparePinsByCellIndexAndDir);
    XSRETURN(argvi);
}


XS(_wrap_dbNet__cells_set) {
    dbNet *arg0 ;
    ctainerCellsLocal *arg1 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) 
    croak("Usage: dbNet__cells_set(self,value);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_dbNet) < 0) {
        croak("Type error in argument 1 of dbNet__cells_set. Expected %s", SWIGTYPE_p_dbNet->name);
        XSRETURN(1);
    }
    if (SWIG_ConvertPtr(ST(1),(void **) &arg1,SWIGTYPE_p_ctainerCellsLocal) < 0) {
        croak("Type error in argument 2 of dbNet__cells_set. Expected %s", SWIGTYPE_p_ctainerCellsLocal->name);
        XSRETURN(1);
    }
    arg0->_cells = *arg1;
    XSRETURN(argvi);
}


XS(_wrap_dbNet__cells_get) {
    dbNet *arg0 ;
    int argvi = 0;
    ctainerCellsLocal *result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: dbNet__cells_get(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_dbNet) < 0) {
        croak("Type error in argument 1 of dbNet__cells_get. Expected %s", SWIGTYPE_p_dbNet->name);
        XSRETURN(1);
    }
    result = (ctainerCellsLocal *)& (arg0->_cells);
    ST(argvi) = sv_newmortal();
    SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_ctainerCellsLocal);
    XSRETURN(argvi);
}


XS(_wrap_dbNet__pins_set) {
    dbNet *arg0 ;
    ctainerPinsLocal *arg1 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) 
    croak("Usage: dbNet__pins_set(self,value);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_dbNet) < 0) {
        croak("Type error in argument 1 of dbNet__pins_set. Expected %s", SWIGTYPE_p_dbNet->name);
        XSRETURN(1);
    }
    if (SWIG_ConvertPtr(ST(1),(void **) &arg1,SWIGTYPE_p_ctainerPinsLocal) < 0) {
        croak("Type error in argument 2 of dbNet__pins_set. Expected %s", SWIGTYPE_p_ctainerPinsLocal->name);
        XSRETURN(1);
    }
    arg0->_pins = *arg1;
    XSRETURN(argvi);
}


XS(_wrap_dbNet__pins_get) {
    dbNet *arg0 ;
    int argvi = 0;
    ctainerPinsLocal *result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: dbNet__pins_get(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_dbNet) < 0) {
        croak("Type error in argument 1 of dbNet__pins_get. Expected %s", SWIGTYPE_p_dbNet->name);
        XSRETURN(1);
    }
    result = (ctainerPinsLocal *)& (arg0->_pins);
    ST(argvi) = sv_newmortal();
    SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_ctainerPinsLocal);
    XSRETURN(argvi);
}


XS(_wrap_dbNet__wiring_set) {
    dbNet *arg0 ;
    ctainerLayerGeoms *arg1 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) 
    croak("Usage: dbNet__wiring_set(self,value);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_dbNet) < 0) {
        croak("Type error in argument 1 of dbNet__wiring_set. Expected %s", SWIGTYPE_p_dbNet->name);
        XSRETURN(1);
    }
    if (SWIG_ConvertPtr(ST(1),(void **) &arg1,SWIGTYPE_p_ctainerLayerGeoms) < 0) {
        croak("Type error in argument 2 of dbNet__wiring_set. Expected %s", SWIGTYPE_p_ctainerLayerGeoms->name);
        XSRETURN(1);
    }
    arg0->_wiring = *arg1;
    XSRETURN(argvi);
}


XS(_wrap_dbNet__wiring_get) {
    dbNet *arg0 ;
    int argvi = 0;
    ctainerLayerGeoms *result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: dbNet__wiring_get(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_dbNet) < 0) {
        croak("Type error in argument 1 of dbNet__wiring_get. Expected %s", SWIGTYPE_p_dbNet->name);
        XSRETURN(1);
    }
    result = (ctainerLayerGeoms *)& (arg0->_wiring);
    ST(argvi) = sv_newmortal();
    SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_ctainerLayerGeoms);
    XSRETURN(argvi);
}


XS(_wrap_dbNet__numOut_set) {
    dbNet *arg0 ;
    unsigned int arg1 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) 
    croak("Usage: dbNet__numOut_set(self,value);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_dbNet) < 0) {
        croak("Type error in argument 1 of dbNet__numOut_set. Expected %s", SWIGTYPE_p_dbNet->name);
        XSRETURN(1);
    }
    arg1 = (unsigned int )SvIV(ST(1));
    arg0->_numOut = arg1;
    XSRETURN(argvi);
}


XS(_wrap_dbNet__numOut_get) {
    dbNet *arg0 ;
    int argvi = 0;
    unsigned int result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: dbNet__numOut_get(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_dbNet) < 0) {
        croak("Type error in argument 1 of dbNet__numOut_get. Expected %s", SWIGTYPE_p_dbNet->name);
        XSRETURN(1);
    }
    result = (unsigned int ) (arg0->_numOut);
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) result);
    XSRETURN(argvi);
}


XS(_wrap_dbNet__numInOut_set) {
    dbNet *arg0 ;
    unsigned int arg1 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) 
    croak("Usage: dbNet__numInOut_set(self,value);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_dbNet) < 0) {
        croak("Type error in argument 1 of dbNet__numInOut_set. Expected %s", SWIGTYPE_p_dbNet->name);
        XSRETURN(1);
    }
    arg1 = (unsigned int )SvIV(ST(1));
    arg0->_numInOut = arg1;
    XSRETURN(argvi);
}


XS(_wrap_dbNet__numInOut_get) {
    dbNet *arg0 ;
    int argvi = 0;
    unsigned int result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: dbNet__numInOut_get(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_dbNet) < 0) {
        croak("Type error in argument 1 of dbNet__numInOut_get. Expected %s", SWIGTYPE_p_dbNet->name);
        XSRETURN(1);
    }
    result = (unsigned int ) (arg0->_numInOut);
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) result);
    XSRETURN(argvi);
}


XS(_wrap_dbNet__hasLogicalPin_set) {
    dbNet *arg0 ;
    bool arg1 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) 
    croak("Usage: dbNet__hasLogicalPin_set(self,value);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_dbNet) < 0) {
        croak("Type error in argument 1 of dbNet__hasLogicalPin_set. Expected %s", SWIGTYPE_p_dbNet->name);
        XSRETURN(1);
    }
    arg1 = (bool )SvIV(ST(1));
    arg0->_hasLogicalPin = arg1;
    XSRETURN(argvi);
}


XS(_wrap_dbNet__hasLogicalPin_get) {
    dbNet *arg0 ;
    int argvi = 0;
    bool result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: dbNet__hasLogicalPin_get(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_dbNet) < 0) {
        croak("Type error in argument 1 of dbNet__hasLogicalPin_get. Expected %s", SWIGTYPE_p_dbNet->name);
        XSRETURN(1);
    }
    result = (bool ) (arg0->_hasLogicalPin);
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) result);
    XSRETURN(argvi);
}


XS(_wrap_new_dbNet) {
    char *arg0 ;
    unsigned int arg1 ;
    dbNetType *arg2 ;
    ctainerPinsLocal *arg3 ;
    int argvi = 0;
    dbNet *result ;
    dXSARGS;
    
    if ((items < 4) || (items > 4)) 
    croak("Usage: new_dbNet(name,idx,type,pins);");
    if (! SvOK((SV*) ST(0))) {
        arg0 = 0; 
    }
    else {
        arg0 = (char *) SvPV(ST(0),PL_na); 
    }
    arg1 = (unsigned int )SvIV(ST(1));
    if (SWIG_ConvertPtr(ST(2),(void **) &arg2,SWIGTYPE_p_dbNetType) < 0) {
        croak("Type error in argument 3 of new_dbNet. Expected %s", SWIGTYPE_p_dbNetType->name);
        XSRETURN(1);
    }
    if (SWIG_ConvertPtr(ST(3),(void **) &arg3,SWIGTYPE_r_q_const__ctainerPinsLocal) < 0) {
        croak("Type error in argument 4 of new_dbNet. Expected %s", SWIGTYPE_r_q_const__ctainerPinsLocal->name);
        XSRETURN(1);
    }
    result = (dbNet *)new dbNet((char const *)arg0,arg1,*arg2,(ctainerPinsLocal const &)*arg3);
    ST(argvi) = sv_newmortal();
    SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_dbNet);
    XSRETURN(argvi);
}


XS(_wrap_delete_dbNet) {
    dbNet *arg0 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: delete_dbNet(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_dbNet) < 0) {
        croak("Type error in argument 1 of delete_dbNet. Expected %s", SWIGTYPE_p_dbNet->name);
        XSRETURN(1);
    }
    delete arg0;
    XSRETURN(argvi);
}


XS(_wrap_dbNet_getNumCells) {
    dbNet *arg0 ;
    int argvi = 0;
    unsigned int result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: dbNet_getNumCells(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_dbNet) < 0) {
        croak("Type error in argument 1 of dbNet_getNumCells. Expected %s", SWIGTYPE_p_dbNet->name);
        XSRETURN(1);
    }
    result = (unsigned int )arg0->getNumCells();
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) result);
    XSRETURN(argvi);
}


XS(_wrap_dbNet_getNumPins) {
    dbNet *arg0 ;
    int argvi = 0;
    unsigned int result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: dbNet_getNumPins(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_dbNet) < 0) {
        croak("Type error in argument 1 of dbNet_getNumPins. Expected %s", SWIGTYPE_p_dbNet->name);
        XSRETURN(1);
    }
    result = (unsigned int )arg0->getNumPins();
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) result);
    XSRETURN(argvi);
}


XS(_wrap_dbNet_getDegree) {
    dbNet *arg0 ;
    int argvi = 0;
    unsigned int result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: dbNet_getDegree(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_dbNet) < 0) {
        croak("Type error in argument 1 of dbNet_getDegree. Expected %s", SWIGTYPE_p_dbNet->name);
        XSRETURN(1);
    }
    result = (unsigned int )arg0->getDegree();
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) result);
    XSRETURN(argvi);
}


XS(_wrap_dbNet_getIndex) {
    dbNet *arg0 ;
    int argvi = 0;
    unsigned int result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: dbNet_getIndex(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_dbNet) < 0) {
        croak("Type error in argument 1 of dbNet_getIndex. Expected %s", SWIGTYPE_p_dbNet->name);
        XSRETURN(1);
    }
    result = (unsigned int )arg0->getIndex();
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) result);
    XSRETURN(argvi);
}


XS(_wrap_dbNet_getType) {
    dbNet *arg0 ;
    int argvi = 0;
    dbNetType *result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: dbNet_getType(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_dbNet) < 0) {
        croak("Type error in argument 1 of dbNet_getType. Expected %s", SWIGTYPE_p_dbNet->name);
        XSRETURN(1);
    }
    result = new dbNetType (arg0->getType());    ST(argvi) = sv_newmortal();
    SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_dbNetType);
    XSRETURN(argvi);
}


XS(_wrap_dbNet_getName) {
    dbNet *arg0 ;
    int argvi = 0;
    char *result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: dbNet_getName(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_dbNet) < 0) {
        croak("Type error in argument 1 of dbNet_getName. Expected %s", SWIGTYPE_p_dbNet->name);
        XSRETURN(1);
    }
    result = (char *)arg0->getName();
    ST(argvi) = sv_newmortal();
    sv_setpv((SV*)ST(argvi++),(char *) result);
    XSRETURN(argvi);
}


XS(_wrap_dbNet_getNumOut) {
    dbNet *arg0 ;
    int argvi = 0;
    unsigned int result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: dbNet_getNumOut(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_dbNet) < 0) {
        croak("Type error in argument 1 of dbNet_getNumOut. Expected %s", SWIGTYPE_p_dbNet->name);
        XSRETURN(1);
    }
    result = (unsigned int )arg0->getNumOut();
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) result);
    XSRETURN(argvi);
}


XS(_wrap_dbNet_getNumInOut) {
    dbNet *arg0 ;
    int argvi = 0;
    unsigned int result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: dbNet_getNumInOut(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_dbNet) < 0) {
        croak("Type error in argument 1 of dbNet_getNumInOut. Expected %s", SWIGTYPE_p_dbNet->name);
        XSRETURN(1);
    }
    result = (unsigned int )arg0->getNumInOut();
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) result);
    XSRETURN(argvi);
}


XS(_wrap_dbNet_getNumIn) {
    dbNet *arg0 ;
    int argvi = 0;
    unsigned int result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: dbNet_getNumIn(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_dbNet) < 0) {
        croak("Type error in argument 1 of dbNet_getNumIn. Expected %s", SWIGTYPE_p_dbNet->name);
        XSRETURN(1);
    }
    result = (unsigned int )arg0->getNumIn();
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) result);
    XSRETURN(argvi);
}


XS(_wrap_dbNet_hasLogicalPin) {
    dbNet *arg0 ;
    int argvi = 0;
    unsigned int result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: dbNet_hasLogicalPin(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_dbNet) < 0) {
        croak("Type error in argument 1 of dbNet_hasLogicalPin. Expected %s", SWIGTYPE_p_dbNet->name);
        XSRETURN(1);
    }
    result = (unsigned int )arg0->hasLogicalPin();
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) result);
    XSRETURN(argvi);
}


XS(_wrap_dbNet_cellsBegin) {
    dbNet *arg0 ;
    int argvi = 0;
    itCellLocal *result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: dbNet_cellsBegin(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_dbNet) < 0) {
        croak("Type error in argument 1 of dbNet_cellsBegin. Expected %s", SWIGTYPE_p_dbNet->name);
        XSRETURN(1);
    }
    result = new itCellLocal (arg0->cellsBegin());    ST(argvi) = sv_newmortal();
    SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_itCellLocal);
    XSRETURN(argvi);
}


XS(_wrap_dbNet_cellsEnd) {
    dbNet *arg0 ;
    int argvi = 0;
    itCellLocal *result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: dbNet_cellsEnd(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_dbNet) < 0) {
        croak("Type error in argument 1 of dbNet_cellsEnd. Expected %s", SWIGTYPE_p_dbNet->name);
        XSRETURN(1);
    }
    result = new itCellLocal (arg0->cellsEnd());    ST(argvi) = sv_newmortal();
    SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_itCellLocal);
    XSRETURN(argvi);
}


XS(_wrap_dbNet_sourcesBegin) {
    dbNet *arg0 ;
    int argvi = 0;
    itCellLocal *result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: dbNet_sourcesBegin(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_dbNet) < 0) {
        croak("Type error in argument 1 of dbNet_sourcesBegin. Expected %s", SWIGTYPE_p_dbNet->name);
        XSRETURN(1);
    }
    result = new itCellLocal (arg0->sourcesBegin());    ST(argvi) = sv_newmortal();
    SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_itCellLocal);
    XSRETURN(argvi);
}


XS(_wrap_dbNet_sourcesEnd) {
    dbNet *arg0 ;
    int argvi = 0;
    itCellLocal *result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: dbNet_sourcesEnd(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_dbNet) < 0) {
        croak("Type error in argument 1 of dbNet_sourcesEnd. Expected %s", SWIGTYPE_p_dbNet->name);
        XSRETURN(1);
    }
    result = new itCellLocal (arg0->sourcesEnd());    ST(argvi) = sv_newmortal();
    SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_itCellLocal);
    XSRETURN(argvi);
}


XS(_wrap_dbNet_sourceSinksBegin) {
    dbNet *arg0 ;
    int argvi = 0;
    itCellLocal *result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: dbNet_sourceSinksBegin(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_dbNet) < 0) {
        croak("Type error in argument 1 of dbNet_sourceSinksBegin. Expected %s", SWIGTYPE_p_dbNet->name);
        XSRETURN(1);
    }
    result = new itCellLocal (arg0->sourceSinksBegin());    ST(argvi) = sv_newmortal();
    SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_itCellLocal);
    XSRETURN(argvi);
}


XS(_wrap_dbNet_sourceSinksEnd) {
    dbNet *arg0 ;
    int argvi = 0;
    itCellLocal *result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: dbNet_sourceSinksEnd(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_dbNet) < 0) {
        croak("Type error in argument 1 of dbNet_sourceSinksEnd. Expected %s", SWIGTYPE_p_dbNet->name);
        XSRETURN(1);
    }
    result = new itCellLocal (arg0->sourceSinksEnd());    ST(argvi) = sv_newmortal();
    SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_itCellLocal);
    XSRETURN(argvi);
}


XS(_wrap_dbNet_sinksBegin) {
    dbNet *arg0 ;
    int argvi = 0;
    itCellLocal *result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: dbNet_sinksBegin(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_dbNet) < 0) {
        croak("Type error in argument 1 of dbNet_sinksBegin. Expected %s", SWIGTYPE_p_dbNet->name);
        XSRETURN(1);
    }
    result = new itCellLocal (arg0->sinksBegin());    ST(argvi) = sv_newmortal();
    SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_itCellLocal);
    XSRETURN(argvi);
}


XS(_wrap_dbNet_sinksEnd) {
    dbNet *arg0 ;
    int argvi = 0;
    itCellLocal *result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: dbNet_sinksEnd(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_dbNet) < 0) {
        croak("Type error in argument 1 of dbNet_sinksEnd. Expected %s", SWIGTYPE_p_dbNet->name);
        XSRETURN(1);
    }
    result = new itCellLocal (arg0->sinksEnd());    ST(argvi) = sv_newmortal();
    SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_itCellLocal);
    XSRETURN(argvi);
}


XS(_wrap_dbNet_getCellByIdx) {
    dbNet *arg0 ;
    unsigned int arg1 ;
    int argvi = 0;
    dbCell *result ;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) 
    croak("Usage: dbNet_getCellByIdx(self,i);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_dbNet) < 0) {
        croak("Type error in argument 1 of dbNet_getCellByIdx. Expected %s", SWIGTYPE_p_dbNet->name);
        XSRETURN(1);
    }
    arg1 = (unsigned int )SvIV(ST(1));
    dbCell const &_result_ref = arg0->getCellByIdx(arg1);
    result = (dbCell *) &_result_ref;
    ST(argvi) = sv_newmortal();
    SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_dbCell);
    XSRETURN(argvi);
}


XS(_wrap_dbNet_pinsBegin) {
    dbNet *arg0 ;
    int argvi = 0;
    itPinLocal *result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: dbNet_pinsBegin(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_dbNet) < 0) {
        croak("Type error in argument 1 of dbNet_pinsBegin. Expected %s", SWIGTYPE_p_dbNet->name);
        XSRETURN(1);
    }
    result = new itPinLocal (arg0->pinsBegin());    ST(argvi) = sv_newmortal();
    SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_itPinLocal);
    XSRETURN(argvi);
}


XS(_wrap_dbNet_pinsEnd) {
    dbNet *arg0 ;
    int argvi = 0;
    itPinLocal *result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: dbNet_pinsEnd(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_dbNet) < 0) {
        croak("Type error in argument 1 of dbNet_pinsEnd. Expected %s", SWIGTYPE_p_dbNet->name);
        XSRETURN(1);
    }
    result = new itPinLocal (arg0->pinsEnd());    ST(argvi) = sv_newmortal();
    SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_itPinLocal);
    XSRETURN(argvi);
}


XS(_wrap_dbNet_getPinByIdx) {
    dbNet *arg0 ;
    unsigned int arg1 ;
    int argvi = 0;
    dbPin *result ;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) 
    croak("Usage: dbNet_getPinByIdx(self,i);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_dbNet) < 0) {
        croak("Type error in argument 1 of dbNet_getPinByIdx. Expected %s", SWIGTYPE_p_dbNet->name);
        XSRETURN(1);
    }
    arg1 = (unsigned int )SvIV(ST(1));
    dbPin const &_result_ref = arg0->getPinByIdx(arg1);
    result = (dbPin *) &_result_ref;
    ST(argvi) = sv_newmortal();
    SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_dbPin);
    XSRETURN(argvi);
}


XS(_wrap_dbNet_wiringBegin) {
    dbNet *arg0 ;
    int argvi = 0;
    itLayerGeom *result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: dbNet_wiringBegin(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_dbNet) < 0) {
        croak("Type error in argument 1 of dbNet_wiringBegin. Expected %s", SWIGTYPE_p_dbNet->name);
        XSRETURN(1);
    }
    result = new itLayerGeom (arg0->wiringBegin());    ST(argvi) = sv_newmortal();
    SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_itLayerGeom);
    XSRETURN(argvi);
}


XS(_wrap_dbNet_wiringEnd) {
    dbNet *arg0 ;
    int argvi = 0;
    itLayerGeom *result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: dbNet_wiringEnd(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_dbNet) < 0) {
        croak("Type error in argument 1 of dbNet_wiringEnd. Expected %s", SWIGTYPE_p_dbNet->name);
        XSRETURN(1);
    }
    result = new itLayerGeom (arg0->wiringEnd());    ST(argvi) = sv_newmortal();
    SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_itLayerGeom);
    XSRETURN(argvi);
}


XS(_wrap_dbNet_getWiringLayerGeom) {
    dbNet *arg0 ;
    unsigned int arg1 ;
    int argvi = 0;
    dbLayerGeom *result ;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) 
    croak("Usage: dbNet_getWiringLayerGeom(self,i);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_dbNet) < 0) {
        croak("Type error in argument 1 of dbNet_getWiringLayerGeom. Expected %s", SWIGTYPE_p_dbNet->name);
        XSRETURN(1);
    }
    arg1 = (unsigned int )SvIV(ST(1));
    dbLayerGeom const &_result_ref = arg0->getWiringLayerGeom(arg1);
    result = (dbLayerGeom *) &_result_ref;
    ST(argvi) = sv_newmortal();
    SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_dbLayerGeom);
    XSRETURN(argvi);
}


XS(_wrap_dbNet_getNumWiringLayerGeoms) {
    dbNet *arg0 ;
    int argvi = 0;
    unsigned int result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: dbNet_getNumWiringLayerGeoms(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_dbNet) < 0) {
        croak("Type error in argument 1 of dbNet_getNumWiringLayerGeoms. Expected %s", SWIGTYPE_p_dbNet->name);
        XSRETURN(1);
    }
    result = (unsigned int )arg0->getNumWiringLayerGeoms();
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) result);
    XSRETURN(argvi);
}


XS(_wrap_dbNet_loopCellsBegin) {
    dbNet *arg0 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: dbNet_loopCellsBegin(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_dbNet) < 0) {
        croak("Type error in argument 1 of dbNet_loopCellsBegin. Expected %s", SWIGTYPE_p_dbNet->name);
        XSRETURN(1);
    }
    arg0->loopCellsBegin();
    XSRETURN(argvi);
}


XS(_wrap_dbNet_loopCellsEnd) {
    dbNet *arg0 ;
    itCellLocal *arg1 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) 
    croak("Usage: dbNet_loopCellsEnd(self,itr);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_dbNet) < 0) {
        croak("Type error in argument 1 of dbNet_loopCellsEnd. Expected %s", SWIGTYPE_p_dbNet->name);
        XSRETURN(1);
    }
    if (SWIG_ConvertPtr(ST(1),(void **) &arg1,SWIGTYPE_p_itCellLocal) < 0) {
        croak("Type error in argument 2 of dbNet_loopCellsEnd. Expected %s", SWIGTYPE_p_itCellLocal->name);
        XSRETURN(1);
    }
    arg0->loopCellsEnd(*arg1);
    XSRETURN(argvi);
}


XS(_wrap_dbNet_loopPinsBegin) {
    dbNet *arg0 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: dbNet_loopPinsBegin(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_dbNet) < 0) {
        croak("Type error in argument 1 of dbNet_loopPinsBegin. Expected %s", SWIGTYPE_p_dbNet->name);
        XSRETURN(1);
    }
    arg0->loopPinsBegin();
    XSRETURN(argvi);
}


XS(_wrap_dbNet_loopPinsEnd) {
    dbNet *arg0 ;
    itPinLocal *arg1 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) 
    croak("Usage: dbNet_loopPinsEnd(self,itr);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_dbNet) < 0) {
        croak("Type error in argument 1 of dbNet_loopPinsEnd. Expected %s", SWIGTYPE_p_dbNet->name);
        XSRETURN(1);
    }
    if (SWIG_ConvertPtr(ST(1),(void **) &arg1,SWIGTYPE_p_itPinLocal) < 0) {
        croak("Type error in argument 2 of dbNet_loopPinsEnd. Expected %s", SWIGTYPE_p_itPinLocal->name);
        XSRETURN(1);
    }
    arg0->loopPinsEnd(*arg1);
    XSRETURN(argvi);
}


XS(_wrap_dbNet_commonPin) {
    dbNet *arg0 ;
    dbCell *arg1 ;
    int argvi = 0;
    dbPin *result ;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) 
    croak("Usage: dbNet_commonPin(self,cell);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_dbNet) < 0) {
        croak("Type error in argument 1 of dbNet_commonPin. Expected %s", SWIGTYPE_p_dbNet->name);
        XSRETURN(1);
    }
    if (SWIG_ConvertPtr(ST(1),(void **) &arg1,SWIGTYPE_p_dbCell) < 0) {
        croak("Type error in argument 2 of dbNet_commonPin. Expected %s", SWIGTYPE_p_dbCell->name);
        XSRETURN(1);
    }
    result = (dbPin *)arg0->commonPin((dbCell const *)arg1);
    ST(argvi) = sv_newmortal();
    SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_dbPin);
    XSRETURN(argvi);
}


XS(_wrap_dbNet_commonPinIsCellInput) {
    dbNet *arg0 ;
    dbCell *arg1 ;
    int argvi = 0;
    bool result ;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) 
    croak("Usage: dbNet_commonPinIsCellInput(self,cell);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_dbNet) < 0) {
        croak("Type error in argument 1 of dbNet_commonPinIsCellInput. Expected %s", SWIGTYPE_p_dbNet->name);
        XSRETURN(1);
    }
    if (SWIG_ConvertPtr(ST(1),(void **) &arg1,SWIGTYPE_p_dbCell) < 0) {
        croak("Type error in argument 2 of dbNet_commonPinIsCellInput. Expected %s", SWIGTYPE_p_dbCell->name);
        XSRETURN(1);
    }
    result = (bool )arg0->commonPinIsCellInput((dbCell const *)arg1);
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) result);
    XSRETURN(argvi);
}


XS(_wrap_dbNet_commonPinIsCellOutput) {
    dbNet *arg0 ;
    dbCell *arg1 ;
    int argvi = 0;
    bool result ;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) 
    croak("Usage: dbNet_commonPinIsCellOutput(self,cell);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_dbNet) < 0) {
        croak("Type error in argument 1 of dbNet_commonPinIsCellOutput. Expected %s", SWIGTYPE_p_dbNet->name);
        XSRETURN(1);
    }
    if (SWIG_ConvertPtr(ST(1),(void **) &arg1,SWIGTYPE_p_dbCell) < 0) {
        croak("Type error in argument 2 of dbNet_commonPinIsCellOutput. Expected %s", SWIGTYPE_p_dbCell->name);
        XSRETURN(1);
    }
    result = (bool )arg0->commonPinIsCellOutput((dbCell const *)arg1);
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) result);
    XSRETURN(argvi);
}


XS(_wrap_dbNet_getInputCap) {
    dbNet *arg0 ;
    dbCell *arg1 ;
    int argvi = 0;
    double result ;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) 
    croak("Usage: dbNet_getInputCap(self,cell);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_dbNet) < 0) {
        croak("Type error in argument 1 of dbNet_getInputCap. Expected %s", SWIGTYPE_p_dbNet->name);
        XSRETURN(1);
    }
    if (SWIG_ConvertPtr(ST(1),(void **) &arg1,SWIGTYPE_p_dbCell) < 0) {
        croak("Type error in argument 2 of dbNet_getInputCap. Expected %s", SWIGTYPE_p_dbCell->name);
        XSRETURN(1);
    }
    result = (double )arg0->getInputCap((dbCell const *)arg1);
    ST(argvi) = sv_newmortal();
    sv_setnv(ST(argvi++), (double) result);
    XSRETURN(argvi);
}


XS(_wrap_dbNet_getDriverResist) {
    dbNet *arg0 ;
    dbCell *arg1 ;
    int argvi = 0;
    double result ;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) 
    croak("Usage: dbNet_getDriverResist(self,cell);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_dbNet) < 0) {
        croak("Type error in argument 1 of dbNet_getDriverResist. Expected %s", SWIGTYPE_p_dbNet->name);
        XSRETURN(1);
    }
    if (SWIG_ConvertPtr(ST(1),(void **) &arg1,SWIGTYPE_p_dbCell) < 0) {
        croak("Type error in argument 2 of dbNet_getDriverResist. Expected %s", SWIGTYPE_p_dbCell->name);
        XSRETURN(1);
    }
    result = (double )arg0->getDriverResist((dbCell const *)arg1);
    ST(argvi) = sv_newmortal();
    sv_setnv(ST(argvi++), (double) result);
    XSRETURN(argvi);
}


XS(_wrap_dbNet_isSpecial) {
    dbNet *arg0 ;
    int argvi = 0;
    bool result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: dbNet_isSpecial(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_dbNet) < 0) {
        croak("Type error in argument 1 of dbNet_isSpecial. Expected %s", SWIGTYPE_p_dbNet->name);
        XSRETURN(1);
    }
    result = (bool )arg0->isSpecial();
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) result);
    XSRETURN(argvi);
}


XS(_wrap_new_CompareNetsByCellIndex) {
    int argvi = 0;
    CompareNetsByCellIndex *result ;
    dXSARGS;
    
    if ((items < 0) || (items > 0)) 
    croak("Usage: new_CompareNetsByCellIndex();");
    result = (CompareNetsByCellIndex *)new CompareNetsByCellIndex();
    ST(argvi) = sv_newmortal();
    SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_CompareNetsByCellIndex);
    XSRETURN(argvi);
}


XS(_wrap_new_CompareNetsByDegree) {
    int argvi = 0;
    CompareNetsByDegree *result ;
    dXSARGS;
    
    if ((items < 0) || (items > 0)) 
    croak("Usage: new_CompareNetsByDegree();");
    result = (CompareNetsByDegree *)new CompareNetsByDegree();
    ST(argvi) = sv_newmortal();
    SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_CompareNetsByDegree);
    XSRETURN(argvi);
}


XS(_wrap_new_CompareNetsByName) {
    int argvi = 0;
    CompareNetsByName *result ;
    dXSARGS;
    
    if ((items < 0) || (items > 0)) 
    croak("Usage: new_CompareNetsByName();");
    result = (CompareNetsByName *)new CompareNetsByName();
    ST(argvi) = sv_newmortal();
    SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_CompareNetsByName);
    XSRETURN(argvi);
}


XS(_wrap_new_CompareNetsByDirection) {
    dbCell *arg0 ;
    int argvi = 0;
    CompareNetsByDirection *result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: new_CompareNetsByDirection(cell);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_dbCell) < 0) {
        croak("Type error in argument 1 of new_CompareNetsByDirection. Expected %s", SWIGTYPE_p_dbCell->name);
        XSRETURN(1);
    }
    result = (CompareNetsByDirection *)new CompareNetsByDirection((dbCell const &)*arg0);
    ST(argvi) = sv_newmortal();
    SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_CompareNetsByDirection);
    XSRETURN(argvi);
}


XS(_wrap_new_dbNetlist) {
    int argvi = 0;
    dbNetlist *result ;
    dXSARGS;
    
    if ((items < 0) || (items > 0)) 
    croak("Usage: new_dbNetlist();");
    result = (dbNetlist *)new dbNetlist();
    ST(argvi) = sv_newmortal();
    SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_dbNetlist);
    XSRETURN(argvi);
}


XS(_wrap_delete_dbNetlist) {
    dbNetlist *arg0 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: delete_dbNetlist(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_dbNetlist) < 0) {
        croak("Type error in argument 1 of delete_dbNetlist. Expected %s", SWIGTYPE_p_dbNetlist->name);
        XSRETURN(1);
    }
    delete arg0;
    XSRETURN(argvi);
}


XS(_wrap_dbNetlist_getCellLEQClass) {
    dbNetlist *arg0 ;
    dbMasterCell *arg1 ;
    int argvi = 0;
    eqClassMasterCells *result ;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) 
    croak("Usage: dbNetlist_getCellLEQClass(self,dbMasterCell *);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_dbNetlist) < 0) {
        croak("Type error in argument 1 of dbNetlist_getCellLEQClass. Expected %s", SWIGTYPE_p_dbNetlist->name);
        XSRETURN(1);
    }
    if (SWIG_ConvertPtr(ST(1),(void **) &arg1,SWIGTYPE_p_dbMasterCell) < 0) {
        croak("Type error in argument 2 of dbNetlist_getCellLEQClass. Expected %s", SWIGTYPE_p_dbMasterCell->name);
        XSRETURN(1);
    }
    result = new eqClassMasterCells (arg0->getCellLEQClass(arg1));    ST(argvi) = sv_newmortal();
    SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_eqClassMasterCells);
    XSRETURN(argvi);
}


XS(_wrap_dbNetlist_getCellEEQClass) {
    dbNetlist *arg0 ;
    dbMasterCell *arg1 ;
    int argvi = 0;
    eqClassMasterCells *result ;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) 
    croak("Usage: dbNetlist_getCellEEQClass(self,dbMasterCell *);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_dbNetlist) < 0) {
        croak("Type error in argument 1 of dbNetlist_getCellEEQClass. Expected %s", SWIGTYPE_p_dbNetlist->name);
        XSRETURN(1);
    }
    if (SWIG_ConvertPtr(ST(1),(void **) &arg1,SWIGTYPE_p_dbMasterCell) < 0) {
        croak("Type error in argument 2 of dbNetlist_getCellEEQClass. Expected %s", SWIGTYPE_p_dbMasterCell->name);
        XSRETURN(1);
    }
    result = new eqClassMasterCells (arg0->getCellEEQClass(arg1));    ST(argvi) = sv_newmortal();
    SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_eqClassMasterCells);
    XSRETURN(argvi);
}


XS(_wrap_dbNetlist_getPinLEQClass) {
    dbNetlist *arg0 ;
    dbMasterPin *arg1 ;
    int argvi = 0;
    eqClassMasterPins *result ;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) 
    croak("Usage: dbNetlist_getPinLEQClass(self,dbMasterPin *);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_dbNetlist) < 0) {
        croak("Type error in argument 1 of dbNetlist_getPinLEQClass. Expected %s", SWIGTYPE_p_dbNetlist->name);
        XSRETURN(1);
    }
    if (SWIG_ConvertPtr(ST(1),(void **) &arg1,SWIGTYPE_p_dbMasterPin) < 0) {
        croak("Type error in argument 2 of dbNetlist_getPinLEQClass. Expected %s", SWIGTYPE_p_dbMasterPin->name);
        XSRETURN(1);
    }
    result = new eqClassMasterPins (arg0->getPinLEQClass(arg1));    ST(argvi) = sv_newmortal();
    SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_eqClassMasterPins);
    XSRETURN(argvi);
}


XS(_wrap_dbNetlist_isConsistent) {
    dbNetlist *arg0 ;
    int argvi = 0;
    bool result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: dbNetlist_isConsistent(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_dbNetlist) < 0) {
        croak("Type error in argument 1 of dbNetlist_isConsistent. Expected %s", SWIGTYPE_p_dbNetlist->name);
        XSRETURN(1);
    }
    result = (bool )arg0->isConsistent();
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) result);
    XSRETURN(argvi);
}


XS(_wrap_dbNetlist_getNumCells) {
    dbNetlist *arg0 ;
    int argvi = 0;
    unsigned int result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: dbNetlist_getNumCells(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_dbNetlist) < 0) {
        croak("Type error in argument 1 of dbNetlist_getNumCells. Expected %s", SWIGTYPE_p_dbNetlist->name);
        XSRETURN(1);
    }
    result = (unsigned int )arg0->getNumCells();
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) result);
    XSRETURN(argvi);
}


XS(_wrap_dbNetlist_getNumPins) {
    dbNetlist *arg0 ;
    int argvi = 0;
    unsigned int result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: dbNetlist_getNumPins(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_dbNetlist) < 0) {
        croak("Type error in argument 1 of dbNetlist_getNumPins. Expected %s", SWIGTYPE_p_dbNetlist->name);
        XSRETURN(1);
    }
    result = (unsigned int )arg0->getNumPins();
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) result);
    XSRETURN(argvi);
}


XS(_wrap_dbNetlist_getNumNets) {
    dbNetlist *arg0 ;
    int argvi = 0;
    unsigned int result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: dbNetlist_getNumNets(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_dbNetlist) < 0) {
        croak("Type error in argument 1 of dbNetlist_getNumNets. Expected %s", SWIGTYPE_p_dbNetlist->name);
        XSRETURN(1);
    }
    result = (unsigned int )arg0->getNumNets();
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) result);
    XSRETURN(argvi);
}


XS(_wrap_dbNetlist_getNumSNets) {
    dbNetlist *arg0 ;
    int argvi = 0;
    unsigned int result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: dbNetlist_getNumSNets(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_dbNetlist) < 0) {
        croak("Type error in argument 1 of dbNetlist_getNumSNets. Expected %s", SWIGTYPE_p_dbNetlist->name);
        XSRETURN(1);
    }
    result = (unsigned int )arg0->getNumSNets();
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) result);
    XSRETURN(argvi);
}


XS(_wrap_dbNetlist_getNumMasterCells) {
    dbNetlist *arg0 ;
    int argvi = 0;
    unsigned int result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: dbNetlist_getNumMasterCells(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_dbNetlist) < 0) {
        croak("Type error in argument 1 of dbNetlist_getNumMasterCells. Expected %s", SWIGTYPE_p_dbNetlist->name);
        XSRETURN(1);
    }
    result = (unsigned int )arg0->getNumMasterCells();
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) result);
    XSRETURN(argvi);
}


XS(_wrap_dbNetlist_getNumMasterPins) {
    dbNetlist *arg0 ;
    int argvi = 0;
    unsigned int result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: dbNetlist_getNumMasterPins(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_dbNetlist) < 0) {
        croak("Type error in argument 1 of dbNetlist_getNumMasterPins. Expected %s", SWIGTYPE_p_dbNetlist->name);
        XSRETURN(1);
    }
    result = (unsigned int )arg0->getNumMasterPins();
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) result);
    XSRETURN(argvi);
}


XS(_wrap_dbNetlist_getNumCCs) {
    dbNetlist *arg0 ;
    int argvi = 0;
    unsigned int result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: dbNetlist_getNumCCs(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_dbNetlist) < 0) {
        croak("Type error in argument 1 of dbNetlist_getNumCCs. Expected %s", SWIGTYPE_p_dbNetlist->name);
        XSRETURN(1);
    }
    result = (unsigned int )arg0->getNumCCs();
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) result);
    XSRETURN(argvi);
}


XS(_wrap_dbNetlist_getNumSCs) {
    dbNetlist *arg0 ;
    int argvi = 0;
    unsigned int result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: dbNetlist_getNumSCs(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_dbNetlist) < 0) {
        croak("Type error in argument 1 of dbNetlist_getNumSCs. Expected %s", SWIGTYPE_p_dbNetlist->name);
        XSRETURN(1);
    }
    result = (unsigned int )arg0->getNumSCs();
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) result);
    XSRETURN(argvi);
}


XS(_wrap_dbNetlist_getNumIOPads) {
    dbNetlist *arg0 ;
    int argvi = 0;
    unsigned int result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: dbNetlist_getNumIOPads(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_dbNetlist) < 0) {
        croak("Type error in argument 1 of dbNetlist_getNumIOPads. Expected %s", SWIGTYPE_p_dbNetlist->name);
        XSRETURN(1);
    }
    result = (unsigned int )arg0->getNumIOPads();
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) result);
    XSRETURN(argvi);
}


XS(_wrap_dbNetlist_getNumAllPads) {
    dbNetlist *arg0 ;
    int argvi = 0;
    unsigned int result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: dbNetlist_getNumAllPads(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_dbNetlist) < 0) {
        croak("Type error in argument 1 of dbNetlist_getNumAllPads. Expected %s", SWIGTYPE_p_dbNetlist->name);
        XSRETURN(1);
    }
    result = (unsigned int )arg0->getNumAllPads();
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) result);
    XSRETURN(argvi);
}


XS(_wrap_dbNetlist_getNumIOPins) {
    dbNetlist *arg0 ;
    int argvi = 0;
    unsigned int result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: dbNetlist_getNumIOPins(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_dbNetlist) < 0) {
        croak("Type error in argument 1 of dbNetlist_getNumIOPins. Expected %s", SWIGTYPE_p_dbNetlist->name);
        XSRETURN(1);
    }
    result = (unsigned int )arg0->getNumIOPins();
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) result);
    XSRETURN(argvi);
}


XS(_wrap_dbNetlist_getNumCoreCells) {
    dbNetlist *arg0 ;
    int argvi = 0;
    unsigned int result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: dbNetlist_getNumCoreCells(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_dbNetlist) < 0) {
        croak("Type error in argument 1 of dbNetlist_getNumCoreCells. Expected %s", SWIGTYPE_p_dbNetlist->name);
        XSRETURN(1);
    }
    result = (unsigned int )arg0->getNumCoreCells();
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) result);
    XSRETURN(argvi);
}


XS(_wrap_dbNetlist_cellsBegin) {
    dbNetlist *arg0 ;
    int argvi = 0;
    itCellGlobal *result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: dbNetlist_cellsBegin(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_dbNetlist) < 0) {
        croak("Type error in argument 1 of dbNetlist_cellsBegin. Expected %s", SWIGTYPE_p_dbNetlist->name);
        XSRETURN(1);
    }
    result = new itCellGlobal (arg0->cellsBegin());    ST(argvi) = sv_newmortal();
    SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_itCellGlobal);
    XSRETURN(argvi);
}


XS(_wrap_dbNetlist_cellsEnd) {
    dbNetlist *arg0 ;
    int argvi = 0;
    itCellGlobal *result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: dbNetlist_cellsEnd(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_dbNetlist) < 0) {
        croak("Type error in argument 1 of dbNetlist_cellsEnd. Expected %s", SWIGTYPE_p_dbNetlist->name);
        XSRETURN(1);
    }
    result = new itCellGlobal (arg0->cellsEnd());    ST(argvi) = sv_newmortal();
    SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_itCellGlobal);
    XSRETURN(argvi);
}


XS(_wrap_dbNetlist_netsBegin) {
    dbNetlist *arg0 ;
    int argvi = 0;
    itNetGlobal *result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: dbNetlist_netsBegin(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_dbNetlist) < 0) {
        croak("Type error in argument 1 of dbNetlist_netsBegin. Expected %s", SWIGTYPE_p_dbNetlist->name);
        XSRETURN(1);
    }
    result = new itNetGlobal (arg0->netsBegin());    ST(argvi) = sv_newmortal();
    SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_itNetGlobal);
    XSRETURN(argvi);
}


XS(_wrap_dbNetlist_netsEnd) {
    dbNetlist *arg0 ;
    int argvi = 0;
    itNetGlobal *result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: dbNetlist_netsEnd(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_dbNetlist) < 0) {
        croak("Type error in argument 1 of dbNetlist_netsEnd. Expected %s", SWIGTYPE_p_dbNetlist->name);
        XSRETURN(1);
    }
    result = new itNetGlobal (arg0->netsEnd());    ST(argvi) = sv_newmortal();
    SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_itNetGlobal);
    XSRETURN(argvi);
}


XS(_wrap_dbNetlist_sNetsBegin) {
    dbNetlist *arg0 ;
    int argvi = 0;
    itNetGlobal *result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: dbNetlist_sNetsBegin(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_dbNetlist) < 0) {
        croak("Type error in argument 1 of dbNetlist_sNetsBegin. Expected %s", SWIGTYPE_p_dbNetlist->name);
        XSRETURN(1);
    }
    result = new itNetGlobal (arg0->sNetsBegin());    ST(argvi) = sv_newmortal();
    SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_itNetGlobal);
    XSRETURN(argvi);
}


XS(_wrap_dbNetlist_sNetsEnd) {
    dbNetlist *arg0 ;
    int argvi = 0;
    itNetGlobal *result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: dbNetlist_sNetsEnd(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_dbNetlist) < 0) {
        croak("Type error in argument 1 of dbNetlist_sNetsEnd. Expected %s", SWIGTYPE_p_dbNetlist->name);
        XSRETURN(1);
    }
    result = new itNetGlobal (arg0->sNetsEnd());    ST(argvi) = sv_newmortal();
    SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_itNetGlobal);
    XSRETURN(argvi);
}


XS(_wrap_dbNetlist_pinsBegin) {
    dbNetlist *arg0 ;
    int argvi = 0;
    itPinGlobal *result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: dbNetlist_pinsBegin(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_dbNetlist) < 0) {
        croak("Type error in argument 1 of dbNetlist_pinsBegin. Expected %s", SWIGTYPE_p_dbNetlist->name);
        XSRETURN(1);
    }
    result = new itPinGlobal (arg0->pinsBegin());    ST(argvi) = sv_newmortal();
    SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_itPinGlobal);
    XSRETURN(argvi);
}


XS(_wrap_dbNetlist_pinsEnd) {
    dbNetlist *arg0 ;
    int argvi = 0;
    itPinGlobal *result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: dbNetlist_pinsEnd(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_dbNetlist) < 0) {
        croak("Type error in argument 1 of dbNetlist_pinsEnd. Expected %s", SWIGTYPE_p_dbNetlist->name);
        XSRETURN(1);
    }
    result = new itPinGlobal (arg0->pinsEnd());    ST(argvi) = sv_newmortal();
    SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_itPinGlobal);
    XSRETURN(argvi);
}


XS(_wrap_dbNetlist_pinLibBegin) {
    dbNetlist *arg0 ;
    int argvi = 0;
    itMasterPinGlobal *result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: dbNetlist_pinLibBegin(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_dbNetlist) < 0) {
        croak("Type error in argument 1 of dbNetlist_pinLibBegin. Expected %s", SWIGTYPE_p_dbNetlist->name);
        XSRETURN(1);
    }
    result = new itMasterPinGlobal (arg0->pinLibBegin());    ST(argvi) = sv_newmortal();
    SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_itMasterPinGlobal);
    XSRETURN(argvi);
}


XS(_wrap_dbNetlist_pinLibEnd) {
    dbNetlist *arg0 ;
    int argvi = 0;
    itMasterPinGlobal *result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: dbNetlist_pinLibEnd(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_dbNetlist) < 0) {
        croak("Type error in argument 1 of dbNetlist_pinLibEnd. Expected %s", SWIGTYPE_p_dbNetlist->name);
        XSRETURN(1);
    }
    result = new itMasterPinGlobal (arg0->pinLibEnd());    ST(argvi) = sv_newmortal();
    SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_itMasterPinGlobal);
    XSRETURN(argvi);
}


XS(_wrap_dbNetlist_cellLibBegin) {
    dbNetlist *arg0 ;
    int argvi = 0;
    itMasterCell *result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: dbNetlist_cellLibBegin(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_dbNetlist) < 0) {
        croak("Type error in argument 1 of dbNetlist_cellLibBegin. Expected %s", SWIGTYPE_p_dbNetlist->name);
        XSRETURN(1);
    }
    result = new itMasterCell (arg0->cellLibBegin());    ST(argvi) = sv_newmortal();
    SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_itMasterCell);
    XSRETURN(argvi);
}


XS(_wrap_dbNetlist_cellLibEnd) {
    dbNetlist *arg0 ;
    int argvi = 0;
    itMasterCell *result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: dbNetlist_cellLibEnd(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_dbNetlist) < 0) {
        croak("Type error in argument 1 of dbNetlist_cellLibEnd. Expected %s", SWIGTYPE_p_dbNetlist->name);
        XSRETURN(1);
    }
    result = new itMasterCell (arg0->cellLibEnd());    ST(argvi) = sv_newmortal();
    SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_itMasterCell);
    XSRETURN(argvi);
}


XS(_wrap_dbNetlist_getCellByIdx) {
    dbNetlist *arg0 ;
    unsigned int arg1 ;
    int argvi = 0;
    dbCell *result ;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) 
    croak("Usage: dbNetlist_getCellByIdx(self,i);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_dbNetlist) < 0) {
        croak("Type error in argument 1 of dbNetlist_getCellByIdx. Expected %s", SWIGTYPE_p_dbNetlist->name);
        XSRETURN(1);
    }
    arg1 = (unsigned int )SvIV(ST(1));
    dbCell const &_result_ref = arg0->getCellByIdx(arg1);
    result = (dbCell *) &_result_ref;
    ST(argvi) = sv_newmortal();
    SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_dbCell);
    XSRETURN(argvi);
}


XS(_wrap_dbNetlist_getNetByIdx) {
    dbNetlist *arg0 ;
    unsigned int arg1 ;
    int argvi = 0;
    dbNet *result ;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) 
    croak("Usage: dbNetlist_getNetByIdx(self,i);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_dbNetlist) < 0) {
        croak("Type error in argument 1 of dbNetlist_getNetByIdx. Expected %s", SWIGTYPE_p_dbNetlist->name);
        XSRETURN(1);
    }
    arg1 = (unsigned int )SvIV(ST(1));
    dbNet const &_result_ref = arg0->getNetByIdx(arg1);
    result = (dbNet *) &_result_ref;
    ST(argvi) = sv_newmortal();
    SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_dbNet);
    XSRETURN(argvi);
}


XS(_wrap_dbNetlist_getSNetByIdx) {
    dbNetlist *arg0 ;
    unsigned int arg1 ;
    int argvi = 0;
    dbNet *result ;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) 
    croak("Usage: dbNetlist_getSNetByIdx(self,i);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_dbNetlist) < 0) {
        croak("Type error in argument 1 of dbNetlist_getSNetByIdx. Expected %s", SWIGTYPE_p_dbNetlist->name);
        XSRETURN(1);
    }
    arg1 = (unsigned int )SvIV(ST(1));
    dbNet const &_result_ref = arg0->getSNetByIdx(arg1);
    result = (dbNet *) &_result_ref;
    ST(argvi) = sv_newmortal();
    SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_dbNet);
    XSRETURN(argvi);
}


XS(_wrap_dbNetlist_getPinByIdx) {
    dbNetlist *arg0 ;
    unsigned int arg1 ;
    int argvi = 0;
    dbPin *result ;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) 
    croak("Usage: dbNetlist_getPinByIdx(self,i);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_dbNetlist) < 0) {
        croak("Type error in argument 1 of dbNetlist_getPinByIdx. Expected %s", SWIGTYPE_p_dbNetlist->name);
        XSRETURN(1);
    }
    arg1 = (unsigned int )SvIV(ST(1));
    dbPin const &_result_ref = arg0->getPinByIdx(arg1);
    result = (dbPin *) &_result_ref;
    ST(argvi) = sv_newmortal();
    SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_dbPin);
    XSRETURN(argvi);
}


XS(_wrap_dbNetlist_loopCellsBegin) {
    dbNetlist *arg0 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: dbNetlist_loopCellsBegin(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_dbNetlist) < 0) {
        croak("Type error in argument 1 of dbNetlist_loopCellsBegin. Expected %s", SWIGTYPE_p_dbNetlist->name);
        XSRETURN(1);
    }
    arg0->loopCellsBegin();
    XSRETURN(argvi);
}


XS(_wrap_dbNetlist_loopCellsEnd) {
    dbNetlist *arg0 ;
    itCellGlobal *arg1 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) 
    croak("Usage: dbNetlist_loopCellsEnd(self,itr);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_dbNetlist) < 0) {
        croak("Type error in argument 1 of dbNetlist_loopCellsEnd. Expected %s", SWIGTYPE_p_dbNetlist->name);
        XSRETURN(1);
    }
    if (SWIG_ConvertPtr(ST(1),(void **) &arg1,SWIGTYPE_p_itCellGlobal) < 0) {
        croak("Type error in argument 2 of dbNetlist_loopCellsEnd. Expected %s", SWIGTYPE_p_itCellGlobal->name);
        XSRETURN(1);
    }
    arg0->loopCellsEnd(*arg1);
    XSRETURN(argvi);
}


XS(_wrap_dbNetlist_loopNetsBegin) {
    dbNetlist *arg0 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: dbNetlist_loopNetsBegin(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_dbNetlist) < 0) {
        croak("Type error in argument 1 of dbNetlist_loopNetsBegin. Expected %s", SWIGTYPE_p_dbNetlist->name);
        XSRETURN(1);
    }
    arg0->loopNetsBegin();
    XSRETURN(argvi);
}


XS(_wrap_dbNetlist_loopNetsEnd) {
    dbNetlist *arg0 ;
    itNetGlobal *arg1 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) 
    croak("Usage: dbNetlist_loopNetsEnd(self,itr);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_dbNetlist) < 0) {
        croak("Type error in argument 1 of dbNetlist_loopNetsEnd. Expected %s", SWIGTYPE_p_dbNetlist->name);
        XSRETURN(1);
    }
    if (SWIG_ConvertPtr(ST(1),(void **) &arg1,SWIGTYPE_p_itNetGlobal) < 0) {
        croak("Type error in argument 2 of dbNetlist_loopNetsEnd. Expected %s", SWIGTYPE_p_itNetGlobal->name);
        XSRETURN(1);
    }
    arg0->loopNetsEnd(*arg1);
    XSRETURN(argvi);
}


XS(_wrap_dbNetlist_loopSNetsBegin) {
    dbNetlist *arg0 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: dbNetlist_loopSNetsBegin(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_dbNetlist) < 0) {
        croak("Type error in argument 1 of dbNetlist_loopSNetsBegin. Expected %s", SWIGTYPE_p_dbNetlist->name);
        XSRETURN(1);
    }
    arg0->loopSNetsBegin();
    XSRETURN(argvi);
}


XS(_wrap_dbNetlist_loopSNetsEnd) {
    dbNetlist *arg0 ;
    itNetGlobal *arg1 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) 
    croak("Usage: dbNetlist_loopSNetsEnd(self,itr);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_dbNetlist) < 0) {
        croak("Type error in argument 1 of dbNetlist_loopSNetsEnd. Expected %s", SWIGTYPE_p_dbNetlist->name);
        XSRETURN(1);
    }
    if (SWIG_ConvertPtr(ST(1),(void **) &arg1,SWIGTYPE_p_itNetGlobal) < 0) {
        croak("Type error in argument 2 of dbNetlist_loopSNetsEnd. Expected %s", SWIGTYPE_p_itNetGlobal->name);
        XSRETURN(1);
    }
    arg0->loopSNetsEnd(*arg1);
    XSRETURN(argvi);
}


XS(_wrap_dbNetlist_postProcess) {
    dbNetlist *arg0 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: dbNetlist_postProcess(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_dbNetlist) < 0) {
        croak("Type error in argument 1 of dbNetlist_postProcess. Expected %s", SWIGTYPE_p_dbNetlist->name);
        XSRETURN(1);
    }
    arg0->postProcess();
    XSRETURN(argvi);
}


XS(_wrap_dbNetlist_processLGC) {
    dbNetlist *arg0 ;
    ifstream *arg1 ;
    Verbosity *arg2 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 3) || (items > 3)) 
    croak("Usage: dbNetlist_processLGC(self,lgcf,verbose);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_dbNetlist) < 0) {
        croak("Type error in argument 1 of dbNetlist_processLGC. Expected %s", SWIGTYPE_p_dbNetlist->name);
        XSRETURN(1);
    }
    if (SWIG_ConvertPtr(ST(1),(void **) &arg1,SWIGTYPE_p_ifstream) < 0) {
        croak("Type error in argument 2 of dbNetlist_processLGC. Expected %s", SWIGTYPE_p_ifstream->name);
        XSRETURN(1);
    }
    if (SWIG_ConvertPtr(ST(2),(void **) &arg2,SWIGTYPE_p_Verbosity) < 0) {
        croak("Type error in argument 3 of dbNetlist_processLGC. Expected %s", SWIGTYPE_p_Verbosity->name);
        XSRETURN(1);
    }
    arg0->processLGC(*arg1,(Verbosity const &)*arg2);
    XSRETURN(argvi);
}


XS(_wrap_dbNetlist_evalHalfPerimCost) {
    dbNetlist *arg0 ;
    Placement *arg1 ;
    unsigned int arg2 = 0 ;
    bool arg3 = false ;
    int argvi = 0;
    double result ;
    dXSARGS;
    
    if ((items < 2) || (items > 4)) 
    croak("Usage: dbNetlist_evalHalfPerimCost(self,pl,threshold,IONetsOnly);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_dbNetlist) < 0) {
        croak("Type error in argument 1 of dbNetlist_evalHalfPerimCost. Expected %s", SWIGTYPE_p_dbNetlist->name);
        XSRETURN(1);
    }
    if (SWIG_ConvertPtr(ST(1),(void **) &arg1,SWIGTYPE_p_Placement) < 0) {
        croak("Type error in argument 2 of dbNetlist_evalHalfPerimCost. Expected %s", SWIGTYPE_p_Placement->name);
        XSRETURN(1);
    }
    if (items > 2) {
        arg2 = (unsigned int )SvIV(ST(2));
    }
    if (items > 3) {
        arg3 = (bool )SvIV(ST(3));
    }
    result = (double )arg0->evalHalfPerimCost((Placement const &)*arg1,arg2,arg3);
    ST(argvi) = sv_newmortal();
    sv_setnv(ST(argvi++), (double) result);
    XSRETURN(argvi);
}


XS(_wrap_dbNetlist_evalWHalfPerimCost) {
    dbNetlist *arg0 ;
    Placement *arg1 ;
    unsigned int arg2 = 0 ;
    bool arg3 = false ;
    int argvi = 0;
    double result ;
    dXSARGS;
    
    if ((items < 2) || (items > 4)) 
    croak("Usage: dbNetlist_evalWHalfPerimCost(self,pl,threshold,IONetsOnly);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_dbNetlist) < 0) {
        croak("Type error in argument 1 of dbNetlist_evalWHalfPerimCost. Expected %s", SWIGTYPE_p_dbNetlist->name);
        XSRETURN(1);
    }
    if (SWIG_ConvertPtr(ST(1),(void **) &arg1,SWIGTYPE_p_Placement) < 0) {
        croak("Type error in argument 2 of dbNetlist_evalWHalfPerimCost. Expected %s", SWIGTYPE_p_Placement->name);
        XSRETURN(1);
    }
    if (items > 2) {
        arg2 = (unsigned int )SvIV(ST(2));
    }
    if (items > 3) {
        arg3 = (bool )SvIV(ST(3));
    }
    result = (double )arg0->evalWHalfPerimCost((Placement const &)*arg1,arg2,arg3);
    ST(argvi) = sv_newmortal();
    sv_setnv(ST(argvi++), (double) result);
    XSRETURN(argvi);
}


XS(_wrap_dbNetlist_evalMSTCost) {
    dbNetlist *arg0 ;
    Placement *arg1 ;
    int argvi = 0;
    double result ;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) 
    croak("Usage: dbNetlist_evalMSTCost(self,pl);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_dbNetlist) < 0) {
        croak("Type error in argument 1 of dbNetlist_evalMSTCost. Expected %s", SWIGTYPE_p_dbNetlist->name);
        XSRETURN(1);
    }
    if (SWIG_ConvertPtr(ST(1),(void **) &arg1,SWIGTYPE_p_Placement) < 0) {
        croak("Type error in argument 2 of dbNetlist_evalMSTCost. Expected %s", SWIGTYPE_p_Placement->name);
        XSRETURN(1);
    }
    result = (double )arg0->evalMSTCost((Placement const &)*arg1);
    ST(argvi) = sv_newmortal();
    sv_setnv(ST(argvi++), (double) result);
    XSRETURN(argvi);
}


XS(_wrap_dbNetlist_evalHalfPerimCostNoPins) {
    dbNetlist *arg0 ;
    dbNet *arg1 ;
    Placement *arg2 ;
    bool arg3 = false ;
    int argvi = 0;
    double result ;
    dXSARGS;
    
    if ((items < 3) || (items > 4)) 
    croak("Usage: dbNetlist_evalHalfPerimCostNoPins(self,net,pl,IONetsOnly);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_dbNetlist) < 0) {
        croak("Type error in argument 1 of dbNetlist_evalHalfPerimCostNoPins. Expected %s", SWIGTYPE_p_dbNetlist->name);
        XSRETURN(1);
    }
    if (SWIG_ConvertPtr(ST(1),(void **) &arg1,SWIGTYPE_p_dbNet) < 0) {
        croak("Type error in argument 2 of dbNetlist_evalHalfPerimCostNoPins. Expected %s", SWIGTYPE_p_dbNet->name);
        XSRETURN(1);
    }
    if (SWIG_ConvertPtr(ST(2),(void **) &arg2,SWIGTYPE_p_Placement) < 0) {
        croak("Type error in argument 3 of dbNetlist_evalHalfPerimCostNoPins. Expected %s", SWIGTYPE_p_Placement->name);
        XSRETURN(1);
    }
    if (items > 3) {
        arg3 = (bool )SvIV(ST(3));
    }
    result = (double )arg0->evalHalfPerimCostNoPins(arg1,(Placement const &)*arg2,arg3);
    ST(argvi) = sv_newmortal();
    sv_setnv(ST(argvi++), (double) result);
    XSRETURN(argvi);
}


XS(_wrap_dbNetlist_printNetStats) {
    dbNetlist *arg0 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: dbNetlist_printNetStats(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_dbNetlist) < 0) {
        croak("Type error in argument 1 of dbNetlist_printNetStats. Expected %s", SWIGTYPE_p_dbNetlist->name);
        XSRETURN(1);
    }
    arg0->printNetStats();
    XSRETURN(argvi);
}


XS(_wrap_dbEasyAccess_populate) {
    dbEasyAccess *arg0 ;
    dbContext *arg1 ;
    dbNetlist *arg2 ;
    dbSpatial *arg3 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 4) || (items > 4)) 
    croak("Usage: dbEasyAccess_populate(self,dbContext const &,dbNetlist const &,dbSpatial const &);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_dbEasyAccess) < 0) {
        croak("Type error in argument 1 of dbEasyAccess_populate. Expected %s", SWIGTYPE_p_dbEasyAccess->name);
        XSRETURN(1);
    }
    if (SWIG_ConvertPtr(ST(1),(void **) &arg1,SWIGTYPE_p_dbContext) < 0) {
        croak("Type error in argument 2 of dbEasyAccess_populate. Expected %s", SWIGTYPE_p_dbContext->name);
        XSRETURN(1);
    }
    if (SWIG_ConvertPtr(ST(2),(void **) &arg2,SWIGTYPE_p_dbNetlist) < 0) {
        croak("Type error in argument 3 of dbEasyAccess_populate. Expected %s", SWIGTYPE_p_dbNetlist->name);
        XSRETURN(1);
    }
    if (SWIG_ConvertPtr(ST(3),(void **) &arg3,SWIGTYPE_p_dbSpatial) < 0) {
        croak("Type error in argument 4 of dbEasyAccess_populate. Expected %s", SWIGTYPE_p_dbSpatial->name);
        XSRETURN(1);
    }
    arg0->populate((dbContext const &)*arg1,(dbNetlist const &)*arg2,(dbSpatial const &)*arg3);
    XSRETURN(argvi);
}


XS(_wrap_dbEasyAccess_isConsistent) {
    dbEasyAccess *arg0 ;
    dbContext *arg1 ;
    dbNetlist *arg2 ;
    int argvi = 0;
    bool result ;
    dXSARGS;
    
    if ((items < 3) || (items > 3)) 
    croak("Usage: dbEasyAccess_isConsistent(self,dbContext const &,dbNetlist const &);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_dbEasyAccess) < 0) {
        croak("Type error in argument 1 of dbEasyAccess_isConsistent. Expected %s", SWIGTYPE_p_dbEasyAccess->name);
        XSRETURN(1);
    }
    if (SWIG_ConvertPtr(ST(1),(void **) &arg1,SWIGTYPE_p_dbContext) < 0) {
        croak("Type error in argument 2 of dbEasyAccess_isConsistent. Expected %s", SWIGTYPE_p_dbContext->name);
        XSRETURN(1);
    }
    if (SWIG_ConvertPtr(ST(2),(void **) &arg2,SWIGTYPE_p_dbNetlist) < 0) {
        croak("Type error in argument 3 of dbEasyAccess_isConsistent. Expected %s", SWIGTYPE_p_dbNetlist->name);
        XSRETURN(1);
    }
    result = (bool )arg0->isConsistent((dbContext const &)*arg1,(dbNetlist const &)*arg2);
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) result);
    XSRETURN(argvi);
}


XS(_wrap_dbEasyAccess_getCellWidths) {
    dbEasyAccess *arg0 ;
    int argvi = 0;
    vector<double> *result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: dbEasyAccess_getCellWidths(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_dbEasyAccess) < 0) {
        croak("Type error in argument 1 of dbEasyAccess_getCellWidths. Expected %s", SWIGTYPE_p_dbEasyAccess->name);
        XSRETURN(1);
    }
    vector<double> const &_result_ref = arg0->getCellWidths();
    result = (vector<double> *) &_result_ref;
    ST(argvi) = sv_newmortal();
    SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_vector_double_);
    XSRETURN(argvi);
}


XS(_wrap_dbEasyAccess_getCellAreas) {
    dbEasyAccess *arg0 ;
    int argvi = 0;
    vector<double> *result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: dbEasyAccess_getCellAreas(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_dbEasyAccess) < 0) {
        croak("Type error in argument 1 of dbEasyAccess_getCellAreas. Expected %s", SWIGTYPE_p_dbEasyAccess->name);
        XSRETURN(1);
    }
    vector<double> const &_result_ref = arg0->getCellAreas();
    result = (vector<double> *) &_result_ref;
    ST(argvi) = sv_newmortal();
    SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_vector_double_);
    XSRETURN(argvi);
}


XS(_wrap_dbEasyAccess_getWhitespace) {
    dbEasyAccess *arg0 ;
    int argvi = 0;
    vector<IntervalSeqLayer> *result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: dbEasyAccess_getWhitespace(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_dbEasyAccess) < 0) {
        croak("Type error in argument 1 of dbEasyAccess_getWhitespace. Expected %s", SWIGTYPE_p_dbEasyAccess->name);
        XSRETURN(1);
    }
    vector<IntervalSeqLayer> const &_result_ref = arg0->getWhitespace();
    result = (vector<IntervalSeqLayer> *) &_result_ref;
    ST(argvi) = sv_newmortal();
    SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_vector_IntervalSeqLayer_);
    XSRETURN(argvi);
}


XS(_wrap_dbEasyAccess_getNumPortLocations) {
    dbEasyAccess *arg0 ;
    int argvi = 0;
    unsigned int result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: dbEasyAccess_getNumPortLocations(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_dbEasyAccess) < 0) {
        croak("Type error in argument 1 of dbEasyAccess_getNumPortLocations. Expected %s", SWIGTYPE_p_dbEasyAccess->name);
        XSRETURN(1);
    }
    result = (unsigned int )arg0->getNumPortLocations();
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) result);
    XSRETURN(argvi);
}


XS(_wrap_dbEasyAccess_getPortLocationByIdx) {
    dbEasyAccess *arg0 ;
    unsigned int arg1 ;
    int argvi = 0;
    ISPairLayer *result ;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) 
    croak("Usage: dbEasyAccess_getPortLocationByIdx(self,idx);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_dbEasyAccess) < 0) {
        croak("Type error in argument 1 of dbEasyAccess_getPortLocationByIdx. Expected %s", SWIGTYPE_p_dbEasyAccess->name);
        XSRETURN(1);
    }
    arg1 = (unsigned int )SvIV(ST(1));
    ISPairLayer const &_result_ref = arg0->getPortLocationByIdx(arg1);
    result = (ISPairLayer *) &_result_ref;
    ST(argvi) = sv_newmortal();
    SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_ISPairLayer);
    XSRETURN(argvi);
}


XS(_wrap_dbEasyAccess_getNetIds) {
    dbEasyAccess *arg0 ;
    int argvi = 0;
    vector<unsigned> *result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: dbEasyAccess_getNetIds(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_dbEasyAccess) < 0) {
        croak("Type error in argument 1 of dbEasyAccess_getNetIds. Expected %s", SWIGTYPE_p_dbEasyAccess->name);
        XSRETURN(1);
    }
    vector<unsigned> const &_result_ref = arg0->getNetIds();
    result = (vector<unsigned> *) &_result_ref;
    ST(argvi) = sv_newmortal();
    SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_vector_unsigned_);
    XSRETURN(argvi);
}


XS(_wrap_dbEasyAccess_getCoreCells) {
    dbEasyAccess *arg0 ;
    int argvi = 0;
    Subset *result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: dbEasyAccess_getCoreCells(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_dbEasyAccess) < 0) {
        croak("Type error in argument 1 of dbEasyAccess_getCoreCells. Expected %s", SWIGTYPE_p_dbEasyAccess->name);
        XSRETURN(1);
    }
    Subset const &_result_ref = arg0->getCoreCells();
    result = (Subset *) &_result_ref;
    ST(argvi) = sv_newmortal();
    SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_Subset);
    XSRETURN(argvi);
}


XS(_wrap_dbEasyAccess_getCoreBBox) {
    dbEasyAccess *arg0 ;
    int argvi = 0;
    BBox *result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: dbEasyAccess_getCoreBBox(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_dbEasyAccess) < 0) {
        croak("Type error in argument 1 of dbEasyAccess_getCoreBBox. Expected %s", SWIGTYPE_p_dbEasyAccess->name);
        XSRETURN(1);
    }
    BBox const &_result_ref = arg0->getCoreBBox();
    result = (BBox *) &_result_ref;
    ST(argvi) = sv_newmortal();
    SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_BBox);
    XSRETURN(argvi);
}


XS(_wrap_dbEasyAccess_getPin2CellIdx) {
    dbEasyAccess *arg0 ;
    int argvi = 0;
    vector<unsigned> *result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: dbEasyAccess_getPin2CellIdx(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_dbEasyAccess) < 0) {
        croak("Type error in argument 1 of dbEasyAccess_getPin2CellIdx. Expected %s", SWIGTYPE_p_dbEasyAccess->name);
        XSRETURN(1);
    }
    vector<unsigned> const &_result_ref = arg0->getPin2CellIdx();
    result = (vector<unsigned> *) &_result_ref;
    ST(argvi) = sv_newmortal();
    SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_vector_unsigned_);
    XSRETURN(argvi);
}


XS(_wrap_dbEasyAccess_getCellIdxByPinIdx) {
    dbEasyAccess *arg0 ;
    unsigned int arg1 ;
    int argvi = 0;
    unsigned int result ;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) 
    croak("Usage: dbEasyAccess_getCellIdxByPinIdx(self,k);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_dbEasyAccess) < 0) {
        croak("Type error in argument 1 of dbEasyAccess_getCellIdxByPinIdx. Expected %s", SWIGTYPE_p_dbEasyAccess->name);
        XSRETURN(1);
    }
    arg1 = (unsigned int )SvIV(ST(1));
    result = (unsigned int )arg0->getCellIdxByPinIdx(arg1);
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) result);
    XSRETURN(argvi);
}


XS(_wrap_dbEasyAccess_getCoreCellArea) {
    dbEasyAccess *arg0 ;
    int argvi = 0;
    double result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: dbEasyAccess_getCoreCellArea(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_dbEasyAccess) < 0) {
        croak("Type error in argument 1 of dbEasyAccess_getCoreCellArea. Expected %s", SWIGTYPE_p_dbEasyAccess->name);
        XSRETURN(1);
    }
    result = (double )arg0->getCoreCellArea();
    ST(argvi) = sv_newmortal();
    sv_setnv(ST(argvi++), (double) result);
    XSRETURN(argvi);
}


XS(_wrap_dbEasyAccess_getTotalCellWidth) {
    dbEasyAccess *arg0 ;
    int argvi = 0;
    double result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: dbEasyAccess_getTotalCellWidth(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_dbEasyAccess) < 0) {
        croak("Type error in argument 1 of dbEasyAccess_getTotalCellWidth. Expected %s", SWIGTYPE_p_dbEasyAccess->name);
        XSRETURN(1);
    }
    result = (double )arg0->getTotalCellWidth();
    ST(argvi) = sv_newmortal();
    sv_setnv(ST(argvi++), (double) result);
    XSRETURN(argvi);
}


XS(_wrap_dbEasyAccess_getCellByName) {
    dbEasyAccess *arg0 ;
    char *arg1 ;
    int argvi = 0;
    dbCell *result ;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) 
    croak("Usage: dbEasyAccess_getCellByName(self,name);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_dbEasyAccess) < 0) {
        croak("Type error in argument 1 of dbEasyAccess_getCellByName. Expected %s", SWIGTYPE_p_dbEasyAccess->name);
        XSRETURN(1);
    }
    if (! SvOK((SV*) ST(1))) {
        arg1 = 0; 
    }
    else {
        arg1 = (char *) SvPV(ST(1),PL_na); 
    }
    dbCell const &_result_ref = arg0->getCellByName((char const *)arg1);
    result = (dbCell *) &_result_ref;
    ST(argvi) = sv_newmortal();
    SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_dbCell);
    XSRETURN(argvi);
}


XS(_wrap_dbEasyAccess_getNetByName) {
    dbEasyAccess *arg0 ;
    char *arg1 ;
    int argvi = 0;
    dbNet *result ;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) 
    croak("Usage: dbEasyAccess_getNetByName(self,name);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_dbEasyAccess) < 0) {
        croak("Type error in argument 1 of dbEasyAccess_getNetByName. Expected %s", SWIGTYPE_p_dbEasyAccess->name);
        XSRETURN(1);
    }
    if (! SvOK((SV*) ST(1))) {
        arg1 = 0; 
    }
    else {
        arg1 = (char *) SvPV(ST(1),PL_na); 
    }
    dbNet const &_result_ref = arg0->getNetByName((char const *)arg1);
    result = (dbNet *) &_result_ref;
    ST(argvi) = sv_newmortal();
    SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_dbNet);
    XSRETURN(argvi);
}


XS(_wrap_new_dbSpatial) {
    int argvi = 0;
    dbSpatial *result ;
    dXSARGS;
    
    if ((items < 0) || (items > 0)) 
    croak("Usage: new_dbSpatial();");
    result = (dbSpatial *)new dbSpatial();
    ST(argvi) = sv_newmortal();
    SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_dbSpatial);
    XSRETURN(argvi);
}


XS(_wrap_dbSpatial_locations_set) {
    dbSpatial *arg0 ;
    Placement *arg1 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) 
    croak("Usage: dbSpatial_locations_set(self,value);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_dbSpatial) < 0) {
        croak("Type error in argument 1 of dbSpatial_locations_set. Expected %s", SWIGTYPE_p_dbSpatial->name);
        XSRETURN(1);
    }
    if (SWIG_ConvertPtr(ST(1),(void **) &arg1,SWIGTYPE_p_Placement) < 0) {
        croak("Type error in argument 2 of dbSpatial_locations_set. Expected %s", SWIGTYPE_p_Placement->name);
        XSRETURN(1);
    }
    arg0->locations = *arg1;
    XSRETURN(argvi);
}


XS(_wrap_dbSpatial_locations_get) {
    dbSpatial *arg0 ;
    int argvi = 0;
    Placement *result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: dbSpatial_locations_get(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_dbSpatial) < 0) {
        croak("Type error in argument 1 of dbSpatial_locations_get. Expected %s", SWIGTYPE_p_dbSpatial->name);
        XSRETURN(1);
    }
    result = (Placement *)& (arg0->locations);
    ST(argvi) = sv_newmortal();
    SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_Placement);
    XSRETURN(argvi);
}


XS(_wrap_dbSpatial_locationValid_set) {
    dbSpatial *arg0 ;
    bit_vector *arg1 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) 
    croak("Usage: dbSpatial_locationValid_set(self,value);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_dbSpatial) < 0) {
        croak("Type error in argument 1 of dbSpatial_locationValid_set. Expected %s", SWIGTYPE_p_dbSpatial->name);
        XSRETURN(1);
    }
    if (SWIG_ConvertPtr(ST(1),(void **) &arg1,SWIGTYPE_p_bit_vector) < 0) {
        croak("Type error in argument 2 of dbSpatial_locationValid_set. Expected %s", SWIGTYPE_p_bit_vector->name);
        XSRETURN(1);
    }
    arg0->locationValid = *arg1;
    XSRETURN(argvi);
}


XS(_wrap_dbSpatial_locationValid_get) {
    dbSpatial *arg0 ;
    int argvi = 0;
    bit_vector *result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: dbSpatial_locationValid_get(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_dbSpatial) < 0) {
        croak("Type error in argument 1 of dbSpatial_locationValid_get. Expected %s", SWIGTYPE_p_dbSpatial->name);
        XSRETURN(1);
    }
    result = (bit_vector *)& (arg0->locationValid);
    ST(argvi) = sv_newmortal();
    SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_bit_vector);
    XSRETURN(argvi);
}


XS(_wrap_dbSpatial_orientations_set) {
    dbSpatial *arg0 ;
    vector<Orientation> *arg1 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) 
    croak("Usage: dbSpatial_orientations_set(self,value);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_dbSpatial) < 0) {
        croak("Type error in argument 1 of dbSpatial_orientations_set. Expected %s", SWIGTYPE_p_dbSpatial->name);
        XSRETURN(1);
    }
    if (SWIG_ConvertPtr(ST(1),(void **) &arg1,SWIGTYPE_p_vector_Orientation_) < 0) {
        croak("Type error in argument 2 of dbSpatial_orientations_set. Expected %s", SWIGTYPE_p_vector_Orientation_->name);
        XSRETURN(1);
    }
    arg0->orientations = *arg1;
    XSRETURN(argvi);
}


XS(_wrap_dbSpatial_orientations_get) {
    dbSpatial *arg0 ;
    int argvi = 0;
    vector<Orientation> *result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: dbSpatial_orientations_get(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_dbSpatial) < 0) {
        croak("Type error in argument 1 of dbSpatial_orientations_get. Expected %s", SWIGTYPE_p_dbSpatial->name);
        XSRETURN(1);
    }
    result = (vector<Orientation> *)& (arg0->orientations);
    ST(argvi) = sv_newmortal();
    SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_vector_Orientation_);
    XSRETURN(argvi);
}


XS(_wrap_dbSpatial_constraints_set) {
    dbSpatial *arg0 ;
    Constraints *arg1 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) 
    croak("Usage: dbSpatial_constraints_set(self,value);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_dbSpatial) < 0) {
        croak("Type error in argument 1 of dbSpatial_constraints_set. Expected %s", SWIGTYPE_p_dbSpatial->name);
        XSRETURN(1);
    }
    if (SWIG_ConvertPtr(ST(1),(void **) &arg1,SWIGTYPE_p_Constraints) < 0) {
        croak("Type error in argument 2 of dbSpatial_constraints_set. Expected %s", SWIGTYPE_p_Constraints->name);
        XSRETURN(1);
    }
    arg0->constraints = *arg1;
    XSRETURN(argvi);
}


XS(_wrap_dbSpatial_constraints_get) {
    dbSpatial *arg0 ;
    int argvi = 0;
    Constraints *result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: dbSpatial_constraints_get(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_dbSpatial) < 0) {
        croak("Type error in argument 1 of dbSpatial_constraints_get. Expected %s", SWIGTYPE_p_dbSpatial->name);
        XSRETURN(1);
    }
    result = (Constraints *)& (arg0->constraints);
    ST(argvi) = sv_newmortal();
    SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_Constraints);
    XSRETURN(argvi);
}


XS(_wrap_dbSpatial_getSize) {
    dbSpatial *arg0 ;
    int argvi = 0;
    unsigned int result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: dbSpatial_getSize(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_dbSpatial) < 0) {
        croak("Type error in argument 1 of dbSpatial_getSize. Expected %s", SWIGTYPE_p_dbSpatial->name);
        XSRETURN(1);
    }
    result = (unsigned int )arg0->getSize();
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) result);
    XSRETURN(argvi);
}


XS(_wrap_dbSpatial_isConsistent) {
    dbSpatial *arg0 ;
    int argvi = 0;
    bool result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: dbSpatial_isConsistent(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_dbSpatial) < 0) {
        croak("Type error in argument 1 of dbSpatial_isConsistent. Expected %s", SWIGTYPE_p_dbSpatial->name);
        XSRETURN(1);
    }
    result = (bool )arg0->isConsistent();
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) result);
    XSRETURN(argvi);
}


XS(_wrap_dbSpatial_reorderCells) {
    dbSpatial *arg0 ;
    Permutation *arg1 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) 
    croak("Usage: dbSpatial_reorderCells(self,Permutation const &);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_dbSpatial) < 0) {
        croak("Type error in argument 1 of dbSpatial_reorderCells. Expected %s", SWIGTYPE_p_dbSpatial->name);
        XSRETURN(1);
    }
    if (SWIG_ConvertPtr(ST(1),(void **) &arg1,SWIGTYPE_p_Permutation) < 0) {
        croak("Type error in argument 2 of dbSpatial_reorderCells. Expected %s", SWIGTYPE_p_Permutation->name);
        XSRETURN(1);
    }
    arg0->reorderCells((Permutation const &)*arg1);
    XSRETURN(argvi);
}


XS(_wrap_dbSpatial_allCellsPlaced) {
    dbSpatial *arg0 ;
    int argvi = 0;
    bool result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: dbSpatial_allCellsPlaced(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_dbSpatial) < 0) {
        croak("Type error in argument 1 of dbSpatial_allCellsPlaced. Expected %s", SWIGTYPE_p_dbSpatial->name);
        XSRETURN(1);
    }
    result = (bool )arg0->allCellsPlaced();
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) result);
    XSRETURN(argvi);
}


XS(_wrap_DB_spatial_set) {
    DB *arg0 ;
    dbSpatial *arg1 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) 
    croak("Usage: DB_spatial_set(self,value);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_DB) < 0) {
        croak("Type error in argument 1 of DB_spatial_set. Expected %s", SWIGTYPE_p_DB->name);
        XSRETURN(1);
    }
    if (SWIG_ConvertPtr(ST(1),(void **) &arg1,SWIGTYPE_p_dbSpatial) < 0) {
        croak("Type error in argument 2 of DB_spatial_set. Expected %s", SWIGTYPE_p_dbSpatial->name);
        XSRETURN(1);
    }
    arg0->spatial = *arg1;
    XSRETURN(argvi);
}


XS(_wrap_DB_spatial_get) {
    DB *arg0 ;
    int argvi = 0;
    dbSpatial *result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: DB_spatial_get(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_DB) < 0) {
        croak("Type error in argument 1 of DB_spatial_get. Expected %s", SWIGTYPE_p_DB->name);
        XSRETURN(1);
    }
    result = (dbSpatial *)& (arg0->spatial);
    ST(argvi) = sv_newmortal();
    SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_dbSpatial);
    XSRETURN(argvi);
}


XS(_wrap_DB_easyAccess_set) {
    DB *arg0 ;
    dbEasyAccess *arg1 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) 
    croak("Usage: DB_easyAccess_set(self,value);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_DB) < 0) {
        croak("Type error in argument 1 of DB_easyAccess_set. Expected %s", SWIGTYPE_p_DB->name);
        XSRETURN(1);
    }
    if (SWIG_ConvertPtr(ST(1),(void **) &arg1,SWIGTYPE_p_dbEasyAccess) < 0) {
        croak("Type error in argument 2 of DB_easyAccess_set. Expected %s", SWIGTYPE_p_dbEasyAccess->name);
        XSRETURN(1);
    }
    arg0->easyAccess = *arg1;
    XSRETURN(argvi);
}


XS(_wrap_DB_easyAccess_get) {
    DB *arg0 ;
    int argvi = 0;
    dbEasyAccess *result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: DB_easyAccess_get(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_DB) < 0) {
        croak("Type error in argument 1 of DB_easyAccess_get. Expected %s", SWIGTYPE_p_DB->name);
        XSRETURN(1);
    }
    result = (dbEasyAccess *)& (arg0->easyAccess);
    ST(argvi) = sv_newmortal();
    SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_dbEasyAccess);
    XSRETURN(argvi);
}


XS(_wrap_DB_routedNets_set) {
    DB *arg0 ;
    dbRoutingInfo *arg1 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) 
    croak("Usage: DB_routedNets_set(self,value);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_DB) < 0) {
        croak("Type error in argument 1 of DB_routedNets_set. Expected %s", SWIGTYPE_p_DB->name);
        XSRETURN(1);
    }
    if (SWIG_ConvertPtr(ST(1),(void **) &arg1,SWIGTYPE_p_dbRoutingInfo) < 0) {
        croak("Type error in argument 2 of DB_routedNets_set. Expected %s", SWIGTYPE_p_dbRoutingInfo->name);
        XSRETURN(1);
    }
    arg0->routedNets = *arg1;
    XSRETURN(argvi);
}


XS(_wrap_DB_routedNets_get) {
    DB *arg0 ;
    int argvi = 0;
    dbRoutingInfo *result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: DB_routedNets_get(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_DB) < 0) {
        croak("Type error in argument 1 of DB_routedNets_get. Expected %s", SWIGTYPE_p_DB->name);
        XSRETURN(1);
    }
    result = (dbRoutingInfo *)& (arg0->routedNets);
    ST(argvi) = sv_newmortal();
    SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_dbRoutingInfo);
    XSRETURN(argvi);
}


XS(_wrap_DB_timing_set) {
    DB *arg0 ;
    dbTemporal *arg1 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) 
    croak("Usage: DB_timing_set(self,value);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_DB) < 0) {
        croak("Type error in argument 1 of DB_timing_set. Expected %s", SWIGTYPE_p_DB->name);
        XSRETURN(1);
    }
    if (SWIG_ConvertPtr(ST(1),(void **) &arg1,SWIGTYPE_p_dbTemporal) < 0) {
        croak("Type error in argument 2 of DB_timing_set. Expected %s", SWIGTYPE_p_dbTemporal->name);
        XSRETURN(1);
    }
    arg0->timing = arg1;
    XSRETURN(argvi);
}


XS(_wrap_DB_timing_get) {
    DB *arg0 ;
    int argvi = 0;
    dbTemporal *result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: DB_timing_get(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_DB) < 0) {
        croak("Type error in argument 1 of DB_timing_get. Expected %s", SWIGTYPE_p_DB->name);
        XSRETURN(1);
    }
    result = (dbTemporal *) (arg0->timing);
    ST(argvi) = sv_newmortal();
    SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_dbTemporal);
    XSRETURN(argvi);
}


XS(_wrap_new_DB) {
    char *arg0 ;
    DB_Parameters *arg1 ;
    int argvi = 0;
    DB *result ;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) 
    croak("Usage: new_DB(auxFileName,params);");
    if (! SvOK((SV*) ST(0))) {
        arg0 = 0; 
    }
    else {
        arg0 = (char *) SvPV(ST(0),PL_na); 
    }
    if (SWIG_ConvertPtr(ST(1),(void **) &arg1,SWIGTYPE_p_DB_Parameters) < 0) {
        croak("Type error in argument 2 of new_DB. Expected %s", SWIGTYPE_p_DB_Parameters->name);
        XSRETURN(1);
    }
    result = (DB *)new DB((char const *)arg0,*arg1);
    ST(argvi) = sv_newmortal();
    SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_DB);
    XSRETURN(argvi);
}


XS(_wrap_delete_DB) {
    DB *arg0 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: delete_DB(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_DB) < 0) {
        croak("Type error in argument 1 of delete_DB. Expected %s", SWIGTYPE_p_DB->name);
        XSRETURN(1);
    }
    delete arg0;
    XSRETURN(argvi);
}


XS(_wrap_DB_isConsistent) {
    DB *arg0 ;
    int argvi = 0;
    bool result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: DB_isConsistent(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_DB) < 0) {
        croak("Type error in argument 1 of DB_isConsistent. Expected %s", SWIGTYPE_p_DB->name);
        XSRETURN(1);
    }
    result = (bool )arg0->isConsistent();
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) result);
    XSRETURN(argvi);
}


XS(_wrap_DB_getOrigFileName) {
    DB *arg0 ;
    int argvi = 0;
    char *result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: DB_getOrigFileName(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_DB) < 0) {
        croak("Type error in argument 1 of DB_getOrigFileName. Expected %s", SWIGTYPE_p_DB->name);
        XSRETURN(1);
    }
    result = (char *)arg0->getOrigFileName();
    ST(argvi) = sv_newmortal();
    sv_setpv((SV*)ST(argvi++),(char *) result);
    XSRETURN(argvi);
}


XS(_wrap_DB_getAuxName) {
    DB *arg0 ;
    int argvi = 0;
    char *result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: DB_getAuxName(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_DB) < 0) {
        croak("Type error in argument 1 of DB_getAuxName. Expected %s", SWIGTYPE_p_DB->name);
        XSRETURN(1);
    }
    result = (char *)arg0->getAuxName();
    ST(argvi) = sv_newmortal();
    sv_setpv((SV*)ST(argvi++),(char *) result);
    XSRETURN(argvi);
}


XS(_wrap_DB_getDirName) {
    DB *arg0 ;
    int argvi = 0;
    char *result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: DB_getDirName(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_DB) < 0) {
        croak("Type error in argument 1 of DB_getDirName. Expected %s", SWIGTYPE_p_DB->name);
        XSRETURN(1);
    }
    result = (char *)arg0->getDirName();
    ST(argvi) = sv_newmortal();
    sv_setpv((SV*)ST(argvi++),(char *) result);
    XSRETURN(argvi);
}


XS(_wrap_DB_getFileNames) {
    DB *arg0 ;
    int argvi = 0;
    vector<char*> *result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: DB_getFileNames(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_DB) < 0) {
        croak("Type error in argument 1 of DB_getFileNames. Expected %s", SWIGTYPE_p_DB->name);
        XSRETURN(1);
    }
    vector<char*> const &_result_ref = arg0->getFileNames();
    result = (vector<char*> *) &_result_ref;
    ST(argvi) = sv_newmortal();
    SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_vector_char__);
    XSRETURN(argvi);
}


XS(_wrap_DB_getOrigFileFormat) {
    DB *arg0 ;
    int argvi = 0;
    char *result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: DB_getOrigFileFormat(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_DB) < 0) {
        croak("Type error in argument 1 of DB_getOrigFileFormat. Expected %s", SWIGTYPE_p_DB->name);
        XSRETURN(1);
    }
    result = (char *)arg0->getOrigFileFormat();
    ST(argvi) = sv_newmortal();
    sv_setpv((SV*)ST(argvi++),(char *) result);
    XSRETURN(argvi);
}


XS(_wrap_DB_getDelimiter) {
    DB *arg0 ;
    int argvi = 0;
    char result ;
    char ctemp[2];
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: DB_getDelimiter(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_DB) < 0) {
        croak("Type error in argument 1 of DB_getDelimiter. Expected %s", SWIGTYPE_p_DB->name);
        XSRETURN(1);
    }
    result = (char )arg0->getDelimiter();
    ST(argvi) = sv_newmortal();
    ctemp[0] = result;
    ctemp[1] = 0;
    sv_setpv((SV*)ST(argvi++),ctemp);
    XSRETURN(argvi);
}


XS(_wrap_DB_getLayout) {
    DB *arg0 ;
    int argvi = 0;
    dbLayout *result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: DB_getLayout(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_DB) < 0) {
        croak("Type error in argument 1 of DB_getLayout. Expected %s", SWIGTYPE_p_DB->name);
        XSRETURN(1);
    }
    dbLayout const &_result_ref = arg0->getLayout();
    result = (dbLayout *) &_result_ref;
    ST(argvi) = sv_newmortal();
    SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_r_q_const__dbLayout);
    XSRETURN(argvi);
}


XS(_wrap_DB_getNetlist) {
    DB *arg0 ;
    int argvi = 0;
    dbNetlist *result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: DB_getNetlist(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_DB) < 0) {
        croak("Type error in argument 1 of DB_getNetlist. Expected %s", SWIGTYPE_p_DB->name);
        XSRETURN(1);
    }
    dbNetlist const &_result_ref = arg0->getNetlist();
    result = (dbNetlist *) &_result_ref;
    ST(argvi) = sv_newmortal();
    SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_dbNetlist);
    XSRETURN(argvi);
}


XS(_wrap_DB_getNetlistForSurgery) {
    DB *arg0 ;
    int argvi = 0;
    dbNetlist *result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: DB_getNetlistForSurgery(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_DB) < 0) {
        croak("Type error in argument 1 of DB_getNetlistForSurgery. Expected %s", SWIGTYPE_p_DB->name);
        XSRETURN(1);
    }
    dbNetlist &_result_ref = arg0->getNetlistForSurgery();
    result = (dbNetlist *) &_result_ref;
    ST(argvi) = sv_newmortal();
    SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_dbNetlist);
    XSRETURN(argvi);
}


XS(_wrap_DB_getTiming) {
    DB *arg0 ;
    int argvi = 0;
    dbTemporal *result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: DB_getTiming(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_DB) < 0) {
        croak("Type error in argument 1 of DB_getTiming. Expected %s", SWIGTYPE_p_DB->name);
        XSRETURN(1);
    }
    dbTemporal const &_result_ref = arg0->getTiming();
    result = (dbTemporal *) &_result_ref;
    ST(argvi) = sv_newmortal();
    SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_dbTemporal);
    XSRETURN(argvi);
}


XS(_wrap_DB_saveDEF) {
    DB *arg0 ;
    char *arg1 ;
    bool arg2 = false ;
    bool arg3 = true ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 4)) 
    croak("Usage: DB_saveDEF(self,defFileName,bSaveUnPlacedLocs,bSaveRoutingInfo);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_DB) < 0) {
        croak("Type error in argument 1 of DB_saveDEF. Expected %s", SWIGTYPE_p_DB->name);
        XSRETURN(1);
    }
    if (! SvOK((SV*) ST(1))) {
        arg1 = 0; 
    }
    else {
        arg1 = (char *) SvPV(ST(1),PL_na); 
    }
    if (items > 2) {
        arg2 = (bool )SvIV(ST(2));
    }
    if (items > 3) {
        arg3 = (bool )SvIV(ST(3));
    }
    arg0->saveDEF((char const *)arg1,arg2,arg3);
    XSRETURN(argvi);
}


XS(_wrap_DB_saveXYLineDrawing) {
    DB *arg0 ;
    char *arg1 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) 
    croak("Usage: DB_saveXYLineDrawing(self,xyFileName);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_DB) < 0) {
        croak("Type error in argument 1 of DB_saveXYLineDrawing. Expected %s", SWIGTYPE_p_DB->name);
        XSRETURN(1);
    }
    if (! SvOK((SV*) ST(1))) {
        arg1 = 0; 
    }
    else {
        arg1 = (char *) SvPV(ST(1),PL_na); 
    }
    arg0->saveXYLineDrawing((char const *)arg1);
    XSRETURN(argvi);
}


XS(_wrap_DB_hasDesignName) {
    DB *arg0 ;
    int argvi = 0;
    bool result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: DB_hasDesignName(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_DB) < 0) {
        croak("Type error in argument 1 of DB_hasDesignName. Expected %s", SWIGTYPE_p_DB->name);
        XSRETURN(1);
    }
    result = (bool )arg0->hasDesignName();
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) result);
    XSRETURN(argvi);
}


XS(_wrap_DB_hasTechnoName) {
    DB *arg0 ;
    int argvi = 0;
    bool result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: DB_hasTechnoName(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_DB) < 0) {
        croak("Type error in argument 1 of DB_hasTechnoName. Expected %s", SWIGTYPE_p_DB->name);
        XSRETURN(1);
    }
    result = (bool )arg0->hasTechnoName();
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) result);
    XSRETURN(argvi);
}


XS(_wrap_DB_getDesignName) {
    DB *arg0 ;
    int argvi = 0;
    char *result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: DB_getDesignName(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_DB) < 0) {
        croak("Type error in argument 1 of DB_getDesignName. Expected %s", SWIGTYPE_p_DB->name);
        XSRETURN(1);
    }
    result = (char *)arg0->getDesignName();
    ST(argvi) = sv_newmortal();
    sv_setpv((SV*)ST(argvi++),(char *) result);
    XSRETURN(argvi);
}


XS(_wrap_DB_getTechnoName) {
    DB *arg0 ;
    int argvi = 0;
    char *result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: DB_getTechnoName(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_DB) < 0) {
        croak("Type error in argument 1 of DB_getTechnoName. Expected %s", SWIGTYPE_p_DB->name);
        XSRETURN(1);
    }
    result = (char *)arg0->getTechnoName();
    ST(argvi) = sv_newmortal();
    sv_setpv((SV*)ST(argvi++),(char *) result);
    XSRETURN(argvi);
}


XS(_wrap_DB_evalHPWLcost) {
    DB *arg0 ;
    unsigned int arg1 = 0 ;
    bool arg2 = false ;
    int argvi = 0;
    double result ;
    dXSARGS;
    
    if ((items < 1) || (items > 3)) 
    croak("Usage: DB_evalHPWLcost(self,threshold,IONetsOnly);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_DB) < 0) {
        croak("Type error in argument 1 of DB_evalHPWLcost. Expected %s", SWIGTYPE_p_DB->name);
        XSRETURN(1);
    }
    if (items > 1) {
        arg1 = (unsigned int )SvIV(ST(1));
    }
    if (items > 2) {
        arg2 = (bool )SvIV(ST(2));
    }
    result = (double )arg0->evalHPWLcost(arg1,arg2);
    ST(argvi) = sv_newmortal();
    sv_setnv(ST(argvi++), (double) result);
    XSRETURN(argvi);
}


XS(_wrap_DB_evalWHPWLcost) {
    DB *arg0 ;
    unsigned int arg1 = 0 ;
    bool arg2 = false ;
    int argvi = 0;
    double result ;
    dXSARGS;
    
    if ((items < 1) || (items > 3)) 
    croak("Usage: DB_evalWHPWLcost(self,threshold,IONetsOnly);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_DB) < 0) {
        croak("Type error in argument 1 of DB_evalWHPWLcost. Expected %s", SWIGTYPE_p_DB->name);
        XSRETURN(1);
    }
    if (items > 1) {
        arg1 = (unsigned int )SvIV(ST(1));
    }
    if (items > 2) {
        arg2 = (bool )SvIV(ST(2));
    }
    result = (double )arg0->evalWHPWLcost(arg1,arg2);
    ST(argvi) = sv_newmortal();
    sv_setnv(ST(argvi++), (double) result);
    XSRETURN(argvi);
}


XS(_wrap_DB_printNetStats) {
    DB *arg0 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: DB_printNetStats(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_DB) < 0) {
        croak("Type error in argument 1 of DB_printNetStats. Expected %s", SWIGTYPE_p_DB->name);
        XSRETURN(1);
    }
    arg0->printNetStats();
    XSRETURN(argvi);
}


XS(_wrap_DB_locatePin) {
    DB *arg0 ;
    dbPin *arg1 ;
    Placement *arg2 ;
    vector<Orient> *arg3 ;
    int argvi = 0;
    Point *result ;
    dXSARGS;
    
    if ((items < 4) || (items > 4)) 
    croak("Usage: DB_locatePin(self,pin,placement,orientations);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_DB) < 0) {
        croak("Type error in argument 1 of DB_locatePin. Expected %s", SWIGTYPE_p_DB->name);
        XSRETURN(1);
    }
    if (SWIG_ConvertPtr(ST(1),(void **) &arg1,SWIGTYPE_p_dbPin) < 0) {
        croak("Type error in argument 2 of DB_locatePin. Expected %s", SWIGTYPE_p_dbPin->name);
        XSRETURN(1);
    }
    if (SWIG_ConvertPtr(ST(2),(void **) &arg2,SWIGTYPE_p_Placement) < 0) {
        croak("Type error in argument 3 of DB_locatePin. Expected %s", SWIGTYPE_p_Placement->name);
        XSRETURN(1);
    }
    if (SWIG_ConvertPtr(ST(3),(void **) &arg3,SWIGTYPE_p_vector_Orient_) < 0) {
        croak("Type error in argument 4 of DB_locatePin. Expected %s", SWIGTYPE_p_vector_Orient_->name);
        XSRETURN(1);
    }
    result = new Point (arg0->locatePin((dbPin const &)*arg1,(Placement const &)*arg2,(vector<Orient> const &)*arg3));    ST(argvi) = sv_newmortal();
    SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_Point);
    XSRETURN(argvi);
}


XS(_wrap_DB_setPlaceAndOrient) {
    DB *arg0 ;
    PlacementWOrient *arg1 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) 
    croak("Usage: DB_setPlaceAndOrient(self,plWOri);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_DB) < 0) {
        croak("Type error in argument 1 of DB_setPlaceAndOrient. Expected %s", SWIGTYPE_p_DB->name);
        XSRETURN(1);
    }
    if (SWIG_ConvertPtr(ST(1),(void **) &arg1,SWIGTYPE_p_PlacementWOrient) < 0) {
        croak("Type error in argument 2 of DB_setPlaceAndOrient. Expected %s", SWIGTYPE_p_PlacementWOrient->name);
        XSRETURN(1);
    }
    arg0->setPlaceAndOrient((PlacementWOrient const &)*arg1);
    XSRETURN(argvi);
}


XS(_wrap_DB_Parameters_ignoreLogicalPins_set) {
    DB_Parameters *arg0 ;
    bool arg1 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) 
    croak("Usage: DB_Parameters_ignoreLogicalPins_set(self,value);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_DB_Parameters) < 0) {
        croak("Type error in argument 1 of DB_Parameters_ignoreLogicalPins_set. Expected %s", SWIGTYPE_p_DB_Parameters->name);
        XSRETURN(1);
    }
    arg1 = (bool )SvIV(ST(1));
    arg0->ignoreLogicalPins = arg1;
    XSRETURN(argvi);
}


XS(_wrap_DB_Parameters_ignoreLogicalPins_get) {
    DB_Parameters *arg0 ;
    int argvi = 0;
    bool result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: DB_Parameters_ignoreLogicalPins_get(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_DB_Parameters) < 0) {
        croak("Type error in argument 1 of DB_Parameters_ignoreLogicalPins_get. Expected %s", SWIGTYPE_p_DB_Parameters->name);
        XSRETURN(1);
    }
    result = (bool ) (arg0->ignoreLogicalPins);
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) result);
    XSRETURN(argvi);
}


XS(_wrap_DB_Parameters_ignoreGlobalRoutingInfo_set) {
    DB_Parameters *arg0 ;
    bool arg1 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) 
    croak("Usage: DB_Parameters_ignoreGlobalRoutingInfo_set(self,value);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_DB_Parameters) < 0) {
        croak("Type error in argument 1 of DB_Parameters_ignoreGlobalRoutingInfo_set. Expected %s", SWIGTYPE_p_DB_Parameters->name);
        XSRETURN(1);
    }
    arg1 = (bool )SvIV(ST(1));
    arg0->ignoreGlobalRoutingInfo = arg1;
    XSRETURN(argvi);
}


XS(_wrap_DB_Parameters_ignoreGlobalRoutingInfo_get) {
    DB_Parameters *arg0 ;
    int argvi = 0;
    bool result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: DB_Parameters_ignoreGlobalRoutingInfo_get(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_DB_Parameters) < 0) {
        croak("Type error in argument 1 of DB_Parameters_ignoreGlobalRoutingInfo_get. Expected %s", SWIGTYPE_p_DB_Parameters->name);
        XSRETURN(1);
    }
    result = (bool ) (arg0->ignoreGlobalRoutingInfo);
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) result);
    XSRETURN(argvi);
}


XS(_wrap_DB_Parameters_ignoreDetailedRoutingInfo_set) {
    DB_Parameters *arg0 ;
    bool arg1 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) 
    croak("Usage: DB_Parameters_ignoreDetailedRoutingInfo_set(self,value);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_DB_Parameters) < 0) {
        croak("Type error in argument 1 of DB_Parameters_ignoreDetailedRoutingInfo_set. Expected %s", SWIGTYPE_p_DB_Parameters->name);
        XSRETURN(1);
    }
    arg1 = (bool )SvIV(ST(1));
    arg0->ignoreDetailedRoutingInfo = arg1;
    XSRETURN(argvi);
}


XS(_wrap_DB_Parameters_ignoreDetailedRoutingInfo_get) {
    DB_Parameters *arg0 ;
    int argvi = 0;
    bool result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: DB_Parameters_ignoreDetailedRoutingInfo_get(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_DB_Parameters) < 0) {
        croak("Type error in argument 1 of DB_Parameters_ignoreDetailedRoutingInfo_get. Expected %s", SWIGTYPE_p_DB_Parameters->name);
        XSRETURN(1);
    }
    result = (bool ) (arg0->ignoreDetailedRoutingInfo);
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) result);
    XSRETURN(argvi);
}


XS(_wrap_DB_Parameters_ignoreTimingLibs_set) {
    DB_Parameters *arg0 ;
    bool arg1 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) 
    croak("Usage: DB_Parameters_ignoreTimingLibs_set(self,value);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_DB_Parameters) < 0) {
        croak("Type error in argument 1 of DB_Parameters_ignoreTimingLibs_set. Expected %s", SWIGTYPE_p_DB_Parameters->name);
        XSRETURN(1);
    }
    arg1 = (bool )SvIV(ST(1));
    arg0->ignoreTimingLibs = arg1;
    XSRETURN(argvi);
}


XS(_wrap_DB_Parameters_ignoreTimingLibs_get) {
    DB_Parameters *arg0 ;
    int argvi = 0;
    bool result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: DB_Parameters_ignoreTimingLibs_get(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_DB_Parameters) < 0) {
        croak("Type error in argument 1 of DB_Parameters_ignoreTimingLibs_get. Expected %s", SWIGTYPE_p_DB_Parameters->name);
        XSRETURN(1);
    }
    result = (bool ) (arg0->ignoreTimingLibs);
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) result);
    XSRETURN(argvi);
}


XS(_wrap_DB_Parameters_fixPlacedPads_set) {
    DB_Parameters *arg0 ;
    bool arg1 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) 
    croak("Usage: DB_Parameters_fixPlacedPads_set(self,value);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_DB_Parameters) < 0) {
        croak("Type error in argument 1 of DB_Parameters_fixPlacedPads_set. Expected %s", SWIGTYPE_p_DB_Parameters->name);
        XSRETURN(1);
    }
    arg1 = (bool )SvIV(ST(1));
    arg0->fixPlacedPads = arg1;
    XSRETURN(argvi);
}


XS(_wrap_DB_Parameters_fixPlacedPads_get) {
    DB_Parameters *arg0 ;
    int argvi = 0;
    bool result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: DB_Parameters_fixPlacedPads_get(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_DB_Parameters) < 0) {
        croak("Type error in argument 1 of DB_Parameters_fixPlacedPads_get. Expected %s", SWIGTYPE_p_DB_Parameters->name);
        XSRETURN(1);
    }
    result = (bool ) (arg0->fixPlacedPads);
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) result);
    XSRETURN(argvi);
}


XS(_wrap_DB_Parameters_verbose_set) {
    DB_Parameters *arg0 ;
    Verbosity *arg1 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) 
    croak("Usage: DB_Parameters_verbose_set(self,value);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_DB_Parameters) < 0) {
        croak("Type error in argument 1 of DB_Parameters_verbose_set. Expected %s", SWIGTYPE_p_DB_Parameters->name);
        XSRETURN(1);
    }
    if (SWIG_ConvertPtr(ST(1),(void **) &arg1,SWIGTYPE_p_Verbosity) < 0) {
        croak("Type error in argument 2 of DB_Parameters_verbose_set. Expected %s", SWIGTYPE_p_Verbosity->name);
        XSRETURN(1);
    }
    arg0->verbose = *arg1;
    XSRETURN(argvi);
}


XS(_wrap_DB_Parameters_verbose_get) {
    DB_Parameters *arg0 ;
    int argvi = 0;
    Verbosity *result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: DB_Parameters_verbose_get(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_DB_Parameters) < 0) {
        croak("Type error in argument 1 of DB_Parameters_verbose_get. Expected %s", SWIGTYPE_p_DB_Parameters->name);
        XSRETURN(1);
    }
    result = (Verbosity *)& (arg0->verbose);
    ST(argvi) = sv_newmortal();
    SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_Verbosity);
    XSRETURN(argvi);
}


XS(_wrap_DB_Parameters_routedDesign_set) {
    DB_Parameters *arg0 ;
    bool arg1 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) 
    croak("Usage: DB_Parameters_routedDesign_set(self,value);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_DB_Parameters) < 0) {
        croak("Type error in argument 1 of DB_Parameters_routedDesign_set. Expected %s", SWIGTYPE_p_DB_Parameters->name);
        XSRETURN(1);
    }
    arg1 = (bool )SvIV(ST(1));
    arg0->routedDesign = arg1;
    XSRETURN(argvi);
}


XS(_wrap_DB_Parameters_routedDesign_get) {
    DB_Parameters *arg0 ;
    int argvi = 0;
    bool result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: DB_Parameters_routedDesign_get(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_DB_Parameters) < 0) {
        croak("Type error in argument 1 of DB_Parameters_routedDesign_get. Expected %s", SWIGTYPE_p_DB_Parameters->name);
        XSRETURN(1);
    }
    result = (bool ) (arg0->routedDesign);
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) result);
    XSRETURN(argvi);
}


XS(_wrap_DB_Parameters_alwaysCheckConsistency_set) {
    DB_Parameters *arg0 ;
    bool arg1 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) 
    croak("Usage: DB_Parameters_alwaysCheckConsistency_set(self,value);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_DB_Parameters) < 0) {
        croak("Type error in argument 1 of DB_Parameters_alwaysCheckConsistency_set. Expected %s", SWIGTYPE_p_DB_Parameters->name);
        XSRETURN(1);
    }
    arg1 = (bool )SvIV(ST(1));
    arg0->alwaysCheckConsistency = arg1;
    XSRETURN(argvi);
}


XS(_wrap_DB_Parameters_alwaysCheckConsistency_get) {
    DB_Parameters *arg0 ;
    int argvi = 0;
    bool result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: DB_Parameters_alwaysCheckConsistency_get(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_DB_Parameters) < 0) {
        croak("Type error in argument 1 of DB_Parameters_alwaysCheckConsistency_get. Expected %s", SWIGTYPE_p_DB_Parameters->name);
        XSRETURN(1);
    }
    result = (bool ) (arg0->alwaysCheckConsistency);
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) result);
    XSRETURN(argvi);
}


XS(_wrap_DB_Parameters_placeHolder2_set) {
    DB_Parameters *arg0 ;
    unsigned int arg1 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) 
    croak("Usage: DB_Parameters_placeHolder2_set(self,value);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_DB_Parameters) < 0) {
        croak("Type error in argument 1 of DB_Parameters_placeHolder2_set. Expected %s", SWIGTYPE_p_DB_Parameters->name);
        XSRETURN(1);
    }
    arg1 = (unsigned int )SvIV(ST(1));
    arg0->placeHolder2 = arg1;
    XSRETURN(argvi);
}


XS(_wrap_DB_Parameters_placeHolder2_get) {
    DB_Parameters *arg0 ;
    int argvi = 0;
    unsigned int result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: DB_Parameters_placeHolder2_get(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_DB_Parameters) < 0) {
        croak("Type error in argument 1 of DB_Parameters_placeHolder2_get. Expected %s", SWIGTYPE_p_DB_Parameters->name);
        XSRETURN(1);
    }
    result = (unsigned int ) (arg0->placeHolder2);
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) result);
    XSRETURN(argvi);
}


XS(_wrap_DB_Parameters_placeHolder3_set) {
    DB_Parameters *arg0 ;
    unsigned int arg1 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) 
    croak("Usage: DB_Parameters_placeHolder3_set(self,value);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_DB_Parameters) < 0) {
        croak("Type error in argument 1 of DB_Parameters_placeHolder3_set. Expected %s", SWIGTYPE_p_DB_Parameters->name);
        XSRETURN(1);
    }
    arg1 = (unsigned int )SvIV(ST(1));
    arg0->placeHolder3 = arg1;
    XSRETURN(argvi);
}


XS(_wrap_DB_Parameters_placeHolder3_get) {
    DB_Parameters *arg0 ;
    int argvi = 0;
    unsigned int result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: DB_Parameters_placeHolder3_get(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_DB_Parameters) < 0) {
        croak("Type error in argument 1 of DB_Parameters_placeHolder3_get. Expected %s", SWIGTYPE_p_DB_Parameters->name);
        XSRETURN(1);
    }
    result = (unsigned int ) (arg0->placeHolder3);
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) result);
    XSRETURN(argvi);
}


XS(_wrap_DB_Parameters_placeHolder4_set) {
    DB_Parameters *arg0 ;
    double arg1 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) 
    croak("Usage: DB_Parameters_placeHolder4_set(self,value);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_DB_Parameters) < 0) {
        croak("Type error in argument 1 of DB_Parameters_placeHolder4_set. Expected %s", SWIGTYPE_p_DB_Parameters->name);
        XSRETURN(1);
    }
    arg1 = (double )SvNV(ST(1));
    arg0->placeHolder4 = arg1;
    XSRETURN(argvi);
}


XS(_wrap_DB_Parameters_placeHolder4_get) {
    DB_Parameters *arg0 ;
    int argvi = 0;
    double result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: DB_Parameters_placeHolder4_get(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_DB_Parameters) < 0) {
        croak("Type error in argument 1 of DB_Parameters_placeHolder4_get. Expected %s", SWIGTYPE_p_DB_Parameters->name);
        XSRETURN(1);
    }
    result = (double ) (arg0->placeHolder4);
    ST(argvi) = sv_newmortal();
    sv_setnv(ST(argvi++), (double) result);
    XSRETURN(argvi);
}


XS(_wrap_DB_Parameters_placeHolder5_set) {
    DB_Parameters *arg0 ;
    double arg1 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) 
    croak("Usage: DB_Parameters_placeHolder5_set(self,value);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_DB_Parameters) < 0) {
        croak("Type error in argument 1 of DB_Parameters_placeHolder5_set. Expected %s", SWIGTYPE_p_DB_Parameters->name);
        XSRETURN(1);
    }
    arg1 = (double )SvNV(ST(1));
    arg0->placeHolder5 = arg1;
    XSRETURN(argvi);
}


XS(_wrap_DB_Parameters_placeHolder5_get) {
    DB_Parameters *arg0 ;
    int argvi = 0;
    double result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: DB_Parameters_placeHolder5_get(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_DB_Parameters) < 0) {
        croak("Type error in argument 1 of DB_Parameters_placeHolder5_get. Expected %s", SWIGTYPE_p_DB_Parameters->name);
        XSRETURN(1);
    }
    result = (double ) (arg0->placeHolder5);
    ST(argvi) = sv_newmortal();
    sv_setnv(ST(argvi++), (double) result);
    XSRETURN(argvi);
}


XS(_wrap_new_DB_Parameters) {
    int argvi = 0;
    DB_Parameters *result ;
    dXSARGS;
    
    if ((items < 0) || (items > 0)) 
    croak("Usage: new_DB_Parameters();");
    result = (DB_Parameters *)new DB_Parameters();
    ST(argvi) = sv_newmortal();
    SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_DB_Parameters);
    XSRETURN(argvi);
}


XS(_wrap_new_RBPlacement) {
    char *arg0 ;
    RBPlacement_Parameters *arg1 ;
    int argvi = 0;
    RBPlacement *result ;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) 
    croak("Usage: new_RBPlacement(auxFileName,params);");
    if (! SvOK((SV*) ST(0))) {
        arg0 = 0; 
    }
    else {
        arg0 = (char *) SvPV(ST(0),PL_na); 
    }
    if (SWIG_ConvertPtr(ST(1),(void **) &arg1,SWIGTYPE_p_RBPlacement_Parameters) < 0) {
        croak("Type error in argument 2 of new_RBPlacement. Expected %s", SWIGTYPE_p_RBPlacement_Parameters->name);
        XSRETURN(1);
    }
    result = (RBPlacement *)new RBPlacement((char const *)arg0,(RBPlacement_Parameters const &)*arg1);
    ST(argvi) = sv_newmortal();
    SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_RBPlacement);
    XSRETURN(argvi);
}


XS(_wrap_delete_RBPlacement) {
    RBPlacement *arg0 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: delete_RBPlacement(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_RBPlacement) < 0) {
        croak("Type error in argument 1 of delete_RBPlacement. Expected %s", SWIGTYPE_p_RBPlacement->name);
        XSRETURN(1);
    }
    delete arg0;
    XSRETURN(argvi);
}


XS(_wrap_RBPlacement_getOrigFileName) {
    RBPlacement *arg0 ;
    int argvi = 0;
    char *result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: RBPlacement_getOrigFileName(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_RBPlacement) < 0) {
        croak("Type error in argument 1 of RBPlacement_getOrigFileName. Expected %s", SWIGTYPE_p_RBPlacement->name);
        XSRETURN(1);
    }
    result = (char *)arg0->getOrigFileName();
    ST(argvi) = sv_newmortal();
    sv_setpv((SV*)ST(argvi++),(char *) result);
    XSRETURN(argvi);
}


XS(_wrap_RBPlacement_getAuxName) {
    RBPlacement *arg0 ;
    int argvi = 0;
    char *result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: RBPlacement_getAuxName(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_RBPlacement) < 0) {
        croak("Type error in argument 1 of RBPlacement_getAuxName. Expected %s", SWIGTYPE_p_RBPlacement->name);
        XSRETURN(1);
    }
    result = (char *)arg0->getAuxName();
    ST(argvi) = sv_newmortal();
    sv_setpv((SV*)ST(argvi++),(char *) result);
    XSRETURN(argvi);
}


XS(_wrap_RBPlacement_getDirName) {
    RBPlacement *arg0 ;
    int argvi = 0;
    char *result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: RBPlacement_getDirName(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_RBPlacement) < 0) {
        croak("Type error in argument 1 of RBPlacement_getDirName. Expected %s", SWIGTYPE_p_RBPlacement->name);
        XSRETURN(1);
    }
    result = (char *)arg0->getDirName();
    ST(argvi) = sv_newmortal();
    sv_setpv((SV*)ST(argvi++),(char *) result);
    XSRETURN(argvi);
}


XS(_wrap_RBPlacement_getFileNames) {
    RBPlacement *arg0 ;
    int argvi = 0;
    vector<char*> *result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: RBPlacement_getFileNames(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_RBPlacement) < 0) {
        croak("Type error in argument 1 of RBPlacement_getFileNames. Expected %s", SWIGTYPE_p_RBPlacement->name);
        XSRETURN(1);
    }
    vector<char*> const &_result_ref = arg0->getFileNames();
    result = (vector<char*> *) &_result_ref;
    ST(argvi) = sv_newmortal();
    SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_vector_char__);
    XSRETURN(argvi);
}


XS(_wrap_RBPlacement_resetPlacementWOri) {
    RBPlacement *arg0 ;
    PlacementWOrient *arg1 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) 
    croak("Usage: RBPlacement_resetPlacementWOri(self,pl);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_RBPlacement) < 0) {
        croak("Type error in argument 1 of RBPlacement_resetPlacementWOri. Expected %s", SWIGTYPE_p_RBPlacement->name);
        XSRETURN(1);
    }
    if (SWIG_ConvertPtr(ST(1),(void **) &arg1,SWIGTYPE_p_PlacementWOrient) < 0) {
        croak("Type error in argument 2 of RBPlacement_resetPlacementWOri. Expected %s", SWIGTYPE_p_PlacementWOrient->name);
        XSRETURN(1);
    }
    arg0->resetPlacementWOri((PlacementWOrient const &)*arg1);
    XSRETURN(argvi);
}


XS(_wrap_RBPlacement_resetPlacement) {
    RBPlacement *arg0 ;
    Placement *arg1 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) 
    croak("Usage: RBPlacement_resetPlacement(self,pl);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_RBPlacement) < 0) {
        croak("Type error in argument 1 of RBPlacement_resetPlacement. Expected %s", SWIGTYPE_p_RBPlacement->name);
        XSRETURN(1);
    }
    if (SWIG_ConvertPtr(ST(1),(void **) &arg1,SWIGTYPE_p_Placement) < 0) {
        croak("Type error in argument 2 of RBPlacement_resetPlacement. Expected %s", SWIGTYPE_p_Placement->name);
        XSRETURN(1);
    }
    arg0->resetPlacement((Placement const &)*arg1);
    XSRETURN(argvi);
}


XS(_wrap_RBPlacement_getNumCells) {
    RBPlacement *arg0 ;
    int argvi = 0;
    unsigned int result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: RBPlacement_getNumCells(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_RBPlacement) < 0) {
        croak("Type error in argument 1 of RBPlacement_getNumCells. Expected %s", SWIGTYPE_p_RBPlacement->name);
        XSRETURN(1);
    }
    result = (unsigned int )arg0->getNumCells();
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) result);
    XSRETURN(argvi);
}


XS(_wrap_RBPlacement_isPopulated) {
    RBPlacement *arg0 ;
    int argvi = 0;
    bool result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: RBPlacement_isPopulated(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_RBPlacement) < 0) {
        croak("Type error in argument 1 of RBPlacement_isPopulated. Expected %s", SWIGTYPE_p_RBPlacement->name);
        XSRETURN(1);
    }
    result = (bool )arg0->isPopulated();
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) result);
    XSRETURN(argvi);
}


XS(_wrap_RBPlacement_allCellsPlaced) {
    RBPlacement *arg0 ;
    int argvi = 0;
    bool result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: RBPlacement_allCellsPlaced(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_RBPlacement) < 0) {
        croak("Type error in argument 1 of RBPlacement_allCellsPlaced. Expected %s", SWIGTYPE_p_RBPlacement->name);
        XSRETURN(1);
    }
    result = (bool )arg0->allCellsPlaced();
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) result);
    XSRETURN(argvi);
}


XS(_wrap_RBPlacement_numCellsNotPlaced) {
    RBPlacement *arg0 ;
    int argvi = 0;
    unsigned int result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: RBPlacement_numCellsNotPlaced(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_RBPlacement) < 0) {
        croak("Type error in argument 1 of RBPlacement_numCellsNotPlaced. Expected %s", SWIGTYPE_p_RBPlacement->name);
        XSRETURN(1);
    }
    result = (unsigned int )arg0->numCellsNotPlaced();
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) result);
    XSRETURN(argvi);
}


XS(_wrap_RBPlacement_isCoreCell) {
    RBPlacement *arg0 ;
    unsigned int arg1 ;
    int argvi = 0;
    bool result ;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) 
    croak("Usage: RBPlacement_isCoreCell(self,id);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_RBPlacement) < 0) {
        croak("Type error in argument 1 of RBPlacement_isCoreCell. Expected %s", SWIGTYPE_p_RBPlacement->name);
        XSRETURN(1);
    }
    arg1 = (unsigned int )SvIV(ST(1));
    result = (bool )arg0->isCoreCell(arg1);
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) result);
    XSRETURN(argvi);
}


XS(_wrap_RBPlacement_isFixed) {
    RBPlacement *arg0 ;
    unsigned int arg1 ;
    int argvi = 0;
    bool result ;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) 
    croak("Usage: RBPlacement_isFixed(self,id);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_RBPlacement) < 0) {
        croak("Type error in argument 1 of RBPlacement_isFixed. Expected %s", SWIGTYPE_p_RBPlacement->name);
        XSRETURN(1);
    }
    arg1 = (unsigned int )SvIV(ST(1));
    result = (bool )arg0->isFixed(arg1);
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) result);
    XSRETURN(argvi);
}


XS(_wrap_RBPlacement_isStorElt) {
    RBPlacement *arg0 ;
    unsigned int arg1 ;
    int argvi = 0;
    bool result ;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) 
    croak("Usage: RBPlacement_isStorElt(self,id);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_RBPlacement) < 0) {
        croak("Type error in argument 1 of RBPlacement_isStorElt. Expected %s", SWIGTYPE_p_RBPlacement->name);
        XSRETURN(1);
    }
    arg1 = (unsigned int )SvIV(ST(1));
    result = (bool )arg0->isStorElt(arg1);
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) result);
    XSRETURN(argvi);
}


XS(_wrap_RBPlacement_isInSubRow) {
    RBPlacement *arg0 ;
    unsigned int arg1 ;
    int argvi = 0;
    bool result ;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) 
    croak("Usage: RBPlacement_isInSubRow(self,id);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_RBPlacement) < 0) {
        croak("Type error in argument 1 of RBPlacement_isInSubRow. Expected %s", SWIGTYPE_p_RBPlacement->name);
        XSRETURN(1);
    }
    arg1 = (unsigned int )SvIV(ST(1));
    result = (bool )arg0->isInSubRow(arg1);
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) result);
    XSRETURN(argvi);
}


XS(_wrap_RBPlacement_getFixed) {
    RBPlacement *arg0 ;
    int argvi = 0;
    bit_vector *result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: RBPlacement_getFixed(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_RBPlacement) < 0) {
        croak("Type error in argument 1 of RBPlacement_getFixed. Expected %s", SWIGTYPE_p_RBPlacement->name);
        XSRETURN(1);
    }
    bit_vector const &_result_ref = arg0->getFixed();
    result = (bit_vector *) &_result_ref;
    ST(argvi) = sv_newmortal();
    SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_bit_vector);
    XSRETURN(argvi);
}


XS(_wrap_RBPlacement_getStorElts) {
    RBPlacement *arg0 ;
    int argvi = 0;
    bit_vector *result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: RBPlacement_getStorElts(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_RBPlacement) < 0) {
        croak("Type error in argument 1 of RBPlacement_getStorElts. Expected %s", SWIGTYPE_p_RBPlacement->name);
        XSRETURN(1);
    }
    bit_vector const &_result_ref = arg0->getStorElts();
    result = (bit_vector *) &_result_ref;
    ST(argvi) = sv_newmortal();
    SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_bit_vector);
    XSRETURN(argvi);
}


XS(_wrap_RBPlacement_setLocation) {
    RBPlacement *arg0 ;
    unsigned int arg1 ;
    Point *arg2 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 3) || (items > 3)) 
    croak("Usage: RBPlacement_setLocation(self,id,pt);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_RBPlacement) < 0) {
        croak("Type error in argument 1 of RBPlacement_setLocation. Expected %s", SWIGTYPE_p_RBPlacement->name);
        XSRETURN(1);
    }
    arg1 = (unsigned int )SvIV(ST(1));
    if (SWIG_ConvertPtr(ST(2),(void **) &arg2,SWIGTYPE_p_Point) < 0) {
        croak("Type error in argument 3 of RBPlacement_setLocation. Expected %s", SWIGTYPE_p_Point->name);
        XSRETURN(1);
    }
    arg0->setLocation(arg1,(Point const &)*arg2);
    XSRETURN(argvi);
}


XS(_wrap_RBPlacement_getOrient) {
    RBPlacement *arg0 ;
    unsigned int arg1 ;
    int argvi = 0;
    Orient *result ;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) 
    croak("Usage: RBPlacement_getOrient(self,id);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_RBPlacement) < 0) {
        croak("Type error in argument 1 of RBPlacement_getOrient. Expected %s", SWIGTYPE_p_RBPlacement->name);
        XSRETURN(1);
    }
    arg1 = (unsigned int )SvIV(ST(1));
    Orient &_result_ref = arg0->getOrient(arg1);
    result = (Orient *) &_result_ref;
    ST(argvi) = sv_newmortal();
    SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_Orient);
    XSRETURN(argvi);
}


XS(_wrap_RBPlacement_setOrient) {
    RBPlacement *arg0 ;
    unsigned int arg1 ;
    Orient *arg2 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 3) || (items > 3)) 
    croak("Usage: RBPlacement_setOrient(self,id,ori);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_RBPlacement) < 0) {
        croak("Type error in argument 1 of RBPlacement_setOrient. Expected %s", SWIGTYPE_p_RBPlacement->name);
        XSRETURN(1);
    }
    arg1 = (unsigned int )SvIV(ST(1));
    if (SWIG_ConvertPtr(ST(2),(void **) &arg2,SWIGTYPE_p_Orient) < 0) {
        croak("Type error in argument 3 of RBPlacement_setOrient. Expected %s", SWIGTYPE_p_Orient->name);
        XSRETURN(1);
    }
    arg0->setOrient(arg1,*arg2);
    XSRETURN(argvi);
}


XS(_wrap_RBPlacement_findCoreRow) {
    RBPlacement *arg0 ;
    Point *arg1 ;
    int argvi = 0;
    RBPCoreRow *result ;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) 
    croak("Usage: RBPlacement_findCoreRow(self,point);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_RBPlacement) < 0) {
        croak("Type error in argument 1 of RBPlacement_findCoreRow. Expected %s", SWIGTYPE_p_RBPlacement->name);
        XSRETURN(1);
    }
    if (SWIG_ConvertPtr(ST(1),(void **) &arg1,SWIGTYPE_p_Point) < 0) {
        croak("Type error in argument 2 of RBPlacement_findCoreRow. Expected %s", SWIGTYPE_p_Point->name);
        XSRETURN(1);
    }
    result = (RBPCoreRow *)arg0->findCoreRow((Point const &)*arg1);
    ST(argvi) = sv_newmortal();
    SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_RBPCoreRow);
    XSRETURN(argvi);
}


XS(_wrap_RBPlacement_findSubRow) {
    RBPlacement *arg0 ;
    Point *arg1 ;
    int argvi = 0;
    RBPSubRow *result ;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) 
    croak("Usage: RBPlacement_findSubRow(self,point);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_RBPlacement) < 0) {
        croak("Type error in argument 1 of RBPlacement_findSubRow. Expected %s", SWIGTYPE_p_RBPlacement->name);
        XSRETURN(1);
    }
    if (SWIG_ConvertPtr(ST(1),(void **) &arg1,SWIGTYPE_p_Point) < 0) {
        croak("Type error in argument 2 of RBPlacement_findSubRow. Expected %s", SWIGTYPE_p_Point->name);
        XSRETURN(1);
    }
    result = (RBPSubRow *)arg0->findSubRow((Point const &)*arg1);
    ST(argvi) = sv_newmortal();
    SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_RBPSubRow);
    XSRETURN(argvi);
}


XS(_wrap_RBPlacement_findBothRows) {
    RBPlacement *arg0 ;
    Point *arg1 ;
    int argvi = 0;
    RBRowPtrs *result ;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) 
    croak("Usage: RBPlacement_findBothRows(self,point);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_RBPlacement) < 0) {
        croak("Type error in argument 1 of RBPlacement_findBothRows. Expected %s", SWIGTYPE_p_RBPlacement->name);
        XSRETURN(1);
    }
    if (SWIG_ConvertPtr(ST(1),(void **) &arg1,SWIGTYPE_p_Point) < 0) {
        croak("Type error in argument 2 of RBPlacement_findBothRows. Expected %s", SWIGTYPE_p_Point->name);
        XSRETURN(1);
    }
    result = new RBRowPtrs (arg0->findBothRows((Point const &)*arg1));    ST(argvi) = sv_newmortal();
    SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_RBRowPtrs);
    XSRETURN(argvi);
}


XS(_wrap_RBPlacement_coreRowsBegin) {
    RBPlacement *arg0 ;
    int argvi = 0;
    itRBPCoreRow *result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: RBPlacement_coreRowsBegin(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_RBPlacement) < 0) {
        croak("Type error in argument 1 of RBPlacement_coreRowsBegin. Expected %s", SWIGTYPE_p_RBPlacement->name);
        XSRETURN(1);
    }
    result = new itRBPCoreRow (arg0->coreRowsBegin());    ST(argvi) = sv_newmortal();
    SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_itRBPCoreRow);
    XSRETURN(argvi);
}


XS(_wrap_RBPlacement_coreRowsEnd) {
    RBPlacement *arg0 ;
    int argvi = 0;
    itRBPCoreRow *result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: RBPlacement_coreRowsEnd(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_RBPlacement) < 0) {
        croak("Type error in argument 1 of RBPlacement_coreRowsEnd. Expected %s", SWIGTYPE_p_RBPlacement->name);
        XSRETURN(1);
    }
    result = new itRBPCoreRow (arg0->coreRowsEnd());    ST(argvi) = sv_newmortal();
    SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_itRBPCoreRow);
    XSRETURN(argvi);
}


XS(_wrap_RBPlacement_getNumCoreRows) {
    RBPlacement *arg0 ;
    int argvi = 0;
    unsigned int result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: RBPlacement_getNumCoreRows(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_RBPlacement) < 0) {
        croak("Type error in argument 1 of RBPlacement_getNumCoreRows. Expected %s", SWIGTYPE_p_RBPlacement->name);
        XSRETURN(1);
    }
    result = (unsigned int )arg0->getNumCoreRows();
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) result);
    XSRETURN(argvi);
}


XS(_wrap_RBPlacement_isCellInRow) {
    RBPlacement *arg0 ;
    unsigned int arg1 ;
    int argvi = 0;
    bool result ;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) 
    croak("Usage: RBPlacement_isCellInRow(self,id);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_RBPlacement) < 0) {
        croak("Type error in argument 1 of RBPlacement_isCellInRow. Expected %s", SWIGTYPE_p_RBPlacement->name);
        XSRETURN(1);
    }
    arg1 = (unsigned int )SvIV(ST(1));
    result = (bool )arg0->isCellInRow(arg1);
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) result);
    XSRETURN(argvi);
}


XS(_wrap_RBPlacement_getCellCoord) {
    RBPlacement *arg0 ;
    unsigned int arg1 ;
    int argvi = 0;
    RBCellCoord *result ;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) 
    croak("Usage: RBPlacement_getCellCoord(self,id);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_RBPlacement) < 0) {
        croak("Type error in argument 1 of RBPlacement_getCellCoord. Expected %s", SWIGTYPE_p_RBPlacement->name);
        XSRETURN(1);
    }
    arg1 = (unsigned int )SvIV(ST(1));
    RBCellCoord const &_result_ref = arg0->getCellCoord(arg1);
    result = (RBCellCoord *) &_result_ref;
    ST(argvi) = sv_newmortal();
    SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_RBCellCoord);
    XSRETURN(argvi);
}


XS(_wrap_RBPlacement_extractCellsFromSR) {
    RBPlacement *arg0 ;
    RBPSubRow *arg1 ;
    vector<unsigned> *arg2 ;
    vector<double> *arg3 ;
    double arg4 = 0 ;
    double arg5 = DBL_MAX ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 4) || (items > 6)) 
    croak("Usage: RBPlacement_extractCellsFromSR(self,sr,cellIds,offsets,beginOffset,endOffset);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_RBPlacement) < 0) {
        croak("Type error in argument 1 of RBPlacement_extractCellsFromSR. Expected %s", SWIGTYPE_p_RBPlacement->name);
        XSRETURN(1);
    }
    if (SWIG_ConvertPtr(ST(1),(void **) &arg1,SWIGTYPE_p_RBPSubRow) < 0) {
        croak("Type error in argument 2 of RBPlacement_extractCellsFromSR. Expected %s", SWIGTYPE_p_RBPSubRow->name);
        XSRETURN(1);
    }
    if (SWIG_ConvertPtr(ST(2),(void **) &arg2,SWIGTYPE_p_vector_unsigned_) < 0) {
        croak("Type error in argument 3 of RBPlacement_extractCellsFromSR. Expected %s", SWIGTYPE_p_vector_unsigned_->name);
        XSRETURN(1);
    }
    if (SWIG_ConvertPtr(ST(3),(void **) &arg3,SWIGTYPE_p_vector_double_) < 0) {
        croak("Type error in argument 4 of RBPlacement_extractCellsFromSR. Expected %s", SWIGTYPE_p_vector_double_->name);
        XSRETURN(1);
    }
    if (items > 4) {
        arg4 = (double )SvNV(ST(4));
    }
    if (items > 5) {
        arg5 = (double )SvNV(ST(5));
    }
    arg0->extractCellsFromSR(*arg1,*arg2,*arg3,arg4,arg5);
    XSRETURN(argvi);
}


XS(_wrap_RBPlacement_embedCellsInSR) {
    RBPlacement *arg0 ;
    RBPSubRow *arg1 ;
    vector<unsigned> *arg2 ;
    vector<double> *arg3 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 4) || (items > 4)) 
    croak("Usage: RBPlacement_embedCellsInSR(self,sr,cellIds,offsets);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_RBPlacement) < 0) {
        croak("Type error in argument 1 of RBPlacement_embedCellsInSR. Expected %s", SWIGTYPE_p_RBPlacement->name);
        XSRETURN(1);
    }
    if (SWIG_ConvertPtr(ST(1),(void **) &arg1,SWIGTYPE_p_RBPSubRow) < 0) {
        croak("Type error in argument 2 of RBPlacement_embedCellsInSR. Expected %s", SWIGTYPE_p_RBPSubRow->name);
        XSRETURN(1);
    }
    if (SWIG_ConvertPtr(ST(2),(void **) &arg2,SWIGTYPE_p_vector_unsigned_) < 0) {
        croak("Type error in argument 3 of RBPlacement_embedCellsInSR. Expected %s", SWIGTYPE_p_vector_unsigned_->name);
        XSRETURN(1);
    }
    if (SWIG_ConvertPtr(ST(3),(void **) &arg3,SWIGTYPE_p_vector_double_) < 0) {
        croak("Type error in argument 4 of RBPlacement_embedCellsInSR. Expected %s", SWIGTYPE_p_vector_double_->name);
        XSRETURN(1);
    }
    arg0->embedCellsInSR(*arg1,(vector<unsigned> const &)*arg2,(vector<double> const &)*arg3);
    XSRETURN(argvi);
}


XS(_wrap_RBPlacement_permuteCellsInSR) {
    RBPlacement *arg0 ;
    RBPSubRow *arg1 ;
    unsigned int arg2 ;
    vector<unsigned> *arg3 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 4) || (items > 4)) 
    croak("Usage: RBPlacement_permuteCellsInSR(self,sr,firstCellOffset,newCellOrder);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_RBPlacement) < 0) {
        croak("Type error in argument 1 of RBPlacement_permuteCellsInSR. Expected %s", SWIGTYPE_p_RBPlacement->name);
        XSRETURN(1);
    }
    if (SWIG_ConvertPtr(ST(1),(void **) &arg1,SWIGTYPE_p_RBPSubRow) < 0) {
        croak("Type error in argument 2 of RBPlacement_permuteCellsInSR. Expected %s", SWIGTYPE_p_RBPSubRow->name);
        XSRETURN(1);
    }
    arg2 = (unsigned int )SvIV(ST(2));
    if (SWIG_ConvertPtr(ST(3),(void **) &arg3,SWIGTYPE_p_vector_unsigned_) < 0) {
        croak("Type error in argument 4 of RBPlacement_permuteCellsInSR. Expected %s", SWIGTYPE_p_vector_unsigned_->name);
        XSRETURN(1);
    }
    arg0->permuteCellsInSR(*arg1,arg2,(vector<unsigned> const &)*arg3);
    XSRETURN(argvi);
}


XS(_wrap_RBPlacement_placeTerms) {
    RBPlacement *arg0 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: RBPlacement_placeTerms(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_RBPlacement) < 0) {
        croak("Type error in argument 1 of RBPlacement_placeTerms. Expected %s", SWIGTYPE_p_RBPlacement->name);
        XSRETURN(1);
    }
    arg0->placeTerms();
    XSRETURN(argvi);
}


XS(_wrap_RBPlacement_evalHPWL) {
    RBPlacement *arg0 ;
    bool arg1 = false ;
    int argvi = 0;
    double result ;
    dXSARGS;
    
    if ((items < 1) || (items > 2)) 
    croak("Usage: RBPlacement_evalHPWL(self,usePinLocs);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_RBPlacement) < 0) {
        croak("Type error in argument 1 of RBPlacement_evalHPWL. Expected %s", SWIGTYPE_p_RBPlacement->name);
        XSRETURN(1);
    }
    if (items > 1) {
        arg1 = (bool )SvIV(ST(1));
    }
    result = (double )arg0->evalHPWL(arg1);
    ST(argvi) = sv_newmortal();
    sv_setnv(ST(argvi++), (double) result);
    XSRETURN(argvi);
}


XS(_wrap_RBPlacement_evalMSTWL) {
    RBPlacement *arg0 ;
    bool arg1 = false ;
    int argvi = 0;
    double result ;
    dXSARGS;
    
    if ((items < 1) || (items > 2)) 
    croak("Usage: RBPlacement_evalMSTWL(self,usePinLocs);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_RBPlacement) < 0) {
        croak("Type error in argument 1 of RBPlacement_evalMSTWL. Expected %s", SWIGTYPE_p_RBPlacement->name);
        XSRETURN(1);
    }
    if (items > 1) {
        arg1 = (bool )SvIV(ST(1));
    }
    result = (double )arg0->evalMSTWL(arg1);
    ST(argvi) = sv_newmortal();
    sv_setnv(ST(argvi++), (double) result);
    XSRETURN(argvi);
}


XS(_wrap_RBPlacement_evalWeightedWL) {
    RBPlacement *arg0 ;
    bool arg1 = false ;
    int argvi = 0;
    double result ;
    dXSARGS;
    
    if ((items < 1) || (items > 2)) 
    croak("Usage: RBPlacement_evalWeightedWL(self,usePinLocs);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_RBPlacement) < 0) {
        croak("Type error in argument 1 of RBPlacement_evalWeightedWL. Expected %s", SWIGTYPE_p_RBPlacement->name);
        XSRETURN(1);
    }
    if (items > 1) {
        arg1 = (bool )SvIV(ST(1));
    }
    result = (double )arg0->evalWeightedWL(arg1);
    ST(argvi) = sv_newmortal();
    sv_setnv(ST(argvi++), (double) result);
    XSRETURN(argvi);
}


XS(_wrap_RBPlacement_evalNetsHPWL) {
    RBPlacement *arg0 ;
    vector<unsigned> *arg1 ;
    bool arg2 = false ;
    int argvi = 0;
    double result ;
    dXSARGS;
    
    if ((items < 2) || (items > 3)) 
    croak("Usage: RBPlacement_evalNetsHPWL(self,netsToEval,usePinLocs);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_RBPlacement) < 0) {
        croak("Type error in argument 1 of RBPlacement_evalNetsHPWL. Expected %s", SWIGTYPE_p_RBPlacement->name);
        XSRETURN(1);
    }
    if (SWIG_ConvertPtr(ST(1),(void **) &arg1,SWIGTYPE_p_vector_unsigned_) < 0) {
        croak("Type error in argument 2 of RBPlacement_evalNetsHPWL. Expected %s", SWIGTYPE_p_vector_unsigned_->name);
        XSRETURN(1);
    }
    if (items > 2) {
        arg2 = (bool )SvIV(ST(2));
    }
    result = (double )arg0->evalNetsHPWL((vector<unsigned> const &)*arg1,arg2);
    ST(argvi) = sv_newmortal();
    sv_setnv(ST(argvi++), (double) result);
    XSRETURN(argvi);
}


XS(_wrap_RBPlacement_getHGraph) {
    RBPlacement *arg0 ;
    int argvi = 0;
    HGraphWDimensions *result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: RBPlacement_getHGraph(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_RBPlacement) < 0) {
        croak("Type error in argument 1 of RBPlacement_getHGraph. Expected %s", SWIGTYPE_p_RBPlacement->name);
        XSRETURN(1);
    }
    HGraphWDimensions const &_result_ref = arg0->getHGraph();
    result = (HGraphWDimensions *) &_result_ref;
    ST(argvi) = sv_newmortal();
    SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_HGraphWDimensions);
    XSRETURN(argvi);
}


XS(_wrap_RBPlacement_isConsistent) {
    RBPlacement *arg0 ;
    int argvi = 0;
    bool result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: RBPlacement_isConsistent(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_RBPlacement) < 0) {
        croak("Type error in argument 1 of RBPlacement_isConsistent. Expected %s", SWIGTYPE_p_RBPlacement->name);
        XSRETURN(1);
    }
    result = (bool )arg0->isConsistent();
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) result);
    XSRETURN(argvi);
}


XS(_wrap_RBPlacement_printRows) {
    RBPlacement *arg0 ;
    char *arg1 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) 
    croak("Usage: RBPlacement_printRows(self,filename);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_RBPlacement) < 0) {
        croak("Type error in argument 1 of RBPlacement_printRows. Expected %s", SWIGTYPE_p_RBPlacement->name);
        XSRETURN(1);
    }
    if (! SvOK((SV*) ST(1))) {
        arg1 = 0; 
    }
    else {
        arg1 = (char *) SvPV(ST(1),PL_na); 
    }
    arg0->printRows((char const *)arg1);
    XSRETURN(argvi);
}


XS(_wrap_RBPlacement_saveAsSCL) {
    RBPlacement *arg0 ;
    char *arg1 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) 
    croak("Usage: RBPlacement_saveAsSCL(self,baseFileName);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_RBPlacement) < 0) {
        croak("Type error in argument 1 of RBPlacement_saveAsSCL. Expected %s", SWIGTYPE_p_RBPlacement->name);
        XSRETURN(1);
    }
    if (! SvOK((SV*) ST(1))) {
        arg1 = 0; 
    }
    else {
        arg1 = (char *) SvPV(ST(1),PL_na); 
    }
    arg0->saveAsSCL((char const *)arg1);
    XSRETURN(argvi);
}


XS(_wrap_RBPlacement_saveAsNodesNetsWts) {
    RBPlacement *arg0 ;
    char *arg1 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) 
    croak("Usage: RBPlacement_saveAsNodesNetsWts(self,baseFileName);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_RBPlacement) < 0) {
        croak("Type error in argument 1 of RBPlacement_saveAsNodesNetsWts. Expected %s", SWIGTYPE_p_RBPlacement->name);
        XSRETURN(1);
    }
    if (! SvOK((SV*) ST(1))) {
        arg1 = 0; 
    }
    else {
        arg1 = (char *) SvPV(ST(1),PL_na); 
    }
    arg0->saveAsNodesNetsWts((char const *)arg1);
    XSRETURN(argvi);
}


XS(_wrap_RBPlacement_saveAsNetDAre) {
    RBPlacement *arg0 ;
    char *arg1 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) 
    croak("Usage: RBPlacement_saveAsNetDAre(self,baseFileName);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_RBPlacement) < 0) {
        croak("Type error in argument 1 of RBPlacement_saveAsNetDAre. Expected %s", SWIGTYPE_p_RBPlacement->name);
        XSRETURN(1);
    }
    if (! SvOK((SV*) ST(1))) {
        arg1 = 0; 
    }
    else {
        arg1 = (char *) SvPV(ST(1),PL_na); 
    }
    arg0->saveAsNetDAre((char const *)arg1);
    XSRETURN(argvi);
}


XS(_wrap_RBPlacement_savePlacement) {
    RBPlacement *arg0 ;
    char *arg1 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) 
    croak("Usage: RBPlacement_savePlacement(self,plFileName);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_RBPlacement) < 0) {
        croak("Type error in argument 1 of RBPlacement_savePlacement. Expected %s", SWIGTYPE_p_RBPlacement->name);
        XSRETURN(1);
    }
    if (! SvOK((SV*) ST(1))) {
        arg1 = 0; 
    }
    else {
        arg1 = (char *) SvPV(ST(1),PL_na); 
    }
    arg0->savePlacement((char const *)arg1);
    XSRETURN(argvi);
}


XS(_wrap_RBPlacement_saveAsSpatialConstraints) {
    RBPlacement *arg0 ;
    char *arg1 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) 
    croak("Usage: RBPlacement_saveAsSpatialConstraints(self,constFileName);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_RBPlacement) < 0) {
        croak("Type error in argument 1 of RBPlacement_saveAsSpatialConstraints. Expected %s", SWIGTYPE_p_RBPlacement->name);
        XSRETURN(1);
    }
    if (! SvOK((SV*) ST(1))) {
        arg1 = 0; 
    }
    else {
        arg1 = (char *) SvPV(ST(1),PL_na); 
    }
    arg0->saveAsSpatialConstraints((char const *)arg1);
    XSRETURN(argvi);
}


XS(_wrap_RBPlacement_saveAsPlot) {
    RBPlacement *arg0 ;
    char *arg1 ;
    double arg2 ;
    double arg3 ;
    double arg4 ;
    double arg5 ;
    char *arg6 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 7) || (items > 7)) 
    croak("Usage: RBPlacement_saveAsPlot(self,command,xmin,xmax,ymin,ymax,baseFileName);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_RBPlacement) < 0) {
        croak("Type error in argument 1 of RBPlacement_saveAsPlot. Expected %s", SWIGTYPE_p_RBPlacement->name);
        XSRETURN(1);
    }
    if (! SvOK((SV*) ST(1))) {
        arg1 = 0; 
    }
    else {
        arg1 = (char *) SvPV(ST(1),PL_na); 
    }
    arg2 = (double )SvNV(ST(2));
    arg3 = (double )SvNV(ST(3));
    arg4 = (double )SvNV(ST(4));
    arg5 = (double )SvNV(ST(5));
    if (! SvOK((SV*) ST(6))) {
        arg6 = 0; 
    }
    else {
        arg6 = (char *) SvPV(ST(6),PL_na); 
    }
    arg0->saveAsPlot(arg1,arg2,arg3,arg4,arg5,(char const *)arg6);
    XSRETURN(argvi);
}


XS(_wrap_RBPlacement_remOverlaps) {
    RBPlacement *arg0 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: RBPlacement_remOverlaps(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_RBPlacement) < 0) {
        croak("Type error in argument 1 of RBPlacement_remOverlaps. Expected %s", SWIGTYPE_p_RBPlacement->name);
        XSRETURN(1);
    }
    arg0->remOverlaps();
    XSRETURN(argvi);
}


XS(_wrap_RBPlacement_remOverlapsVert) {
    RBPlacement *arg0 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: RBPlacement_remOverlapsVert(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_RBPlacement) < 0) {
        croak("Type error in argument 1 of RBPlacement_remOverlapsVert. Expected %s", SWIGTYPE_p_RBPlacement->name);
        XSRETURN(1);
    }
    arg0->remOverlapsVert();
    XSRETURN(argvi);
}


XS(_wrap_RBPlacement_permuteCellsAndWSInSR) {
    RBPlacement *arg0 ;
    RBPSubRow *arg1 ;
    unsigned int arg2 ;
    vector<unsigned> *arg3 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 4) || (items > 4)) 
    croak("Usage: RBPlacement_permuteCellsAndWSInSR(self,sr,firstCellOffset,newCellOrder);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_RBPlacement) < 0) {
        croak("Type error in argument 1 of RBPlacement_permuteCellsAndWSInSR. Expected %s", SWIGTYPE_p_RBPlacement->name);
        XSRETURN(1);
    }
    if (SWIG_ConvertPtr(ST(1),(void **) &arg1,SWIGTYPE_p_RBPSubRow) < 0) {
        croak("Type error in argument 2 of RBPlacement_permuteCellsAndWSInSR. Expected %s", SWIGTYPE_p_RBPSubRow->name);
        XSRETURN(1);
    }
    arg2 = (unsigned int )SvIV(ST(2));
    if (SWIG_ConvertPtr(ST(3),(void **) &arg3,SWIGTYPE_p_vector_unsigned_) < 0) {
        croak("Type error in argument 4 of RBPlacement_permuteCellsAndWSInSR. Expected %s", SWIGTYPE_p_vector_unsigned_->name);
        XSRETURN(1);
    }
    arg0->permuteCellsAndWSInSR(*arg1,arg2,(vector<unsigned> const &)*arg3);
    XSRETURN(argvi);
}


XS(_wrap_RBPlacement_updateIronedCells) {
    RBPlacement *arg0 ;
    vector<unsigned> *arg1 ;
    Placement *arg2 ;
    RBPSubRow *arg3 ;
    RBPSubRow *arg4 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 5) || (items > 5)) 
    croak("Usage: RBPlacement_updateIronedCells(self,movables,soln,subrow1,subrow2);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_RBPlacement) < 0) {
        croak("Type error in argument 1 of RBPlacement_updateIronedCells. Expected %s", SWIGTYPE_p_RBPlacement->name);
        XSRETURN(1);
    }
    if (SWIG_ConvertPtr(ST(1),(void **) &arg1,SWIGTYPE_p_vector_unsigned_) < 0) {
        croak("Type error in argument 2 of RBPlacement_updateIronedCells. Expected %s", SWIGTYPE_p_vector_unsigned_->name);
        XSRETURN(1);
    }
    if (SWIG_ConvertPtr(ST(2),(void **) &arg2,SWIGTYPE_p_Placement) < 0) {
        croak("Type error in argument 3 of RBPlacement_updateIronedCells. Expected %s", SWIGTYPE_p_Placement->name);
        XSRETURN(1);
    }
    if (SWIG_ConvertPtr(ST(3),(void **) &arg3,SWIGTYPE_p_RBPSubRow) < 0) {
        croak("Type error in argument 4 of RBPlacement_updateIronedCells. Expected %s", SWIGTYPE_p_RBPSubRow->name);
        XSRETURN(1);
    }
    if (SWIG_ConvertPtr(ST(4),(void **) &arg4,SWIGTYPE_p_RBPSubRow) < 0) {
        croak("Type error in argument 5 of RBPlacement_updateIronedCells. Expected %s", SWIGTYPE_p_RBPSubRow->name);
        XSRETURN(1);
    }
    arg0->updateIronedCells((vector<unsigned> const &)*arg1,(Placement const &)*arg2,*arg3,*arg4);
    XSRETURN(argvi);
}


XS(_wrap_RBPlacement_updateIronedCellsLR) {
    RBPlacement *arg0 ;
    vector< vector<unsigned> > *arg1 ;
    Placement *arg2 ;
    RBPSubRow *arg3 ;
    RBPSubRow *arg4 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 5) || (items > 5)) 
    croak("Usage: RBPlacement_updateIronedCellsLR(self,movables,soln,subrow1,subrow2);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_RBPlacement) < 0) {
        croak("Type error in argument 1 of RBPlacement_updateIronedCellsLR. Expected %s", SWIGTYPE_p_RBPlacement->name);
        XSRETURN(1);
    }
    if (SWIG_ConvertPtr(ST(1),(void **) &arg1,SWIGTYPE_p_vector__vector_unsigned___) < 0) {
        croak("Type error in argument 2 of RBPlacement_updateIronedCellsLR. Expected %s", SWIGTYPE_p_vector__vector_unsigned___->name);
        XSRETURN(1);
    }
    if (SWIG_ConvertPtr(ST(2),(void **) &arg2,SWIGTYPE_p_Placement) < 0) {
        croak("Type error in argument 3 of RBPlacement_updateIronedCellsLR. Expected %s", SWIGTYPE_p_Placement->name);
        XSRETURN(1);
    }
    if (SWIG_ConvertPtr(ST(3),(void **) &arg3,SWIGTYPE_p_RBPSubRow) < 0) {
        croak("Type error in argument 4 of RBPlacement_updateIronedCellsLR. Expected %s", SWIGTYPE_p_RBPSubRow->name);
        XSRETURN(1);
    }
    if (SWIG_ConvertPtr(ST(4),(void **) &arg4,SWIGTYPE_p_RBPSubRow) < 0) {
        croak("Type error in argument 5 of RBPlacement_updateIronedCellsLR. Expected %s", SWIGTYPE_p_RBPSubRow->name);
        XSRETURN(1);
    }
    arg0->updateIronedCellsLR((vector< vector<unsigned> > const &)*arg1,(Placement const &)*arg2,*arg3,*arg4);
    XSRETURN(argvi);
}


XS(_wrap_RBPlacement_updateIronedCellsRL) {
    RBPlacement *arg0 ;
    vector< vector<unsigned> > *arg1 ;
    Placement *arg2 ;
    RBPSubRow *arg3 ;
    RBPSubRow *arg4 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 5) || (items > 5)) 
    croak("Usage: RBPlacement_updateIronedCellsRL(self,movables,soln,subrow1,subrow2);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_RBPlacement) < 0) {
        croak("Type error in argument 1 of RBPlacement_updateIronedCellsRL. Expected %s", SWIGTYPE_p_RBPlacement->name);
        XSRETURN(1);
    }
    if (SWIG_ConvertPtr(ST(1),(void **) &arg1,SWIGTYPE_p_vector__vector_unsigned___) < 0) {
        croak("Type error in argument 2 of RBPlacement_updateIronedCellsRL. Expected %s", SWIGTYPE_p_vector__vector_unsigned___->name);
        XSRETURN(1);
    }
    if (SWIG_ConvertPtr(ST(2),(void **) &arg2,SWIGTYPE_p_Placement) < 0) {
        croak("Type error in argument 3 of RBPlacement_updateIronedCellsRL. Expected %s", SWIGTYPE_p_Placement->name);
        XSRETURN(1);
    }
    if (SWIG_ConvertPtr(ST(3),(void **) &arg3,SWIGTYPE_p_RBPSubRow) < 0) {
        croak("Type error in argument 4 of RBPlacement_updateIronedCellsRL. Expected %s", SWIGTYPE_p_RBPSubRow->name);
        XSRETURN(1);
    }
    if (SWIG_ConvertPtr(ST(4),(void **) &arg4,SWIGTYPE_p_RBPSubRow) < 0) {
        croak("Type error in argument 5 of RBPlacement_updateIronedCellsRL. Expected %s", SWIGTYPE_p_RBPSubRow->name);
        XSRETURN(1);
    }
    arg0->updateIronedCellsRL((vector< vector<unsigned> > const &)*arg1,(Placement const &)*arg2,*arg3,*arg4);
    XSRETURN(argvi);
}


XS(_wrap_RBPlacement_calcInstHPWL) {
    RBPlacement *arg0 ;
    vector<unsigned> *arg1 ;
    int argvi = 0;
    double result ;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) 
    croak("Usage: RBPlacement_calcInstHPWL(self,cellIds);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_RBPlacement) < 0) {
        croak("Type error in argument 1 of RBPlacement_calcInstHPWL. Expected %s", SWIGTYPE_p_RBPlacement->name);
        XSRETURN(1);
    }
    if (SWIG_ConvertPtr(ST(1),(void **) &arg1,SWIGTYPE_p_vector_unsigned_) < 0) {
        croak("Type error in argument 2 of RBPlacement_calcInstHPWL. Expected %s", SWIGTYPE_p_vector_unsigned_->name);
        XSRETURN(1);
    }
    result = (double )arg0->calcInstHPWL(*arg1);
    ST(argvi) = sv_newmortal();
    sv_setnv(ST(argvi++), (double) result);
    XSRETURN(argvi);
}


XS(_wrap_RBPlacement_saveLEFDEF) {
    RBPlacement *arg0 ;
    char *arg1 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) 
    croak("Usage: RBPlacement_saveLEFDEF(self,baseFileName);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_RBPlacement) < 0) {
        croak("Type error in argument 1 of RBPlacement_saveLEFDEF. Expected %s", SWIGTYPE_p_RBPlacement->name);
        XSRETURN(1);
    }
    if (! SvOK((SV*) ST(1))) {
        arg1 = 0; 
    }
    else {
        arg1 = (char *) SvPV(ST(1),PL_na); 
    }
    arg0->saveLEFDEF((char const *)arg1);
    XSRETURN(argvi);
}


XS(_wrap_RBPlacement_getBBox) {
    RBPlacement *arg0 ;
    int argvi = 0;
    BBox *result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: RBPlacement_getBBox(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_RBPlacement) < 0) {
        croak("Type error in argument 1 of RBPlacement_getBBox. Expected %s", SWIGTYPE_p_RBPlacement->name);
        XSRETURN(1);
    }
    result = new BBox (arg0->getBBox());    ST(argvi) = sv_newmortal();
    SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_BBox);
    XSRETURN(argvi);
}


XS(_wrap_RBPlacement_Parameters_verb_set) {
    RBPlacement_Parameters *arg0 ;
    Verbosity *arg1 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) 
    croak("Usage: RBPlacement_Parameters_verb_set(self,value);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_RBPlacement_Parameters) < 0) {
        croak("Type error in argument 1 of RBPlacement_Parameters_verb_set. Expected %s", SWIGTYPE_p_RBPlacement_Parameters->name);
        XSRETURN(1);
    }
    if (SWIG_ConvertPtr(ST(1),(void **) &arg1,SWIGTYPE_p_Verbosity) < 0) {
        croak("Type error in argument 2 of RBPlacement_Parameters_verb_set. Expected %s", SWIGTYPE_p_Verbosity->name);
        XSRETURN(1);
    }
    arg0->verb = *arg1;
    XSRETURN(argvi);
}


XS(_wrap_RBPlacement_Parameters_verb_get) {
    RBPlacement_Parameters *arg0 ;
    int argvi = 0;
    Verbosity *result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: RBPlacement_Parameters_verb_get(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_RBPlacement_Parameters) < 0) {
        croak("Type error in argument 1 of RBPlacement_Parameters_verb_get. Expected %s", SWIGTYPE_p_RBPlacement_Parameters->name);
        XSRETURN(1);
    }
    result = (Verbosity *)& (arg0->verb);
    ST(argvi) = sv_newmortal();
    SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_Verbosity);
    XSRETURN(argvi);
}


XS(_wrap_RBPlacement_Parameters_numRowsToRemove_set) {
    RBPlacement_Parameters *arg0 ;
    unsigned int arg1 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) 
    croak("Usage: RBPlacement_Parameters_numRowsToRemove_set(self,value);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_RBPlacement_Parameters) < 0) {
        croak("Type error in argument 1 of RBPlacement_Parameters_numRowsToRemove_set. Expected %s", SWIGTYPE_p_RBPlacement_Parameters->name);
        XSRETURN(1);
    }
    arg1 = (unsigned int )SvIV(ST(1));
    arg0->numRowsToRemove = arg1;
    XSRETURN(argvi);
}


XS(_wrap_RBPlacement_Parameters_numRowsToRemove_get) {
    RBPlacement_Parameters *arg0 ;
    int argvi = 0;
    unsigned int result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: RBPlacement_Parameters_numRowsToRemove_get(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_RBPlacement_Parameters) < 0) {
        croak("Type error in argument 1 of RBPlacement_Parameters_numRowsToRemove_get. Expected %s", SWIGTYPE_p_RBPlacement_Parameters->name);
        XSRETURN(1);
    }
    result = (unsigned int ) (arg0->numRowsToRemove);
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) result);
    XSRETURN(argvi);
}


XS(_wrap_RBPlacement_Parameters_spaceCellsAlg_set) {
    RBPlacement_Parameters *arg0 ;
    int arg1 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) 
    croak("Usage: RBPlacement_Parameters_spaceCellsAlg_set(self,value);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_RBPlacement_Parameters) < 0) {
        croak("Type error in argument 1 of RBPlacement_Parameters_spaceCellsAlg_set. Expected %s", SWIGTYPE_p_RBPlacement_Parameters->name);
        XSRETURN(1);
    }
    arg1 = (int )SvIV(ST(1));
    arg0->spaceCellsAlg = (RBPlacement_Parameters::spaceCellsAlgType )arg1;
    XSRETURN(argvi);
}


XS(_wrap_RBPlacement_Parameters_spaceCellsAlg_get) {
    RBPlacement_Parameters *arg0 ;
    int argvi = 0;
    int result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: RBPlacement_Parameters_spaceCellsAlg_get(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_RBPlacement_Parameters) < 0) {
        croak("Type error in argument 1 of RBPlacement_Parameters_spaceCellsAlg_get. Expected %s", SWIGTYPE_p_RBPlacement_Parameters->name);
        XSRETURN(1);
    }
    result = (int ) (arg0->spaceCellsAlg);
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) result);
    XSRETURN(argvi);
}


XS(_wrap_RBPlacement_Parameters_remCongestion_set) {
    RBPlacement_Parameters *arg0 ;
    bool arg1 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) 
    croak("Usage: RBPlacement_Parameters_remCongestion_set(self,value);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_RBPlacement_Parameters) < 0) {
        croak("Type error in argument 1 of RBPlacement_Parameters_remCongestion_set. Expected %s", SWIGTYPE_p_RBPlacement_Parameters->name);
        XSRETURN(1);
    }
    arg1 = (bool )SvIV(ST(1));
    arg0->remCongestion = arg1;
    XSRETURN(argvi);
}


XS(_wrap_RBPlacement_Parameters_remCongestion_get) {
    RBPlacement_Parameters *arg0 ;
    int argvi = 0;
    bool result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: RBPlacement_Parameters_remCongestion_get(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_RBPlacement_Parameters) < 0) {
        croak("Type error in argument 1 of RBPlacement_Parameters_remCongestion_get. Expected %s", SWIGTYPE_p_RBPlacement_Parameters->name);
        XSRETURN(1);
    }
    result = (bool ) (arg0->remCongestion);
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) result);
    XSRETURN(argvi);
}


XS(_wrap_new_RBPlacement_Parameters) {
    int arg0 ;
    char **arg1 ;
    int n_arg ;
    int argvi = 0;
    RBPlacement_Parameters *result ;
    dXSARGS;
    
    {
        arg0=n_arg=items;
        items=1;
    }
    if ((items < 1) || (items > 1)) 
    croak("Usage: new_RBPlacement_Parameters(argv);");
    {
        arg1 = (char **)
        malloc(n_arg*sizeof(char *));
        for (; n_arg; --n_arg) {
            arg1[n_arg-1]=
            (char *)SvPV(ST(n_arg-1),PL_na);
        }
    }
    result = (RBPlacement_Parameters *)new RBPlacement_Parameters(arg0,(char const **)arg1);
    ST(argvi) = sv_newmortal();
    SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_RBPlacement_Parameters);
    XSRETURN(argvi);
}


XS(_wrap_new_CompareCellIdsByX) {
    Placement *arg0 ;
    int argvi = 0;
    CompareCellIdsByX *result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: new_CompareCellIdsByX(place);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_Placement) < 0) {
        croak("Type error in argument 1 of new_CompareCellIdsByX. Expected %s", SWIGTYPE_p_Placement->name);
        XSRETURN(1);
    }
    result = (CompareCellIdsByX *)new CompareCellIdsByX((Placement const &)*arg0);
    ST(argvi) = sv_newmortal();
    SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_CompareCellIdsByX);
    XSRETURN(argvi);
}


XS(_wrap_masterNodeInfo_nodeInfo_set) {
    masterNodeInfo *arg0 ;
    vector<double> *arg1 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) 
    croak("Usage: masterNodeInfo_nodeInfo_set(self,value);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_masterNodeInfo) < 0) {
        croak("Type error in argument 1 of masterNodeInfo_nodeInfo_set. Expected %s", SWIGTYPE_p_masterNodeInfo->name);
        XSRETURN(1);
    }
    if (SWIG_ConvertPtr(ST(1),(void **) &arg1,SWIGTYPE_p_vector_double_) < 0) {
        croak("Type error in argument 2 of masterNodeInfo_nodeInfo_set. Expected %s", SWIGTYPE_p_vector_double_->name);
        XSRETURN(1);
    }
    arg0->nodeInfo = *arg1;
    XSRETURN(argvi);
}


XS(_wrap_masterNodeInfo_nodeInfo_get) {
    masterNodeInfo *arg0 ;
    int argvi = 0;
    vector<double> *result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: masterNodeInfo_nodeInfo_get(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_masterNodeInfo) < 0) {
        croak("Type error in argument 1 of masterNodeInfo_nodeInfo_get. Expected %s", SWIGTYPE_p_masterNodeInfo->name);
        XSRETURN(1);
    }
    result = (vector<double> *)& (arg0->nodeInfo);
    ST(argvi) = sv_newmortal();
    SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_vector_double_);
    XSRETURN(argvi);
}


XS(_wrap_masterNodeInfo_name_get) {
    masterNodeInfo *arg0 ;
    int argvi = 0;
    char *result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: masterNodeInfo_name_get(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_masterNodeInfo) < 0) {
        croak("Type error in argument 1 of masterNodeInfo_name_get. Expected %s", SWIGTYPE_p_masterNodeInfo->name);
        XSRETURN(1);
    }
    result = (char *)(char *) (arg0->name);
    ST(argvi) = sv_newmortal();
    sv_setpv((SV*)ST(argvi++),(char *) result);
    XSRETURN(argvi);
}


XS(_wrap_masterNodeInfo_index_set) {
    masterNodeInfo *arg0 ;
    unsigned int arg1 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) 
    croak("Usage: masterNodeInfo_index_set(self,value);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_masterNodeInfo) < 0) {
        croak("Type error in argument 1 of masterNodeInfo_index_set. Expected %s", SWIGTYPE_p_masterNodeInfo->name);
        XSRETURN(1);
    }
    arg1 = (unsigned int )SvIV(ST(1));
    arg0->index = arg1;
    XSRETURN(argvi);
}


XS(_wrap_masterNodeInfo_index_get) {
    masterNodeInfo *arg0 ;
    int argvi = 0;
    unsigned int result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: masterNodeInfo_index_get(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_masterNodeInfo) < 0) {
        croak("Type error in argument 1 of masterNodeInfo_index_get. Expected %s", SWIGTYPE_p_masterNodeInfo->name);
        XSRETURN(1);
    }
    result = (unsigned int ) (arg0->index);
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) result);
    XSRETURN(argvi);
}


XS(_wrap_masterNodeInfo_pinNames_set) {
    masterNodeInfo *arg0 ;
    vector<char *> *arg1 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) 
    croak("Usage: masterNodeInfo_pinNames_set(self,value);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_masterNodeInfo) < 0) {
        croak("Type error in argument 1 of masterNodeInfo_pinNames_set. Expected %s", SWIGTYPE_p_masterNodeInfo->name);
        XSRETURN(1);
    }
    if (SWIG_ConvertPtr(ST(1),(void **) &arg1,SWIGTYPE_p_vector_char___) < 0) {
        croak("Type error in argument 2 of masterNodeInfo_pinNames_set. Expected %s", SWIGTYPE_p_vector_char___->name);
        XSRETURN(1);
    }
    arg0->pinNames = *arg1;
    XSRETURN(argvi);
}


XS(_wrap_masterNodeInfo_pinNames_get) {
    masterNodeInfo *arg0 ;
    int argvi = 0;
    vector<char *> *result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: masterNodeInfo_pinNames_get(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_masterNodeInfo) < 0) {
        croak("Type error in argument 1 of masterNodeInfo_pinNames_get. Expected %s", SWIGTYPE_p_masterNodeInfo->name);
        XSRETURN(1);
    }
    result = (vector<char *> *)& (arg0->pinNames);
    ST(argvi) = sv_newmortal();
    SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_vector_char___);
    XSRETURN(argvi);
}


XS(_wrap_masterNodeInfo_pinOffsets_set) {
    masterNodeInfo *arg0 ;
    vector<Point> *arg1 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) 
    croak("Usage: masterNodeInfo_pinOffsets_set(self,value);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_masterNodeInfo) < 0) {
        croak("Type error in argument 1 of masterNodeInfo_pinOffsets_set. Expected %s", SWIGTYPE_p_masterNodeInfo->name);
        XSRETURN(1);
    }
    if (SWIG_ConvertPtr(ST(1),(void **) &arg1,SWIGTYPE_p_vector_Point_) < 0) {
        croak("Type error in argument 2 of masterNodeInfo_pinOffsets_set. Expected %s", SWIGTYPE_p_vector_Point_->name);
        XSRETURN(1);
    }
    arg0->pinOffsets = *arg1;
    XSRETURN(argvi);
}


XS(_wrap_masterNodeInfo_pinOffsets_get) {
    masterNodeInfo *arg0 ;
    int argvi = 0;
    vector<Point> *result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: masterNodeInfo_pinOffsets_get(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_masterNodeInfo) < 0) {
        croak("Type error in argument 1 of masterNodeInfo_pinOffsets_get. Expected %s", SWIGTYPE_p_masterNodeInfo->name);
        XSRETURN(1);
    }
    result = (vector<Point> *)& (arg0->pinOffsets);
    ST(argvi) = sv_newmortal();
    SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_vector_Point_);
    XSRETURN(argvi);
}


XS(_wrap_nodesMasInfo_masterNodeIndex_set) {
    nodesMasInfo *arg0 ;
    vector<unsigned> *arg1 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) 
    croak("Usage: nodesMasInfo_masterNodeIndex_set(self,value);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_nodesMasInfo) < 0) {
        croak("Type error in argument 1 of nodesMasInfo_masterNodeIndex_set. Expected %s", SWIGTYPE_p_nodesMasInfo->name);
        XSRETURN(1);
    }
    if (SWIG_ConvertPtr(ST(1),(void **) &arg1,SWIGTYPE_p_vector_unsigned_) < 0) {
        croak("Type error in argument 2 of nodesMasInfo_masterNodeIndex_set. Expected %s", SWIGTYPE_p_vector_unsigned_->name);
        XSRETURN(1);
    }
    arg0->masterNodeIndex = *arg1;
    XSRETURN(argvi);
}


XS(_wrap_nodesMasInfo_masterNodeIndex_get) {
    nodesMasInfo *arg0 ;
    int argvi = 0;
    vector<unsigned> *result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: nodesMasInfo_masterNodeIndex_get(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_nodesMasInfo) < 0) {
        croak("Type error in argument 1 of nodesMasInfo_masterNodeIndex_get. Expected %s", SWIGTYPE_p_nodesMasInfo->name);
        XSRETURN(1);
    }
    result = (vector<unsigned> *)& (arg0->masterNodeIndex);
    ST(argvi) = sv_newmortal();
    SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_vector_unsigned_);
    XSRETURN(argvi);
}


XS(_wrap_new_nodesMasInfo) {
    unsigned int arg0 ;
    int argvi = 0;
    nodesMasInfo *result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: new_nodesMasInfo(numCells);");
    arg0 = (unsigned int )SvIV(ST(0));
    result = (nodesMasInfo *)new nodesMasInfo(arg0);
    ST(argvi) = sv_newmortal();
    SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_nodesMasInfo);
    XSRETURN(argvi);
}


XS(_wrap_nodesMasInfo_putIndex) {
    nodesMasInfo *arg0 ;
    unsigned int arg1 ;
    unsigned int arg2 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 3) || (items > 3)) 
    croak("Usage: nodesMasInfo_putIndex(self,masIndex,index);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_nodesMasInfo) < 0) {
        croak("Type error in argument 1 of nodesMasInfo_putIndex. Expected %s", SWIGTYPE_p_nodesMasInfo->name);
        XSRETURN(1);
    }
    arg1 = (unsigned int )SvIV(ST(1));
    arg2 = (unsigned int )SvIV(ST(2));
    arg0->putIndex(arg1,arg2);
    XSRETURN(argvi);
}


XS(_wrap_nodesMasInfo_getMasterIndex) {
    nodesMasInfo *arg0 ;
    unsigned int arg1 ;
    int argvi = 0;
    unsigned int result ;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) 
    croak("Usage: nodesMasInfo_getMasterIndex(self,index);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_nodesMasInfo) < 0) {
        croak("Type error in argument 1 of nodesMasInfo_getMasterIndex. Expected %s", SWIGTYPE_p_nodesMasInfo->name);
        XSRETURN(1);
    }
    arg1 = (unsigned int )SvIV(ST(1));
    result = (unsigned int )arg0->getMasterIndex(arg1);
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) result);
    XSRETURN(argvi);
}


XS(_wrap_new_CapoPlacer) {
    RBPlacement *arg0 ;
    CapoParameters *arg1 ;
    int argvi = 0;
    CapoPlacer *result ;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) 
    croak("Usage: new_CapoPlacer(rbplace,params);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_RBPlacement) < 0) {
        croak("Type error in argument 1 of new_CapoPlacer. Expected %s", SWIGTYPE_p_RBPlacement->name);
        XSRETURN(1);
    }
    if (SWIG_ConvertPtr(ST(1),(void **) &arg1,SWIGTYPE_p_CapoParameters) < 0) {
        croak("Type error in argument 2 of new_CapoPlacer. Expected %s", SWIGTYPE_p_CapoParameters->name);
        XSRETURN(1);
    }
    result = (CapoPlacer *)new CapoPlacer(*arg0,(CapoParameters const &)*arg1);
    ST(argvi) = sv_newmortal();
    SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_CapoPlacer);
    XSRETURN(argvi);
}


XS(_wrap_delete_CapoPlacer) {
    CapoPlacer *arg0 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: delete_CapoPlacer(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_CapoPlacer) < 0) {
        croak("Type error in argument 1 of delete_CapoPlacer. Expected %s", SWIGTYPE_p_CapoPlacer->name);
        XSRETURN(1);
    }
    delete arg0;
    XSRETURN(argvi);
}


XS(_wrap_CapoPlacer_estimateWL) {
    CapoPlacer *arg0 ;
    int argvi = 0;
    double result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: CapoPlacer_estimateWL(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_CapoPlacer) < 0) {
        croak("Type error in argument 1 of CapoPlacer_estimateWL. Expected %s", SWIGTYPE_p_CapoPlacer->name);
        XSRETURN(1);
    }
    result = (double )arg0->estimateWL();
    ST(argvi) = sv_newmortal();
    sv_setnv(ST(argvi++), (double) result);
    XSRETURN(argvi);
}


XS(_wrap_CapoPlacer_getBBoxPerLayer) {
    CapoPlacer *arg0 ;
    int argvi = 0;
    vector<double> *result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: CapoPlacer_getBBoxPerLayer(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_CapoPlacer) < 0) {
        croak("Type error in argument 1 of CapoPlacer_getBBoxPerLayer. Expected %s", SWIGTYPE_p_CapoPlacer->name);
        XSRETURN(1);
    }
    vector<double> const &_result_ref = arg0->getBBoxPerLayer();
    result = (vector<double> *) &_result_ref;
    ST(argvi) = sv_newmortal();
    SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_vector_double_);
    XSRETURN(argvi);
}


XS(_wrap_CapoPlacer_getCutPerLayer) {
    CapoPlacer *arg0 ;
    int argvi = 0;
    vector<unsigned> *result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: CapoPlacer_getCutPerLayer(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_CapoPlacer) < 0) {
        croak("Type error in argument 1 of CapoPlacer_getCutPerLayer. Expected %s", SWIGTYPE_p_CapoPlacer->name);
        XSRETURN(1);
    }
    vector<unsigned> const &_result_ref = arg0->getCutPerLayer();
    result = (vector<unsigned> *) &_result_ref;
    ST(argvi) = sv_newmortal();
    SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_vector_unsigned_);
    XSRETURN(argvi);
}


XS(_wrap_CapoPlacer_getNodesInEachBlock) {
    CapoPlacer *arg0 ;
    int argvi = 0;
    vector<unsigned> *result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: CapoPlacer_getNodesInEachBlock(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_CapoPlacer) < 0) {
        croak("Type error in argument 1 of CapoPlacer_getNodesInEachBlock. Expected %s", SWIGTYPE_p_CapoPlacer->name);
        XSRETURN(1);
    }
    vector<unsigned> const &_result_ref = arg0->getNodesInEachBlock();
    result = (vector<unsigned> *) &_result_ref;
    ST(argvi) = sv_newmortal();
    SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_vector_unsigned_);
    XSRETURN(argvi);
}


XS(_wrap_CapoPlacer_getTerminalsToEachBlock) {
    CapoPlacer *arg0 ;
    int argvi = 0;
    vector<unsigned> *result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: CapoPlacer_getTerminalsToEachBlock(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_CapoPlacer) < 0) {
        croak("Type error in argument 1 of CapoPlacer_getTerminalsToEachBlock. Expected %s", SWIGTYPE_p_CapoPlacer->name);
        XSRETURN(1);
    }
    vector<unsigned> const &_result_ref = arg0->getTerminalsToEachBlock();
    result = (vector<unsigned> *) &_result_ref;
    ST(argvi) = sv_newmortal();
    SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_vector_unsigned_);
    XSRETURN(argvi);
}


XS(_wrap_CapoPlacer_getCellToBlockMap) {
    CapoPlacer *arg0 ;
    int argvi = 0;
    vector<const CapoBlock*> *result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: CapoPlacer_getCellToBlockMap(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_CapoPlacer) < 0) {
        croak("Type error in argument 1 of CapoPlacer_getCellToBlockMap. Expected %s", SWIGTYPE_p_CapoPlacer->name);
        XSRETURN(1);
    }
    vector<const CapoBlock*> const &_result_ref = arg0->getCellToBlockMap();
    result = (vector<const CapoBlock*> *) &_result_ref;
    ST(argvi) = sv_newmortal();
    SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_vector_const_CapoBlock__);
    XSRETURN(argvi);
}


XS(_wrap_CapoPlacer_getPinLocation) {
    CapoPlacer *arg0 ;
    unsigned int arg1 ;
    unsigned int arg2 ;
    int argvi = 0;
    Point *result ;
    dXSARGS;
    
    if ((items < 3) || (items > 3)) 
    croak("Usage: CapoPlacer_getPinLocation(self,cellId,netId);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_CapoPlacer) < 0) {
        croak("Type error in argument 1 of CapoPlacer_getPinLocation. Expected %s", SWIGTYPE_p_CapoPlacer->name);
        XSRETURN(1);
    }
    arg1 = (unsigned int )SvIV(ST(1));
    arg2 = (unsigned int )SvIV(ST(2));
    result = new Point (arg0->getPinLocation(arg1,arg2));    ST(argvi) = sv_newmortal();
    SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_Point);
    XSRETURN(argvi);
}


XS(_wrap_CapoPlacer_getNetlistHGraph) {
    CapoPlacer *arg0 ;
    int argvi = 0;
    HGraphWDimensions *result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: CapoPlacer_getNetlistHGraph(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_CapoPlacer) < 0) {
        croak("Type error in argument 1 of CapoPlacer_getNetlistHGraph. Expected %s", SWIGTYPE_p_CapoPlacer->name);
        XSRETURN(1);
    }
    HGraphWDimensions const &_result_ref = arg0->getNetlistHGraph();
    result = (HGraphWDimensions *) &_result_ref;
    ST(argvi) = sv_newmortal();
    SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_HGraphWDimensions);
    XSRETURN(argvi);
}


XS(_wrap_CapoPlacer_getParams) {
    CapoPlacer *arg0 ;
    int argvi = 0;
    CapoParameters *result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: CapoPlacer_getParams(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_CapoPlacer) < 0) {
        croak("Type error in argument 1 of CapoPlacer_getParams. Expected %s", SWIGTYPE_p_CapoPlacer->name);
        XSRETURN(1);
    }
    CapoParameters const &_result_ref = arg0->getParams();
    result = (CapoParameters *) &_result_ref;
    ST(argvi) = sv_newmortal();
    SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_CapoParameters);
    XSRETURN(argvi);
}


XS(_wrap_CapoPlacer_getPlacement) {
    CapoPlacer *arg0 ;
    int argvi = 0;
    PlacementWOrient *result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: CapoPlacer_getPlacement(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_CapoPlacer) < 0) {
        croak("Type error in argument 1 of CapoPlacer_getPlacement. Expected %s", SWIGTYPE_p_CapoPlacer->name);
        XSRETURN(1);
    }
    PlacementWOrient const &_result_ref = arg0->getPlacement();
    result = (PlacementWOrient *) &_result_ref;
    ST(argvi) = sv_newmortal();
    SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_PlacementWOrient);
    XSRETURN(argvi);
}


XS(_wrap_CapoPlacer_printCutDensityStats) {
    CapoPlacer *arg0 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: CapoPlacer_printCutDensityStats(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_CapoPlacer) < 0) {
        croak("Type error in argument 1 of CapoPlacer_printCutDensityStats. Expected %s", SWIGTYPE_p_CapoPlacer->name);
        XSRETURN(1);
    }
    arg0->printCutDensityStats();
    XSRETURN(argvi);
}


XS(_wrap_CapoPlacer_printSmallProblemStats) {
    CapoPlacer *arg0 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: CapoPlacer_printSmallProblemStats(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_CapoPlacer) < 0) {
        croak("Type error in argument 1 of CapoPlacer_printSmallProblemStats. Expected %s", SWIGTYPE_p_CapoPlacer->name);
        XSRETURN(1);
    }
    arg0->printSmallProblemStats();
    XSRETURN(argvi);
}


XS(_wrap_CapoPlacer_printNetlistStats) {
    CapoPlacer *arg0 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: CapoPlacer_printNetlistStats(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_CapoPlacer) < 0) {
        croak("Type error in argument 1 of CapoPlacer_printNetlistStats. Expected %s", SWIGTYPE_p_CapoPlacer->name);
        XSRETURN(1);
    }
    arg0->printNetlistStats();
    XSRETURN(argvi);
}


XS(_wrap_CapoPlacer_getNetCutInfo) {
    CapoPlacer *arg0 ;
    vector<unsigned> *arg1 ;
    vector<unsigned> *arg2 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 3) || (items > 3)) 
    croak("Usage: CapoPlacer_getNetCutInfo(self,externalCutNets,containedNets);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_CapoPlacer) < 0) {
        croak("Type error in argument 1 of CapoPlacer_getNetCutInfo. Expected %s", SWIGTYPE_p_CapoPlacer->name);
        XSRETURN(1);
    }
    if (SWIG_ConvertPtr(ST(1),(void **) &arg1,SWIGTYPE_p_vector_unsigned_) < 0) {
        croak("Type error in argument 2 of CapoPlacer_getNetCutInfo. Expected %s", SWIGTYPE_p_vector_unsigned_->name);
        XSRETURN(1);
    }
    if (SWIG_ConvertPtr(ST(2),(void **) &arg2,SWIGTYPE_p_vector_unsigned_) < 0) {
        croak("Type error in argument 3 of CapoPlacer_getNetCutInfo. Expected %s", SWIGTYPE_p_vector_unsigned_->name);
        XSRETURN(1);
    }
    arg0->getNetCutInfo(*arg1,*arg2);
    XSRETURN(argvi);
}


XS(_wrap_CapoPlacer_getTotalNetCut) {
    CapoPlacer *arg0 ;
    int argvi = 0;
    unsigned int result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: CapoPlacer_getTotalNetCut(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_CapoPlacer) < 0) {
        croak("Type error in argument 1 of CapoPlacer_getTotalNetCut. Expected %s", SWIGTYPE_p_CapoPlacer->name);
        XSRETURN(1);
    }
    result = (unsigned int )arg0->getTotalNetCut();
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) result);
    XSRETURN(argvi);
}


XS(_wrap_CapoPlacer_getBlockMembership) {
    CapoPlacer *arg0 ;
    vector<int> *arg1 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) 
    croak("Usage: CapoPlacer_getBlockMembership(self,nodeBlock);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_CapoPlacer) < 0) {
        croak("Type error in argument 1 of CapoPlacer_getBlockMembership. Expected %s", SWIGTYPE_p_CapoPlacer->name);
        XSRETURN(1);
    }
    if (SWIG_ConvertPtr(ST(1),(void **) &arg1,SWIGTYPE_p_vector_int_) < 0) {
        croak("Type error in argument 2 of CapoPlacer_getBlockMembership. Expected %s", SWIGTYPE_p_vector_int_->name);
        XSRETURN(1);
    }
    arg0->getBlockMembership(*arg1);
    XSRETURN(argvi);
}


XS(_wrap_CapoPlacer_printBlockMembership) {
    CapoPlacer *arg0 ;
    char *arg1 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) 
    croak("Usage: CapoPlacer_printBlockMembership(self,fileName);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_CapoPlacer) < 0) {
        croak("Type error in argument 1 of CapoPlacer_printBlockMembership. Expected %s", SWIGTYPE_p_CapoPlacer->name);
        XSRETURN(1);
    }
    if (! SvOK((SV*) ST(1))) {
        arg1 = 0; 
    }
    else {
        arg1 = (char *) SvPV(ST(1),PL_na); 
    }
    arg0->printBlockMembership((char const *)arg1);
    XSRETURN(argvi);
}


XS(_wrap_CapoPlacer_getHierCellNames) {
    CapoPlacer *arg0 ;
    vector<const char*> *arg1 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) 
    croak("Usage: CapoPlacer_getHierCellNames(self,cellNames);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_CapoPlacer) < 0) {
        croak("Type error in argument 1 of CapoPlacer_getHierCellNames. Expected %s", SWIGTYPE_p_CapoPlacer->name);
        XSRETURN(1);
    }
    if (SWIG_ConvertPtr(ST(1),(void **) &arg1,SWIGTYPE_p_vector_const_char__) < 0) {
        croak("Type error in argument 2 of CapoPlacer_getHierCellNames. Expected %s", SWIGTYPE_p_vector_const_char__->name);
        XSRETURN(1);
    }
    arg0->getHierCellNames(*arg1);
    XSRETURN(argvi);
}


XS(_wrap_CapoPlacer_printHierCellNames) {
    CapoPlacer *arg0 ;
    char *arg1 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) 
    croak("Usage: CapoPlacer_printHierCellNames(self,fileName);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_CapoPlacer) < 0) {
        croak("Type error in argument 1 of CapoPlacer_printHierCellNames. Expected %s", SWIGTYPE_p_CapoPlacer->name);
        XSRETURN(1);
    }
    if (! SvOK((SV*) ST(1))) {
        arg1 = 0; 
    }
    else {
        arg1 = (char *) SvPV(ST(1),PL_na); 
    }
    arg0->printHierCellNames((char const *)arg1);
    XSRETURN(argvi);
}


XS(_wrap_CapoPlacer_saveSmallProblem) {
    CapoPlacer *arg0 ;
    PartitioningProblemForCapo *arg1 ;
    CapoBlock *arg2 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 3) || (items > 3)) 
    croak("Usage: CapoPlacer_saveSmallProblem(self,problem,block);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_CapoPlacer) < 0) {
        croak("Type error in argument 1 of CapoPlacer_saveSmallProblem. Expected %s", SWIGTYPE_p_CapoPlacer->name);
        XSRETURN(1);
    }
    if (SWIG_ConvertPtr(ST(1),(void **) &arg1,SWIGTYPE_p_PartitioningProblemForCapo) < 0) {
        croak("Type error in argument 2 of CapoPlacer_saveSmallProblem. Expected %s", SWIGTYPE_p_PartitioningProblemForCapo->name);
        XSRETURN(1);
    }
    if (SWIG_ConvertPtr(ST(2),(void **) &arg2,SWIGTYPE_p_CapoBlock) < 0) {
        croak("Type error in argument 3 of CapoPlacer_saveSmallProblem. Expected %s", SWIGTYPE_p_CapoBlock->name);
        XSRETURN(1);
    }
    arg0->saveSmallProblem((PartitioningProblemForCapo const &)*arg1,(CapoBlock const &)*arg2);
    XSRETURN(argvi);
}


XS(_wrap_CapoSplitterParams_doRepartitioning_set) {
    CapoSplitterParams *arg0 ;
    bool arg1 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) 
    croak("Usage: CapoSplitterParams_doRepartitioning_set(self,value);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_CapoSplitterParams) < 0) {
        croak("Type error in argument 1 of CapoSplitterParams_doRepartitioning_set. Expected %s", SWIGTYPE_p_CapoSplitterParams->name);
        XSRETURN(1);
    }
    arg1 = (bool )SvIV(ST(1));
    arg0->doRepartitioning = arg1;
    XSRETURN(argvi);
}


XS(_wrap_CapoSplitterParams_doRepartitioning_get) {
    CapoSplitterParams *arg0 ;
    int argvi = 0;
    bool result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: CapoSplitterParams_doRepartitioning_get(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_CapoSplitterParams) < 0) {
        croak("Type error in argument 1 of CapoSplitterParams_doRepartitioning_get. Expected %s", SWIGTYPE_p_CapoSplitterParams->name);
        XSRETURN(1);
    }
    result = (bool ) (arg0->doRepartitioning);
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) result);
    XSRETURN(argvi);
}


XS(_wrap_CapoSplitterParams_useWSTolMethod_set) {
    CapoSplitterParams *arg0 ;
    bool arg1 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) 
    croak("Usage: CapoSplitterParams_useWSTolMethod_set(self,value);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_CapoSplitterParams) < 0) {
        croak("Type error in argument 1 of CapoSplitterParams_useWSTolMethod_set. Expected %s", SWIGTYPE_p_CapoSplitterParams->name);
        XSRETURN(1);
    }
    arg1 = (bool )SvIV(ST(1));
    arg0->useWSTolMethod = arg1;
    XSRETURN(argvi);
}


XS(_wrap_CapoSplitterParams_useWSTolMethod_get) {
    CapoSplitterParams *arg0 ;
    int argvi = 0;
    bool result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: CapoSplitterParams_useWSTolMethod_get(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_CapoSplitterParams) < 0) {
        croak("Type error in argument 1 of CapoSplitterParams_useWSTolMethod_get. Expected %s", SWIGTYPE_p_CapoSplitterParams->name);
        XSRETURN(1);
    }
    result = (bool ) (arg0->useWSTolMethod);
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) result);
    XSRETURN(argvi);
}


XS(_wrap_CapoSplitterParams_constantTolerance_set) {
    CapoSplitterParams *arg0 ;
    double arg1 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) 
    croak("Usage: CapoSplitterParams_constantTolerance_set(self,value);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_CapoSplitterParams) < 0) {
        croak("Type error in argument 1 of CapoSplitterParams_constantTolerance_set. Expected %s", SWIGTYPE_p_CapoSplitterParams->name);
        XSRETURN(1);
    }
    arg1 = (double )SvNV(ST(1));
    arg0->constantTolerance = arg1;
    XSRETURN(argvi);
}


XS(_wrap_CapoSplitterParams_constantTolerance_get) {
    CapoSplitterParams *arg0 ;
    int argvi = 0;
    double result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: CapoSplitterParams_constantTolerance_get(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_CapoSplitterParams) < 0) {
        croak("Type error in argument 1 of CapoSplitterParams_constantTolerance_get. Expected %s", SWIGTYPE_p_CapoSplitterParams->name);
        XSRETURN(1);
    }
    result = (double ) (arg0->constantTolerance);
    ST(argvi) = sv_newmortal();
    sv_setnv(ST(argvi++), (double) result);
    XSRETURN(argvi);
}


XS(_wrap_CapoSplitterParams_numMLSets_set) {
    CapoSplitterParams *arg0 ;
    unsigned int arg1 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) 
    croak("Usage: CapoSplitterParams_numMLSets_set(self,value);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_CapoSplitterParams) < 0) {
        croak("Type error in argument 1 of CapoSplitterParams_numMLSets_set. Expected %s", SWIGTYPE_p_CapoSplitterParams->name);
        XSRETURN(1);
    }
    arg1 = (unsigned int )SvIV(ST(1));
    arg0->numMLSets = arg1;
    XSRETURN(argvi);
}


XS(_wrap_CapoSplitterParams_numMLSets_get) {
    CapoSplitterParams *arg0 ;
    int argvi = 0;
    unsigned int result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: CapoSplitterParams_numMLSets_get(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_CapoSplitterParams) < 0) {
        croak("Type error in argument 1 of CapoSplitterParams_numMLSets_get. Expected %s", SWIGTYPE_p_CapoSplitterParams->name);
        XSRETURN(1);
    }
    result = (unsigned int ) (arg0->numMLSets);
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) result);
    XSRETURN(argvi);
}


XS(_wrap_CapoSplitterParams_useNameHierarchy_set) {
    CapoSplitterParams *arg0 ;
    bool arg1 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) 
    croak("Usage: CapoSplitterParams_useNameHierarchy_set(self,value);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_CapoSplitterParams) < 0) {
        croak("Type error in argument 1 of CapoSplitterParams_useNameHierarchy_set. Expected %s", SWIGTYPE_p_CapoSplitterParams->name);
        XSRETURN(1);
    }
    arg1 = (bool )SvIV(ST(1));
    arg0->useNameHierarchy = arg1;
    XSRETURN(argvi);
}


XS(_wrap_CapoSplitterParams_useNameHierarchy_get) {
    CapoSplitterParams *arg0 ;
    int argvi = 0;
    bool result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: CapoSplitterParams_useNameHierarchy_get(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_CapoSplitterParams) < 0) {
        croak("Type error in argument 1 of CapoSplitterParams_useNameHierarchy_get. Expected %s", SWIGTYPE_p_CapoSplitterParams->name);
        XSRETURN(1);
    }
    result = (bool ) (arg0->useNameHierarchy);
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) result);
    XSRETURN(argvi);
}


XS(_wrap_CapoSplitterParams_delimiters_set) {
    CapoSplitterParams *arg0 ;
    char *arg1 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) 
    croak("Usage: CapoSplitterParams_delimiters_set(self,value);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_CapoSplitterParams) < 0) {
        croak("Type error in argument 1 of CapoSplitterParams_delimiters_set. Expected %s", SWIGTYPE_p_CapoSplitterParams->name);
        XSRETURN(1);
    }
    if (! SvOK((SV*) ST(1))) {
        arg1 = 0; 
    }
    else {
        arg1 = (char *) SvPV(ST(1),PL_na); 
    }
    arg0->delimiters = arg1;
    XSRETURN(argvi);
}


XS(_wrap_CapoSplitterParams_delimiters_get) {
    CapoSplitterParams *arg0 ;
    int argvi = 0;
    char *result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: CapoSplitterParams_delimiters_get(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_CapoSplitterParams) < 0) {
        croak("Type error in argument 1 of CapoSplitterParams_delimiters_get. Expected %s", SWIGTYPE_p_CapoSplitterParams->name);
        XSRETURN(1);
    }
    result = (char *) (arg0->delimiters);
    ST(argvi) = sv_newmortal();
    sv_setpv((SV*)ST(argvi++),(char *) result);
    XSRETURN(argvi);
}


XS(_wrap_CapoSplitterParams_verb_set) {
    CapoSplitterParams *arg0 ;
    Verbosity *arg1 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) 
    croak("Usage: CapoSplitterParams_verb_set(self,value);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_CapoSplitterParams) < 0) {
        croak("Type error in argument 1 of CapoSplitterParams_verb_set. Expected %s", SWIGTYPE_p_CapoSplitterParams->name);
        XSRETURN(1);
    }
    if (SWIG_ConvertPtr(ST(1),(void **) &arg1,SWIGTYPE_p_Verbosity) < 0) {
        croak("Type error in argument 2 of CapoSplitterParams_verb_set. Expected %s", SWIGTYPE_p_Verbosity->name);
        XSRETURN(1);
    }
    arg0->verb = *arg1;
    XSRETURN(argvi);
}


XS(_wrap_CapoSplitterParams_verb_get) {
    CapoSplitterParams *arg0 ;
    int argvi = 0;
    Verbosity *result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: CapoSplitterParams_verb_get(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_CapoSplitterParams) < 0) {
        croak("Type error in argument 1 of CapoSplitterParams_verb_get. Expected %s", SWIGTYPE_p_CapoSplitterParams->name);
        XSRETURN(1);
    }
    result = (Verbosity *)& (arg0->verb);
    ST(argvi) = sv_newmortal();
    SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_Verbosity);
    XSRETURN(argvi);
}


XS(_wrap_new_CapoSplitterParams) {
    int arg0 ;
    char **arg1 ;
    int n_arg ;
    int argvi = 0;
    CapoSplitterParams *result ;
    dXSARGS;
    
    {
        arg0=n_arg=items;
        items=1;
    }
    if ((items < 1) || (items > 1)) 
    croak("Usage: new_CapoSplitterParams(argv);");
    {
        arg1 = (char **)
        malloc(n_arg*sizeof(char *));
        for (; n_arg; --n_arg) {
            arg1[n_arg-1]=
            (char *)SvPV(ST(n_arg-1),PL_na);
        }
    }
    result = (CapoSplitterParams *)new CapoSplitterParams(arg0,(char const **)arg1);
    ST(argvi) = sv_newmortal();
    SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_CapoSplitterParams);
    XSRETURN(argvi);
}


XS(_wrap_CapoParameters_verb_set) {
    CapoParameters *arg0 ;
    Verbosity *arg1 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) 
    croak("Usage: CapoParameters_verb_set(self,value);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_CapoParameters) < 0) {
        croak("Type error in argument 1 of CapoParameters_verb_set. Expected %s", SWIGTYPE_p_CapoParameters->name);
        XSRETURN(1);
    }
    if (SWIG_ConvertPtr(ST(1),(void **) &arg1,SWIGTYPE_p_Verbosity) < 0) {
        croak("Type error in argument 2 of CapoParameters_verb_set. Expected %s", SWIGTYPE_p_Verbosity->name);
        XSRETURN(1);
    }
    arg0->verb = *arg1;
    XSRETURN(argvi);
}


XS(_wrap_CapoParameters_verb_get) {
    CapoParameters *arg0 ;
    int argvi = 0;
    Verbosity *result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: CapoParameters_verb_get(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_CapoParameters) < 0) {
        croak("Type error in argument 1 of CapoParameters_verb_get. Expected %s", SWIGTYPE_p_CapoParameters->name);
        XSRETURN(1);
    }
    result = (Verbosity *)& (arg0->verb);
    ST(argvi) = sv_newmortal();
    SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_Verbosity);
    XSRETURN(argvi);
}


XS(_wrap_CapoParameters_stopAtBlocks_set) {
    CapoParameters *arg0 ;
    unsigned int arg1 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) 
    croak("Usage: CapoParameters_stopAtBlocks_set(self,value);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_CapoParameters) < 0) {
        croak("Type error in argument 1 of CapoParameters_stopAtBlocks_set. Expected %s", SWIGTYPE_p_CapoParameters->name);
        XSRETURN(1);
    }
    arg1 = (unsigned int )SvIV(ST(1));
    arg0->stopAtBlocks = arg1;
    XSRETURN(argvi);
}


XS(_wrap_CapoParameters_stopAtBlocks_get) {
    CapoParameters *arg0 ;
    int argvi = 0;
    unsigned int result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: CapoParameters_stopAtBlocks_get(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_CapoParameters) < 0) {
        croak("Type error in argument 1 of CapoParameters_stopAtBlocks_get. Expected %s", SWIGTYPE_p_CapoParameters->name);
        XSRETURN(1);
    }
    result = (unsigned int ) (arg0->stopAtBlocks);
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) result);
    XSRETURN(argvi);
}


XS(_wrap_CapoParameters_replaceSmallBlocks_set) {
    CapoParameters *arg0 ;
    int arg1 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) 
    croak("Usage: CapoParameters_replaceSmallBlocks_set(self,value);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_CapoParameters) < 0) {
        croak("Type error in argument 1 of CapoParameters_replaceSmallBlocks_set. Expected %s", SWIGTYPE_p_CapoParameters->name);
        XSRETURN(1);
    }
    arg1 = (int )SvIV(ST(1));
    arg0->replaceSmallBlocks = (ReplaceSmallBlocksType )arg1;
    XSRETURN(argvi);
}


XS(_wrap_CapoParameters_replaceSmallBlocks_get) {
    CapoParameters *arg0 ;
    int argvi = 0;
    int result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: CapoParameters_replaceSmallBlocks_get(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_CapoParameters) < 0) {
        croak("Type error in argument 1 of CapoParameters_replaceSmallBlocks_get. Expected %s", SWIGTYPE_p_CapoParameters->name);
        XSRETURN(1);
    }
    result = (int ) (arg0->replaceSmallBlocks);
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) result);
    XSRETURN(argvi);
}


XS(_wrap_CapoParameters_useActualPinLocs_set) {
    CapoParameters *arg0 ;
    bool arg1 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) 
    croak("Usage: CapoParameters_useActualPinLocs_set(self,value);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_CapoParameters) < 0) {
        croak("Type error in argument 1 of CapoParameters_useActualPinLocs_set. Expected %s", SWIGTYPE_p_CapoParameters->name);
        XSRETURN(1);
    }
    arg1 = (bool )SvIV(ST(1));
    arg0->useActualPinLocs = arg1;
    XSRETURN(argvi);
}


XS(_wrap_CapoParameters_useActualPinLocs_get) {
    CapoParameters *arg0 ;
    int argvi = 0;
    bool result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: CapoParameters_useActualPinLocs_get(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_CapoParameters) < 0) {
        croak("Type error in argument 1 of CapoParameters_useActualPinLocs_get. Expected %s", SWIGTYPE_p_CapoParameters->name);
        XSRETURN(1);
    }
    result = (bool ) (arg0->useActualPinLocs);
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) result);
    XSRETURN(argvi);
}


XS(_wrap_CapoParameters_smallPartThreshold_set) {
    CapoParameters *arg0 ;
    unsigned int arg1 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) 
    croak("Usage: CapoParameters_smallPartThreshold_set(self,value);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_CapoParameters) < 0) {
        croak("Type error in argument 1 of CapoParameters_smallPartThreshold_set. Expected %s", SWIGTYPE_p_CapoParameters->name);
        XSRETURN(1);
    }
    arg1 = (unsigned int )SvIV(ST(1));
    arg0->smallPartThreshold = arg1;
    XSRETURN(argvi);
}


XS(_wrap_CapoParameters_smallPartThreshold_get) {
    CapoParameters *arg0 ;
    int argvi = 0;
    unsigned int result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: CapoParameters_smallPartThreshold_get(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_CapoParameters) < 0) {
        croak("Type error in argument 1 of CapoParameters_smallPartThreshold_get. Expected %s", SWIGTYPE_p_CapoParameters->name);
        XSRETURN(1);
    }
    result = (unsigned int ) (arg0->smallPartThreshold);
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) result);
    XSRETURN(argvi);
}


XS(_wrap_CapoParameters_smallPlaceThreshold_set) {
    CapoParameters *arg0 ;
    unsigned int arg1 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) 
    croak("Usage: CapoParameters_smallPlaceThreshold_set(self,value);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_CapoParameters) < 0) {
        croak("Type error in argument 1 of CapoParameters_smallPlaceThreshold_set. Expected %s", SWIGTYPE_p_CapoParameters->name);
        XSRETURN(1);
    }
    arg1 = (unsigned int )SvIV(ST(1));
    arg0->smallPlaceThreshold = arg1;
    XSRETURN(argvi);
}


XS(_wrap_CapoParameters_smallPlaceThreshold_get) {
    CapoParameters *arg0 ;
    int argvi = 0;
    unsigned int result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: CapoParameters_smallPlaceThreshold_get(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_CapoParameters) < 0) {
        croak("Type error in argument 1 of CapoParameters_smallPlaceThreshold_get. Expected %s", SWIGTYPE_p_CapoParameters->name);
        XSRETURN(1);
    }
    result = (unsigned int ) (arg0->smallPlaceThreshold);
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) result);
    XSRETURN(argvi);
}


XS(_wrap_CapoParameters_doOverlapping_set) {
    CapoParameters *arg0 ;
    bool arg1 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) 
    croak("Usage: CapoParameters_doOverlapping_set(self,value);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_CapoParameters) < 0) {
        croak("Type error in argument 1 of CapoParameters_doOverlapping_set. Expected %s", SWIGTYPE_p_CapoParameters->name);
        XSRETURN(1);
    }
    arg1 = (bool )SvIV(ST(1));
    arg0->doOverlapping = arg1;
    XSRETURN(argvi);
}


XS(_wrap_CapoParameters_doOverlapping_get) {
    CapoParameters *arg0 ;
    int argvi = 0;
    bool result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: CapoParameters_doOverlapping_get(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_CapoParameters) < 0) {
        croak("Type error in argument 1 of CapoParameters_doOverlapping_get. Expected %s", SWIGTYPE_p_CapoParameters->name);
        XSRETURN(1);
    }
    result = (bool ) (arg0->doOverlapping);
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) result);
    XSRETURN(argvi);
}


XS(_wrap_CapoParameters_startOverlappingLayer_set) {
    CapoParameters *arg0 ;
    unsigned int arg1 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) 
    croak("Usage: CapoParameters_startOverlappingLayer_set(self,value);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_CapoParameters) < 0) {
        croak("Type error in argument 1 of CapoParameters_startOverlappingLayer_set. Expected %s", SWIGTYPE_p_CapoParameters->name);
        XSRETURN(1);
    }
    arg1 = (unsigned int )SvIV(ST(1));
    arg0->startOverlappingLayer = arg1;
    XSRETURN(argvi);
}


XS(_wrap_CapoParameters_startOverlappingLayer_get) {
    CapoParameters *arg0 ;
    int argvi = 0;
    unsigned int result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: CapoParameters_startOverlappingLayer_get(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_CapoParameters) < 0) {
        croak("Type error in argument 1 of CapoParameters_startOverlappingLayer_get. Expected %s", SWIGTYPE_p_CapoParameters->name);
        XSRETURN(1);
    }
    result = (unsigned int ) (arg0->startOverlappingLayer);
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) result);
    XSRETURN(argvi);
}


XS(_wrap_CapoParameters_endOverlappingLayer_set) {
    CapoParameters *arg0 ;
    unsigned int arg1 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) 
    croak("Usage: CapoParameters_endOverlappingLayer_set(self,value);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_CapoParameters) < 0) {
        croak("Type error in argument 1 of CapoParameters_endOverlappingLayer_set. Expected %s", SWIGTYPE_p_CapoParameters->name);
        XSRETURN(1);
    }
    arg1 = (unsigned int )SvIV(ST(1));
    arg0->endOverlappingLayer = arg1;
    XSRETURN(argvi);
}


XS(_wrap_CapoParameters_endOverlappingLayer_get) {
    CapoParameters *arg0 ;
    int argvi = 0;
    unsigned int result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: CapoParameters_endOverlappingLayer_get(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_CapoParameters) < 0) {
        croak("Type error in argument 1 of CapoParameters_endOverlappingLayer_get. Expected %s", SWIGTYPE_p_CapoParameters->name);
        XSRETURN(1);
    }
    result = (unsigned int ) (arg0->endOverlappingLayer);
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) result);
    XSRETURN(argvi);
}


XS(_wrap_CapoParameters_propFromPl_set) {
    CapoParameters *arg0 ;
    bool arg1 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) 
    croak("Usage: CapoParameters_propFromPl_set(self,value);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_CapoParameters) < 0) {
        croak("Type error in argument 1 of CapoParameters_propFromPl_set. Expected %s", SWIGTYPE_p_CapoParameters->name);
        XSRETURN(1);
    }
    arg1 = (bool )SvIV(ST(1));
    arg0->propFromPl = arg1;
    XSRETURN(argvi);
}


XS(_wrap_CapoParameters_propFromPl_get) {
    CapoParameters *arg0 ;
    int argvi = 0;
    bool result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: CapoParameters_propFromPl_get(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_CapoParameters) < 0) {
        croak("Type error in argument 1 of CapoParameters_propFromPl_get. Expected %s", SWIGTYPE_p_CapoParameters->name);
        XSRETURN(1);
    }
    result = (bool ) (arg0->propFromPl);
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) result);
    XSRETURN(argvi);
}


XS(_wrap_CapoParameters_useKPl_set) {
    CapoParameters *arg0 ;
    bool arg1 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) 
    croak("Usage: CapoParameters_useKPl_set(self,value);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_CapoParameters) < 0) {
        croak("Type error in argument 1 of CapoParameters_useKPl_set. Expected %s", SWIGTYPE_p_CapoParameters->name);
        XSRETURN(1);
    }
    arg1 = (bool )SvIV(ST(1));
    arg0->useKPl = arg1;
    XSRETURN(argvi);
}


XS(_wrap_CapoParameters_useKPl_get) {
    CapoParameters *arg0 ;
    int argvi = 0;
    bool result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: CapoParameters_useKPl_get(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_CapoParameters) < 0) {
        croak("Type error in argument 1 of CapoParameters_useKPl_get. Expected %s", SWIGTYPE_p_CapoParameters->name);
        XSRETURN(1);
    }
    result = (bool ) (arg0->useKPl);
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) result);
    XSRETURN(argvi);
}


XS(_wrap_CapoParameters_mlParams_set) {
    CapoParameters *arg0 ;
    MLPartParams *arg1 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) 
    croak("Usage: CapoParameters_mlParams_set(self,value);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_CapoParameters) < 0) {
        croak("Type error in argument 1 of CapoParameters_mlParams_set. Expected %s", SWIGTYPE_p_CapoParameters->name);
        XSRETURN(1);
    }
    if (SWIG_ConvertPtr(ST(1),(void **) &arg1,SWIGTYPE_p_MLPartParams) < 0) {
        croak("Type error in argument 2 of CapoParameters_mlParams_set. Expected %s", SWIGTYPE_p_MLPartParams->name);
        XSRETURN(1);
    }
    arg0->mlParams = *arg1;
    XSRETURN(argvi);
}


XS(_wrap_CapoParameters_mlParams_get) {
    CapoParameters *arg0 ;
    int argvi = 0;
    MLPartParams *result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: CapoParameters_mlParams_get(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_CapoParameters) < 0) {
        croak("Type error in argument 1 of CapoParameters_mlParams_get. Expected %s", SWIGTYPE_p_CapoParameters->name);
        XSRETURN(1);
    }
    result = (MLPartParams *)& (arg0->mlParams);
    ST(argvi) = sv_newmortal();
    SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_MLPartParams);
    XSRETURN(argvi);
}


XS(_wrap_CapoParameters_smplParams_set) {
    CapoParameters *arg0 ;
    SmallPlParams *arg1 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) 
    croak("Usage: CapoParameters_smplParams_set(self,value);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_CapoParameters) < 0) {
        croak("Type error in argument 1 of CapoParameters_smplParams_set. Expected %s", SWIGTYPE_p_CapoParameters->name);
        XSRETURN(1);
    }
    if (SWIG_ConvertPtr(ST(1),(void **) &arg1,SWIGTYPE_p_SmallPlParams) < 0) {
        croak("Type error in argument 2 of CapoParameters_smplParams_set. Expected %s", SWIGTYPE_p_SmallPlParams->name);
        XSRETURN(1);
    }
    arg0->smplParams = *arg1;
    XSRETURN(argvi);
}


XS(_wrap_CapoParameters_smplParams_get) {
    CapoParameters *arg0 ;
    int argvi = 0;
    SmallPlParams *result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: CapoParameters_smplParams_get(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_CapoParameters) < 0) {
        croak("Type error in argument 1 of CapoParameters_smplParams_get. Expected %s", SWIGTYPE_p_CapoParameters->name);
        XSRETURN(1);
    }
    result = (SmallPlParams *)& (arg0->smplParams);
    ST(argvi) = sv_newmortal();
    SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_SmallPlParams);
    XSRETURN(argvi);
}


XS(_wrap_CapoParameters_lookAhead_set) {
    CapoParameters *arg0 ;
    unsigned int arg1 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) 
    croak("Usage: CapoParameters_lookAhead_set(self,value);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_CapoParameters) < 0) {
        croak("Type error in argument 1 of CapoParameters_lookAhead_set. Expected %s", SWIGTYPE_p_CapoParameters->name);
        XSRETURN(1);
    }
    arg1 = (unsigned int )SvIV(ST(1));
    arg0->lookAhead = arg1;
    XSRETURN(argvi);
}


XS(_wrap_CapoParameters_lookAhead_get) {
    CapoParameters *arg0 ;
    int argvi = 0;
    unsigned int result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: CapoParameters_lookAhead_get(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_CapoParameters) < 0) {
        croak("Type error in argument 1 of CapoParameters_lookAhead_get. Expected %s", SWIGTYPE_p_CapoParameters->name);
        XSRETURN(1);
    }
    result = (unsigned int ) (arg0->lookAhead);
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) result);
    XSRETURN(argvi);
}


XS(_wrap_CapoParameters_allowRowSplits_set) {
    CapoParameters *arg0 ;
    bool arg1 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) 
    croak("Usage: CapoParameters_allowRowSplits_set(self,value);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_CapoParameters) < 0) {
        croak("Type error in argument 1 of CapoParameters_allowRowSplits_set. Expected %s", SWIGTYPE_p_CapoParameters->name);
        XSRETURN(1);
    }
    arg1 = (bool )SvIV(ST(1));
    arg0->allowRowSplits = arg1;
    XSRETURN(argvi);
}


XS(_wrap_CapoParameters_allowRowSplits_get) {
    CapoParameters *arg0 ;
    int argvi = 0;
    bool result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: CapoParameters_allowRowSplits_get(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_CapoParameters) < 0) {
        croak("Type error in argument 1 of CapoParameters_allowRowSplits_get. Expected %s", SWIGTYPE_p_CapoParameters->name);
        XSRETURN(1);
    }
    result = (bool ) (arg0->allowRowSplits);
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) result);
    XSRETURN(argvi);
}


XS(_wrap_CapoParameters_splitterParams_set) {
    CapoParameters *arg0 ;
    CapoSplitterParams *arg1 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) 
    croak("Usage: CapoParameters_splitterParams_set(self,value);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_CapoParameters) < 0) {
        croak("Type error in argument 1 of CapoParameters_splitterParams_set. Expected %s", SWIGTYPE_p_CapoParameters->name);
        XSRETURN(1);
    }
    if (SWIG_ConvertPtr(ST(1),(void **) &arg1,SWIGTYPE_p_CapoSplitterParams) < 0) {
        croak("Type error in argument 2 of CapoParameters_splitterParams_set. Expected %s", SWIGTYPE_p_CapoSplitterParams->name);
        XSRETURN(1);
    }
    arg0->splitterParams = *arg1;
    XSRETURN(argvi);
}


XS(_wrap_CapoParameters_splitterParams_get) {
    CapoParameters *arg0 ;
    int argvi = 0;
    CapoSplitterParams *result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: CapoParameters_splitterParams_get(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_CapoParameters) < 0) {
        croak("Type error in argument 1 of CapoParameters_splitterParams_get. Expected %s", SWIGTYPE_p_CapoParameters->name);
        XSRETURN(1);
    }
    result = (CapoSplitterParams *)& (arg0->splitterParams);
    ST(argvi) = sv_newmortal();
    SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_CapoSplitterParams);
    XSRETURN(argvi);
}


XS(_wrap_CapoParameters_plotBlocks_set) {
    CapoParameters *arg0 ;
    bool arg1 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) 
    croak("Usage: CapoParameters_plotBlocks_set(self,value);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_CapoParameters) < 0) {
        croak("Type error in argument 1 of CapoParameters_plotBlocks_set. Expected %s", SWIGTYPE_p_CapoParameters->name);
        XSRETURN(1);
    }
    arg1 = (bool )SvIV(ST(1));
    arg0->plotBlocks = arg1;
    XSRETURN(argvi);
}


XS(_wrap_CapoParameters_plotBlocks_get) {
    CapoParameters *arg0 ;
    int argvi = 0;
    bool result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: CapoParameters_plotBlocks_get(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_CapoParameters) < 0) {
        croak("Type error in argument 1 of CapoParameters_plotBlocks_get. Expected %s", SWIGTYPE_p_CapoParameters->name);
        XSRETURN(1);
    }
    result = (bool ) (arg0->plotBlocks);
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) result);
    XSRETURN(argvi);
}


XS(_wrap_CapoParameters_saveLayerBBoxes_set) {
    CapoParameters *arg0 ;
    bool arg1 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) 
    croak("Usage: CapoParameters_saveLayerBBoxes_set(self,value);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_CapoParameters) < 0) {
        croak("Type error in argument 1 of CapoParameters_saveLayerBBoxes_set. Expected %s", SWIGTYPE_p_CapoParameters->name);
        XSRETURN(1);
    }
    arg1 = (bool )SvIV(ST(1));
    arg0->saveLayerBBoxes = arg1;
    XSRETURN(argvi);
}


XS(_wrap_CapoParameters_saveLayerBBoxes_get) {
    CapoParameters *arg0 ;
    int argvi = 0;
    bool result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: CapoParameters_saveLayerBBoxes_get(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_CapoParameters) < 0) {
        croak("Type error in argument 1 of CapoParameters_saveLayerBBoxes_get. Expected %s", SWIGTYPE_p_CapoParameters->name);
        XSRETURN(1);
    }
    result = (bool ) (arg0->saveLayerBBoxes);
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) result);
    XSRETURN(argvi);
}


XS(_wrap_CapoParameters_saveBlocks_set) {
    CapoParameters *arg0 ;
    bool arg1 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) 
    croak("Usage: CapoParameters_saveBlocks_set(self,value);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_CapoParameters) < 0) {
        croak("Type error in argument 1 of CapoParameters_saveBlocks_set. Expected %s", SWIGTYPE_p_CapoParameters->name);
        XSRETURN(1);
    }
    arg1 = (bool )SvIV(ST(1));
    arg0->saveBlocks = arg1;
    XSRETURN(argvi);
}


XS(_wrap_CapoParameters_saveBlocks_get) {
    CapoParameters *arg0 ;
    int argvi = 0;
    bool result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: CapoParameters_saveBlocks_get(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_CapoParameters) < 0) {
        croak("Type error in argument 1 of CapoParameters_saveBlocks_get. Expected %s", SWIGTYPE_p_CapoParameters->name);
        XSRETURN(1);
    }
    result = (bool ) (arg0->saveBlocks);
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) result);
    XSRETURN(argvi);
}


XS(_wrap_CapoParameters_saveSmallPlProb_set) {
    CapoParameters *arg0 ;
    bool arg1 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) 
    croak("Usage: CapoParameters_saveSmallPlProb_set(self,value);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_CapoParameters) < 0) {
        croak("Type error in argument 1 of CapoParameters_saveSmallPlProb_set. Expected %s", SWIGTYPE_p_CapoParameters->name);
        XSRETURN(1);
    }
    arg1 = (bool )SvIV(ST(1));
    arg0->saveSmallPlProb = arg1;
    XSRETURN(argvi);
}


XS(_wrap_CapoParameters_saveSmallPlProb_get) {
    CapoParameters *arg0 ;
    int argvi = 0;
    bool result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: CapoParameters_saveSmallPlProb_get(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_CapoParameters) < 0) {
        croak("Type error in argument 1 of CapoParameters_saveSmallPlProb_get. Expected %s", SWIGTYPE_p_CapoParameters->name);
        XSRETURN(1);
    }
    result = (bool ) (arg0->saveSmallPlProb);
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) result);
    XSRETURN(argvi);
}


XS(_wrap_new_CapoParameters) {
    int argvi = 0;
    CapoParameters *result ;
    dXSARGS;
    
    if ((items < 0) || (items > 0)) 
    croak("Usage: new_CapoParameters();");
    result = (CapoParameters *)new CapoParameters();
    ST(argvi) = sv_newmortal();
    SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_CapoParameters);
    XSRETURN(argvi);
}


XS(_wrap_CapoParameters_printHelp) {
    CapoParameters *arg0 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: CapoParameters_printHelp(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_CapoParameters) < 0) {
        croak("Type error in argument 1 of CapoParameters_printHelp. Expected %s", SWIGTYPE_p_CapoParameters->name);
        XSRETURN(1);
    }
    arg0->printHelp();
    XSRETURN(argvi);
}


XS(_wrap_MetaPlacerParams_verb_set) {
    MetaPlacerParams *arg0 ;
    Verbosity *arg1 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) 
    croak("Usage: MetaPlacerParams_verb_set(self,value);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_MetaPlacerParams) < 0) {
        croak("Type error in argument 1 of MetaPlacerParams_verb_set. Expected %s", SWIGTYPE_p_MetaPlacerParams->name);
        XSRETURN(1);
    }
    if (SWIG_ConvertPtr(ST(1),(void **) &arg1,SWIGTYPE_p_Verbosity) < 0) {
        croak("Type error in argument 2 of MetaPlacerParams_verb_set. Expected %s", SWIGTYPE_p_Verbosity->name);
        XSRETURN(1);
    }
    arg0->verb = *arg1;
    XSRETURN(argvi);
}


XS(_wrap_MetaPlacerParams_verb_get) {
    MetaPlacerParams *arg0 ;
    int argvi = 0;
    Verbosity *result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: MetaPlacerParams_verb_get(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_MetaPlacerParams) < 0) {
        croak("Type error in argument 1 of MetaPlacerParams_verb_get. Expected %s", SWIGTYPE_p_MetaPlacerParams->name);
        XSRETURN(1);
    }
    result = (Verbosity *)& (arg0->verb);
    ST(argvi) = sv_newmortal();
    SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_Verbosity);
    XSRETURN(argvi);
}


XS(_wrap_MetaPlacerParams_save_set) {
    MetaPlacerParams *arg0 ;
    bool arg1 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) 
    croak("Usage: MetaPlacerParams_save_set(self,value);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_MetaPlacerParams) < 0) {
        croak("Type error in argument 1 of MetaPlacerParams_save_set. Expected %s", SWIGTYPE_p_MetaPlacerParams->name);
        XSRETURN(1);
    }
    arg1 = (bool )SvIV(ST(1));
    arg0->save = arg1;
    XSRETURN(argvi);
}


XS(_wrap_MetaPlacerParams_save_get) {
    MetaPlacerParams *arg0 ;
    int argvi = 0;
    bool result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: MetaPlacerParams_save_get(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_MetaPlacerParams) < 0) {
        croak("Type error in argument 1 of MetaPlacerParams_save_get. Expected %s", SWIGTYPE_p_MetaPlacerParams->name);
        XSRETURN(1);
    }
    result = (bool ) (arg0->save);
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) result);
    XSRETURN(argvi);
}


XS(_wrap_MetaPlacerParams_flip_set) {
    MetaPlacerParams *arg0 ;
    bool arg1 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) 
    croak("Usage: MetaPlacerParams_flip_set(self,value);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_MetaPlacerParams) < 0) {
        croak("Type error in argument 1 of MetaPlacerParams_flip_set. Expected %s", SWIGTYPE_p_MetaPlacerParams->name);
        XSRETURN(1);
    }
    arg1 = (bool )SvIV(ST(1));
    arg0->flip = arg1;
    XSRETURN(argvi);
}


XS(_wrap_MetaPlacerParams_flip_get) {
    MetaPlacerParams *arg0 ;
    int argvi = 0;
    bool result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: MetaPlacerParams_flip_get(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_MetaPlacerParams) < 0) {
        croak("Type error in argument 1 of MetaPlacerParams_flip_get. Expected %s", SWIGTYPE_p_MetaPlacerParams->name);
        XSRETURN(1);
    }
    result = (bool ) (arg0->flip);
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) result);
    XSRETURN(argvi);
}


XS(_wrap_MetaPlacerParams_skipRowIroning_set) {
    MetaPlacerParams *arg0 ;
    bool arg1 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) 
    croak("Usage: MetaPlacerParams_skipRowIroning_set(self,value);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_MetaPlacerParams) < 0) {
        croak("Type error in argument 1 of MetaPlacerParams_skipRowIroning_set. Expected %s", SWIGTYPE_p_MetaPlacerParams->name);
        XSRETURN(1);
    }
    arg1 = (bool )SvIV(ST(1));
    arg0->skipRowIroning = arg1;
    XSRETURN(argvi);
}


XS(_wrap_MetaPlacerParams_skipRowIroning_get) {
    MetaPlacerParams *arg0 ;
    int argvi = 0;
    bool result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: MetaPlacerParams_skipRowIroning_get(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_MetaPlacerParams) < 0) {
        croak("Type error in argument 1 of MetaPlacerParams_skipRowIroning_get. Expected %s", SWIGTYPE_p_MetaPlacerParams->name);
        XSRETURN(1);
    }
    result = (bool ) (arg0->skipRowIroning);
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) result);
    XSRETURN(argvi);
}


XS(_wrap_new_MetaPlacerParams) {
    int arg0 ;
    char **arg1 ;
    int n_arg ;
    int argvi = 0;
    MetaPlacerParams *result ;
    dXSARGS;
    
    {
        arg0=n_arg=items;
        items=1;
    }
    if ((items < 1) || (items > 1)) 
    croak("Usage: new_MetaPlacerParams(argv);");
    {
        arg1 = (char **)
        malloc(n_arg*sizeof(char *));
        for (; n_arg; --n_arg) {
            arg1[n_arg-1]=
            (char *)SvPV(ST(n_arg-1),PL_na);
        }
    }
    result = (MetaPlacerParams *)new MetaPlacerParams(arg0,(char const *(*))arg1);
    ST(argvi) = sv_newmortal();
    SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_MetaPlacerParams);
    XSRETURN(argvi);
}


XS(_wrap_new_MetaPlacer) {
    RBPlacement *arg0 ;
    MetaPlacerParams *arg1 ;
    int argvi = 0;
    MetaPlacer *result ;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) 
    croak("Usage: new_MetaPlacer(rbplace,par);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_RBPlacement) < 0) {
        croak("Type error in argument 1 of new_MetaPlacer. Expected %s", SWIGTYPE_p_RBPlacement->name);
        XSRETURN(1);
    }
    if (SWIG_ConvertPtr(ST(1),(void **) &arg1,SWIGTYPE_p_MetaPlacerParams) < 0) {
        croak("Type error in argument 2 of new_MetaPlacer. Expected %s", SWIGTYPE_p_MetaPlacerParams->name);
        XSRETURN(1);
    }
    result = (MetaPlacer *)new MetaPlacer(*arg0,*arg1);
    ST(argvi) = sv_newmortal();
    SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_MetaPlacer);
    XSRETURN(argvi);
}


XS(_wrap_delete_MetaPlacer) {
    MetaPlacer *arg0 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: delete_MetaPlacer(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_MetaPlacer) < 0) {
        croak("Type error in argument 1 of delete_MetaPlacer. Expected %s", SWIGTYPE_p_MetaPlacer->name);
        XSRETURN(1);
    }
    delete arg0;
    XSRETURN(argvi);
}


XS(_wrap_new_PartitioningProblem) {
    HGraphFixed *arg0 ;
    PartitioningBuffer *arg1 ;
    Partitioning *arg2 ;
    vector<BBox> *arg3 ;
    vector<vector<double> > *arg4 ;
    vector<double> *arg5 ;
    vector<unsigned> *arg6 ;
    vector<BBox> *arg7 ;
    PartitioningProblem_Parameters *arg8 ;
    int argvi = 0;
    PartitioningProblem *result ;
    dXSARGS;
    
    if ((items < 9) || (items > 9)) 
    croak("Usage: new_PartitioningProblem(hgraph,solnBuffers,fixedConstr,partitions,capacities,tolerances,terminalToBlock,padBlocks,parameters);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_HGraphFixed) < 0) {
        croak("Type error in argument 1 of new_PartitioningProblem. Expected %s", SWIGTYPE_p_HGraphFixed->name);
        XSRETURN(1);
    }
    if (SWIG_ConvertPtr(ST(1),(void **) &arg1,SWIGTYPE_p_PartitioningBuffer) < 0) {
        croak("Type error in argument 2 of new_PartitioningProblem. Expected %s", SWIGTYPE_p_PartitioningBuffer->name);
        XSRETURN(1);
    }
    if (SWIG_ConvertPtr(ST(2),(void **) &arg2,SWIGTYPE_p_Partitioning) < 0) {
        croak("Type error in argument 3 of new_PartitioningProblem. Expected %s", SWIGTYPE_p_Partitioning->name);
        XSRETURN(1);
    }
    if (SWIG_ConvertPtr(ST(3),(void **) &arg3,SWIGTYPE_p_vector_BBox_) < 0) {
        croak("Type error in argument 4 of new_PartitioningProblem. Expected %s", SWIGTYPE_p_vector_BBox_->name);
        XSRETURN(1);
    }
    if (SWIG_ConvertPtr(ST(4),(void **) &arg4,SWIGTYPE_p_vector_vector_double___) < 0) {
        croak("Type error in argument 5 of new_PartitioningProblem. Expected %s", SWIGTYPE_p_vector_vector_double___->name);
        XSRETURN(1);
    }
    if (SWIG_ConvertPtr(ST(5),(void **) &arg5,SWIGTYPE_p_vector_double_) < 0) {
        croak("Type error in argument 6 of new_PartitioningProblem. Expected %s", SWIGTYPE_p_vector_double_->name);
        XSRETURN(1);
    }
    if (SWIG_ConvertPtr(ST(6),(void **) &arg6,SWIGTYPE_p_vector_unsigned_) < 0) {
        croak("Type error in argument 7 of new_PartitioningProblem. Expected %s", SWIGTYPE_p_vector_unsigned_->name);
        XSRETURN(1);
    }
    if (SWIG_ConvertPtr(ST(7),(void **) &arg7,SWIGTYPE_p_vector_BBox_) < 0) {
        croak("Type error in argument 8 of new_PartitioningProblem. Expected %s", SWIGTYPE_p_vector_BBox_->name);
        XSRETURN(1);
    }
    if (SWIG_ConvertPtr(ST(8),(void **) &arg8,SWIGTYPE_p_PartitioningProblem_Parameters) < 0) {
        croak("Type error in argument 9 of new_PartitioningProblem. Expected %s", SWIGTYPE_p_PartitioningProblem_Parameters->name);
        XSRETURN(1);
    }
    result = (PartitioningProblem *)new PartitioningProblem((HGraphFixed const &)*arg0,(PartitioningBuffer const &)*arg1,(Partitioning const &)*arg2,(vector<BBox> const &)*arg3,(vector<vector<double> > const &)*arg4,(vector<double> const &)*arg5,(vector<unsigned> const &)*arg6,(vector<BBox> const &)*arg7,*arg8);
    ST(argvi) = sv_newmortal();
    SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_PartitioningProblem);
    XSRETURN(argvi);
}


XS(_wrap_delete_PartitioningProblem) {
    PartitioningProblem *arg0 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: delete_PartitioningProblem(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_PartitioningProblem) < 0) {
        croak("Type error in argument 1 of delete_PartitioningProblem. Expected %s", SWIGTYPE_p_PartitioningProblem->name);
        XSRETURN(1);
    }
    delete arg0;
    XSRETURN(argvi);
}


XS(_wrap_PartitioningProblem_propagateTerminals) {
    PartitioningProblem *arg0 ;
    double arg1 = 0.0 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 1) || (items > 2)) 
    croak("Usage: PartitioningProblem_propagateTerminals(self,fuzziness);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_PartitioningProblem) < 0) {
        croak("Type error in argument 1 of PartitioningProblem_propagateTerminals. Expected %s", SWIGTYPE_p_PartitioningProblem->name);
        XSRETURN(1);
    }
    if (items > 1) {
        arg1 = (double )SvNV(ST(1));
    }
    arg0->propagateTerminals(arg1);
    XSRETURN(argvi);
}


XS(_wrap_PartitioningProblem_saveAsNetDAre) {
    PartitioningProblem *arg0 ;
    char *arg1 ;
    int argvi = 0;
    bool result ;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) 
    croak("Usage: PartitioningProblem_saveAsNetDAre(self,baseFileName);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_PartitioningProblem) < 0) {
        croak("Type error in argument 1 of PartitioningProblem_saveAsNetDAre. Expected %s", SWIGTYPE_p_PartitioningProblem->name);
        XSRETURN(1);
    }
    if (! SvOK((SV*) ST(1))) {
        arg1 = 0; 
    }
    else {
        arg1 = (char *) SvPV(ST(1),PL_na); 
    }
    result = (bool )arg0->saveAsNetDAre((char const *)arg1);
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) result);
    XSRETURN(argvi);
}


XS(_wrap_PartitioningProblem_saveAsNodesNets) {
    PartitioningProblem *arg0 ;
    char *arg1 ;
    int argvi = 0;
    bool result ;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) 
    croak("Usage: PartitioningProblem_saveAsNodesNets(self,baseFileName);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_PartitioningProblem) < 0) {
        croak("Type error in argument 1 of PartitioningProblem_saveAsNodesNets. Expected %s", SWIGTYPE_p_PartitioningProblem->name);
        XSRETURN(1);
    }
    if (! SvOK((SV*) ST(1))) {
        arg1 = 0; 
    }
    else {
        arg1 = (char *) SvPV(ST(1),PL_na); 
    }
    result = (bool )arg0->saveAsNodesNets((char const *)arg1);
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) result);
    XSRETURN(argvi);
}


XS(_wrap_PartitioningProblem_saveBestSol) {
    PartitioningProblem *arg0 ;
    char *arg1 ;
    int argvi = 0;
    bool result ;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) 
    croak("Usage: PartitioningProblem_saveBestSol(self,solFileName);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_PartitioningProblem) < 0) {
        croak("Type error in argument 1 of PartitioningProblem_saveBestSol. Expected %s", SWIGTYPE_p_PartitioningProblem->name);
        XSRETURN(1);
    }
    if (! SvOK((SV*) ST(1))) {
        arg1 = 0; 
    }
    else {
        arg1 = (char *) SvPV(ST(1),PL_na); 
    }
    result = (bool )arg0->saveBestSol((char const *)arg1);
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) result);
    XSRETURN(argvi);
}


XS(_wrap_PartitioningProblem_reserveBuffers) {
    PartitioningProblem *arg0 ;
    unsigned int arg1 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) 
    croak("Usage: PartitioningProblem_reserveBuffers(self,num);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_PartitioningProblem) < 0) {
        croak("Type error in argument 1 of PartitioningProblem_reserveBuffers. Expected %s", SWIGTYPE_p_PartitioningProblem->name);
        XSRETURN(1);
    }
    arg1 = (unsigned int )SvIV(ST(1));
    arg0->reserveBuffers(arg1);
    XSRETURN(argvi);
}


XS(_wrap_PartitioningProblem_isDataOwned) {
    PartitioningProblem *arg0 ;
    int argvi = 0;
    bool result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: PartitioningProblem_isDataOwned(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_PartitioningProblem) < 0) {
        croak("Type error in argument 1 of PartitioningProblem_isDataOwned. Expected %s", SWIGTYPE_p_PartitioningProblem->name);
        XSRETURN(1);
    }
    result = (bool )arg0->isDataOwned();
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) result);
    XSRETURN(argvi);
}


XS(_wrap_PartitioningProblem_partsComeFromGrid) {
    PartitioningProblem *arg0 ;
    int argvi = 0;
    bool result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: PartitioningProblem_partsComeFromGrid(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_PartitioningProblem) < 0) {
        croak("Type error in argument 1 of PartitioningProblem_partsComeFromGrid. Expected %s", SWIGTYPE_p_PartitioningProblem->name);
        XSRETURN(1);
    }
    result = (bool )arg0->partsComeFromGrid();
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) result);
    XSRETURN(argvi);
}


XS(_wrap_PartitioningProblem_getNumXParts) {
    PartitioningProblem *arg0 ;
    int argvi = 0;
    unsigned int result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: PartitioningProblem_getNumXParts(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_PartitioningProblem) < 0) {
        croak("Type error in argument 1 of PartitioningProblem_getNumXParts. Expected %s", SWIGTYPE_p_PartitioningProblem->name);
        XSRETURN(1);
    }
    result = (unsigned int )arg0->getNumXParts();
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) result);
    XSRETURN(argvi);
}


XS(_wrap_PartitioningProblem_getNumYParts) {
    PartitioningProblem *arg0 ;
    int argvi = 0;
    unsigned int result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: PartitioningProblem_getNumYParts(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_PartitioningProblem) < 0) {
        croak("Type error in argument 1 of PartitioningProblem_getNumYParts. Expected %s", SWIGTYPE_p_PartitioningProblem->name);
        XSRETURN(1);
    }
    result = (unsigned int )arg0->getNumYParts();
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) result);
    XSRETURN(argvi);
}


XS(_wrap_PartitioningProblem_getXTics) {
    PartitioningProblem *arg0 ;
    int argvi = 0;
    vector<double> *result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: PartitioningProblem_getXTics(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_PartitioningProblem) < 0) {
        croak("Type error in argument 1 of PartitioningProblem_getXTics. Expected %s", SWIGTYPE_p_PartitioningProblem->name);
        XSRETURN(1);
    }
    vector<double> const &_result_ref = arg0->getXTics();
    result = (vector<double> *) &_result_ref;
    ST(argvi) = sv_newmortal();
    SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_vector_double_);
    XSRETURN(argvi);
}


XS(_wrap_PartitioningProblem_getYTics) {
    PartitioningProblem *arg0 ;
    int argvi = 0;
    vector<double> *result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: PartitioningProblem_getYTics(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_PartitioningProblem) < 0) {
        croak("Type error in argument 1 of PartitioningProblem_getYTics. Expected %s", SWIGTYPE_p_PartitioningProblem->name);
        XSRETURN(1);
    }
    vector<double> const &_result_ref = arg0->getYTics();
    result = (vector<double> *) &_result_ref;
    ST(argvi) = sv_newmortal();
    SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_vector_double_);
    XSRETURN(argvi);
}


XS(_wrap_PartitioningProblem_getHGraph) {
    PartitioningProblem *arg0 ;
    int argvi = 0;
    HGraphFixed *result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: PartitioningProblem_getHGraph(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_PartitioningProblem) < 0) {
        croak("Type error in argument 1 of PartitioningProblem_getHGraph. Expected %s", SWIGTYPE_p_PartitioningProblem->name);
        XSRETURN(1);
    }
    HGraphFixed const &_result_ref = arg0->getHGraph();
    result = (HGraphFixed *) &_result_ref;
    ST(argvi) = sv_newmortal();
    SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_HGraphFixed);
    XSRETURN(argvi);
}


XS(_wrap_PartitioningProblem_getHGraphPointer) {
    PartitioningProblem *arg0 ;
    int argvi = 0;
    HGraphFixed *result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: PartitioningProblem_getHGraphPointer(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_PartitioningProblem) < 0) {
        croak("Type error in argument 1 of PartitioningProblem_getHGraphPointer. Expected %s", SWIGTYPE_p_PartitioningProblem->name);
        XSRETURN(1);
    }
    result = (HGraphFixed *)arg0->getHGraphPointer();
    ST(argvi) = sv_newmortal();
    SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_HGraphFixed);
    XSRETURN(argvi);
}


XS(_wrap_PartitioningProblem_getParameters) {
    PartitioningProblem *arg0 ;
    int argvi = 0;
    PartitioningProblem_Parameters *result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: PartitioningProblem_getParameters(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_PartitioningProblem) < 0) {
        croak("Type error in argument 1 of PartitioningProblem_getParameters. Expected %s", SWIGTYPE_p_PartitioningProblem->name);
        XSRETURN(1);
    }
    PartitioningProblem_Parameters const &_result_ref = arg0->getParameters();
    result = (PartitioningProblem_Parameters *) &_result_ref;
    ST(argvi) = sv_newmortal();
    SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_PartitioningProblem_Parameters);
    XSRETURN(argvi);
}


XS(_wrap_PartitioningProblem_getSolnBuffers) {
    PartitioningProblem *arg0 ;
    int argvi = 0;
    PartitioningBuffer *result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: PartitioningProblem_getSolnBuffers(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_PartitioningProblem) < 0) {
        croak("Type error in argument 1 of PartitioningProblem_getSolnBuffers. Expected %s", SWIGTYPE_p_PartitioningProblem->name);
        XSRETURN(1);
    }
    PartitioningBuffer &_result_ref = arg0->getSolnBuffers();
    result = (PartitioningBuffer *) &_result_ref;
    ST(argvi) = sv_newmortal();
    SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_PartitioningBuffer);
    XSRETURN(argvi);
}


XS(_wrap_PartitioningProblem_getBestSoln) {
    PartitioningProblem *arg0 ;
    int argvi = 0;
    Partitioning *result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: PartitioningProblem_getBestSoln(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_PartitioningProblem) < 0) {
        croak("Type error in argument 1 of PartitioningProblem_getBestSoln. Expected %s", SWIGTYPE_p_PartitioningProblem->name);
        XSRETURN(1);
    }
    Partitioning const &_result_ref = arg0->getBestSoln();
    result = (Partitioning *) &_result_ref;
    ST(argvi) = sv_newmortal();
    SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_Partitioning);
    XSRETURN(argvi);
}


XS(_wrap_PartitioningProblem_setSolnBuffers) {
    PartitioningProblem *arg0 ;
    PartitioningBuffer *arg1 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) 
    croak("Usage: PartitioningProblem_setSolnBuffers(self,newbufs);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_PartitioningProblem) < 0) {
        croak("Type error in argument 1 of PartitioningProblem_setSolnBuffers. Expected %s", SWIGTYPE_p_PartitioningProblem->name);
        XSRETURN(1);
    }
    if (SWIG_ConvertPtr(ST(1),(void **) &arg1,SWIGTYPE_p_PartitioningBuffer) < 0) {
        croak("Type error in argument 2 of PartitioningProblem_setSolnBuffers. Expected %s", SWIGTYPE_p_PartitioningBuffer->name);
        XSRETURN(1);
    }
    arg0->setSolnBuffers(arg1);
    XSRETURN(argvi);
}


XS(_wrap_PartitioningProblem_swapOutSolnBuffers) {
    PartitioningProblem *arg0 ;
    PartitioningBuffer *arg1 ;
    int argvi = 0;
    PartitioningBuffer *result ;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) 
    croak("Usage: PartitioningProblem_swapOutSolnBuffers(self,newbufs);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_PartitioningProblem) < 0) {
        croak("Type error in argument 1 of PartitioningProblem_swapOutSolnBuffers. Expected %s", SWIGTYPE_p_PartitioningProblem->name);
        XSRETURN(1);
    }
    if (SWIG_ConvertPtr(ST(1),(void **) &arg1,SWIGTYPE_p_PartitioningBuffer) < 0) {
        croak("Type error in argument 2 of PartitioningProblem_swapOutSolnBuffers. Expected %s", SWIGTYPE_p_PartitioningBuffer->name);
        XSRETURN(1);
    }
    result = (PartitioningBuffer *)arg0->swapOutSolnBuffers(arg1);
    ST(argvi) = sv_newmortal();
    SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_PartitioningBuffer);
    XSRETURN(argvi);
}


XS(_wrap_PartitioningProblem_swapOutFixedConst) {
    PartitioningProblem *arg0 ;
    Partitioning *arg1 ;
    int argvi = 0;
    Partitioning *result ;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) 
    croak("Usage: PartitioningProblem_swapOutFixedConst(self,fixedConstr);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_PartitioningProblem) < 0) {
        croak("Type error in argument 1 of PartitioningProblem_swapOutFixedConst. Expected %s", SWIGTYPE_p_PartitioningProblem->name);
        XSRETURN(1);
    }
    if (SWIG_ConvertPtr(ST(1),(void **) &arg1,SWIGTYPE_p_Partitioning) < 0) {
        croak("Type error in argument 2 of PartitioningProblem_swapOutFixedConst. Expected %s", SWIGTYPE_p_Partitioning->name);
        XSRETURN(1);
    }
    result = (Partitioning *)arg0->swapOutFixedConst(arg1);
    ST(argvi) = sv_newmortal();
    SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_Partitioning);
    XSRETURN(argvi);
}


XS(_wrap_PartitioningProblem_swapOutHGraph) {
    PartitioningProblem *arg0 ;
    HGraphFixed *arg1 ;
    int argvi = 0;
    HGraphFixed *result ;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) 
    croak("Usage: PartitioningProblem_swapOutHGraph(self,hgraph);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_PartitioningProblem) < 0) {
        croak("Type error in argument 1 of PartitioningProblem_swapOutHGraph. Expected %s", SWIGTYPE_p_PartitioningProblem->name);
        XSRETURN(1);
    }
    if (SWIG_ConvertPtr(ST(1),(void **) &arg1,SWIGTYPE_p_HGraphFixed) < 0) {
        croak("Type error in argument 2 of PartitioningProblem_swapOutHGraph. Expected %s", SWIGTYPE_p_HGraphFixed->name);
        XSRETURN(1);
    }
    result = (HGraphFixed *)arg0->swapOutHGraph(arg1);
    ST(argvi) = sv_newmortal();
    SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_HGraphFixed);
    XSRETURN(argvi);
}


XS(_wrap_PartitioningProblem_getCosts) {
    PartitioningProblem *arg0 ;
    int argvi = 0;
    vector<double> *result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: PartitioningProblem_getCosts(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_PartitioningProblem) < 0) {
        croak("Type error in argument 1 of PartitioningProblem_getCosts. Expected %s", SWIGTYPE_p_PartitioningProblem->name);
        XSRETURN(1);
    }
    vector<double> const &_result_ref = arg0->getCosts();
    result = (vector<double> *) &_result_ref;
    ST(argvi) = sv_newmortal();
    SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_vector_double_);
    XSRETURN(argvi);
}


XS(_wrap_PartitioningProblem_getViolations) {
    PartitioningProblem *arg0 ;
    int argvi = 0;
    vector<double> *result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: PartitioningProblem_getViolations(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_PartitioningProblem) < 0) {
        croak("Type error in argument 1 of PartitioningProblem_getViolations. Expected %s", SWIGTYPE_p_PartitioningProblem->name);
        XSRETURN(1);
    }
    vector<double> const &_result_ref = arg0->getViolations();
    result = (vector<double> *) &_result_ref;
    ST(argvi) = sv_newmortal();
    SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_vector_double_);
    XSRETURN(argvi);
}


XS(_wrap_PartitioningProblem_getImbalances) {
    PartitioningProblem *arg0 ;
    int argvi = 0;
    vector<double> *result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: PartitioningProblem_getImbalances(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_PartitioningProblem) < 0) {
        croak("Type error in argument 1 of PartitioningProblem_getImbalances. Expected %s", SWIGTYPE_p_PartitioningProblem->name);
        XSRETURN(1);
    }
    vector<double> const &_result_ref = arg0->getImbalances();
    result = (vector<double> *) &_result_ref;
    ST(argvi) = sv_newmortal();
    SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_vector_double_);
    XSRETURN(argvi);
}


XS(_wrap_PartitioningProblem_getFixedConstr) {
    PartitioningProblem *arg0 ;
    int argvi = 0;
    Partitioning *result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: PartitioningProblem_getFixedConstr(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_PartitioningProblem) < 0) {
        croak("Type error in argument 1 of PartitioningProblem_getFixedConstr. Expected %s", SWIGTYPE_p_PartitioningProblem->name);
        XSRETURN(1);
    }
    Partitioning const &_result_ref = arg0->getFixedConstr();
    result = (Partitioning *) &_result_ref;
    ST(argvi) = sv_newmortal();
    SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_Partitioning);
    XSRETURN(argvi);
}


XS(_wrap_PartitioningProblem_getCapacities) {
    PartitioningProblem *arg0 ;
    int argvi = 0;
    vector<vector<double> > *result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: PartitioningProblem_getCapacities(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_PartitioningProblem) < 0) {
        croak("Type error in argument 1 of PartitioningProblem_getCapacities. Expected %s", SWIGTYPE_p_PartitioningProblem->name);
        XSRETURN(1);
    }
    vector<vector<double> > const &_result_ref = arg0->getCapacities();
    result = (vector<vector<double> > *) &_result_ref;
    ST(argvi) = sv_newmortal();
    SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_vector_vector_double___);
    XSRETURN(argvi);
}


XS(_wrap_PartitioningProblem_getMaxCapacities) {
    PartitioningProblem *arg0 ;
    int argvi = 0;
    vector<vector<double> > *result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: PartitioningProblem_getMaxCapacities(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_PartitioningProblem) < 0) {
        croak("Type error in argument 1 of PartitioningProblem_getMaxCapacities. Expected %s", SWIGTYPE_p_PartitioningProblem->name);
        XSRETURN(1);
    }
    vector<vector<double> > const &_result_ref = arg0->getMaxCapacities();
    result = (vector<vector<double> > *) &_result_ref;
    ST(argvi) = sv_newmortal();
    SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_vector_vector_double___);
    XSRETURN(argvi);
}


XS(_wrap_PartitioningProblem_getMinCapacities) {
    PartitioningProblem *arg0 ;
    int argvi = 0;
    vector<vector<double> > *result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: PartitioningProblem_getMinCapacities(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_PartitioningProblem) < 0) {
        croak("Type error in argument 1 of PartitioningProblem_getMinCapacities. Expected %s", SWIGTYPE_p_PartitioningProblem->name);
        XSRETURN(1);
    }
    vector<vector<double> > const &_result_ref = arg0->getMinCapacities();
    result = (vector<vector<double> > *) &_result_ref;
    ST(argvi) = sv_newmortal();
    SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_vector_vector_double___);
    XSRETURN(argvi);
}


XS(_wrap_PartitioningProblem_getTotalWeight) {
    PartitioningProblem *arg0 ;
    int argvi = 0;
    vector<double> *result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: PartitioningProblem_getTotalWeight(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_PartitioningProblem) < 0) {
        croak("Type error in argument 1 of PartitioningProblem_getTotalWeight. Expected %s", SWIGTYPE_p_PartitioningProblem->name);
        XSRETURN(1);
    }
    vector<double> const &_result_ref = arg0->getTotalWeight();
    result = (vector<double> *) &_result_ref;
    ST(argvi) = sv_newmortal();
    SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_vector_double_);
    XSRETURN(argvi);
}


XS(_wrap_PartitioningProblem_getPartitions) {
    PartitioningProblem *arg0 ;
    int argvi = 0;
    vector<BBox> *result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: PartitioningProblem_getPartitions(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_PartitioningProblem) < 0) {
        croak("Type error in argument 1 of PartitioningProblem_getPartitions. Expected %s", SWIGTYPE_p_PartitioningProblem->name);
        XSRETURN(1);
    }
    vector<BBox> const &_result_ref = arg0->getPartitions();
    result = (vector<BBox> *) &_result_ref;
    ST(argvi) = sv_newmortal();
    SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_vector_BBox_);
    XSRETURN(argvi);
}


XS(_wrap_PartitioningProblem_getPartitionCenters) {
    PartitioningProblem *arg0 ;
    int argvi = 0;
    vector<Point> *result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: PartitioningProblem_getPartitionCenters(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_PartitioningProblem) < 0) {
        croak("Type error in argument 1 of PartitioningProblem_getPartitionCenters. Expected %s", SWIGTYPE_p_PartitioningProblem->name);
        XSRETURN(1);
    }
    vector<Point> const &_result_ref = arg0->getPartitionCenters();
    result = (vector<Point> *) &_result_ref;
    ST(argvi) = sv_newmortal();
    SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_vector_Point_);
    XSRETURN(argvi);
}


XS(_wrap_PartitioningProblem_getScalingFactorForBBoxQuantization) {
    PartitioningProblem *arg0 ;
    unsigned int arg1 ;
    int argvi = 0;
    double result ;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) 
    croak("Usage: PartitioningProblem_getScalingFactorForBBoxQuantization(self,quantizationBound);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_PartitioningProblem) < 0) {
        croak("Type error in argument 1 of PartitioningProblem_getScalingFactorForBBoxQuantization. Expected %s", SWIGTYPE_p_PartitioningProblem->name);
        XSRETURN(1);
    }
    arg1 = (unsigned int )SvIV(ST(1));
    result = (double )arg0->getScalingFactorForBBoxQuantization(arg1);
    ST(argvi) = sv_newmortal();
    sv_setnv(ST(argvi++), (double) result);
    XSRETURN(argvi);
}


XS(_wrap_PartitioningProblem_getPadBlocks) {
    PartitioningProblem *arg0 ;
    int argvi = 0;
    vector<BBox> *result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: PartitioningProblem_getPadBlocks(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_PartitioningProblem) < 0) {
        croak("Type error in argument 1 of PartitioningProblem_getPadBlocks. Expected %s", SWIGTYPE_p_PartitioningProblem->name);
        XSRETURN(1);
    }
    vector<BBox> const &_result_ref = arg0->getPadBlocks();
    result = (vector<BBox> *) &_result_ref;
    ST(argvi) = sv_newmortal();
    SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_vector_BBox_);
    XSRETURN(argvi);
}


XS(_wrap_PartitioningProblem_getPadBlockCenters) {
    PartitioningProblem *arg0 ;
    int argvi = 0;
    vector<Point> *result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: PartitioningProblem_getPadBlockCenters(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_PartitioningProblem) < 0) {
        croak("Type error in argument 1 of PartitioningProblem_getPadBlockCenters. Expected %s", SWIGTYPE_p_PartitioningProblem->name);
        XSRETURN(1);
    }
    vector<Point> const &_result_ref = arg0->getPadBlockCenters();
    result = (vector<Point> *) &_result_ref;
    ST(argvi) = sv_newmortal();
    SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_vector_Point_);
    XSRETURN(argvi);
}


XS(_wrap_PartitioningProblem_getTerminalToBlock) {
    PartitioningProblem *arg0 ;
    int argvi = 0;
    vector<unsigned> *result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: PartitioningProblem_getTerminalToBlock(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_PartitioningProblem) < 0) {
        croak("Type error in argument 1 of PartitioningProblem_getTerminalToBlock. Expected %s", SWIGTYPE_p_PartitioningProblem->name);
        XSRETURN(1);
    }
    vector<unsigned> const &_result_ref = arg0->getTerminalToBlock();
    result = (vector<unsigned> *) &_result_ref;
    ST(argvi) = sv_newmortal();
    SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_vector_unsigned_);
    XSRETURN(argvi);
}


XS(_wrap_PartitioningProblem_getNumPartitions) {
    PartitioningProblem *arg0 ;
    int argvi = 0;
    unsigned int result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: PartitioningProblem_getNumPartitions(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_PartitioningProblem) < 0) {
        croak("Type error in argument 1 of PartitioningProblem_getNumPartitions. Expected %s", SWIGTYPE_p_PartitioningProblem->name);
        XSRETURN(1);
    }
    result = (unsigned int )arg0->getNumPartitions();
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) result);
    XSRETURN(argvi);
}


XS(_wrap_PartitioningProblem_getBestSolnNum) {
    PartitioningProblem *arg0 ;
    int argvi = 0;
    unsigned int result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: PartitioningProblem_getBestSolnNum(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_PartitioningProblem) < 0) {
        croak("Type error in argument 1 of PartitioningProblem_getBestSolnNum. Expected %s", SWIGTYPE_p_PartitioningProblem->name);
        XSRETURN(1);
    }
    result = (unsigned int )arg0->getBestSolnNum();
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) result);
    XSRETURN(argvi);
}


XS(_wrap_PartitioningProblem_setBestSolnNum) {
    PartitioningProblem *arg0 ;
    unsigned int arg1 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) 
    croak("Usage: PartitioningProblem_setBestSolnNum(self,num);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_PartitioningProblem) < 0) {
        croak("Type error in argument 1 of PartitioningProblem_setBestSolnNum. Expected %s", SWIGTYPE_p_PartitioningProblem->name);
        XSRETURN(1);
    }
    arg1 = (unsigned int )SvIV(ST(1));
    arg0->setBestSolnNum(arg1);
    XSRETURN(argvi);
}


XS(_wrap_PartitioningProblem_printLargestCellStats) {
    PartitioningProblem *arg0 ;
    unsigned int arg1 = 10 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 1) || (items > 2)) 
    croak("Usage: PartitioningProblem_printLargestCellStats(self,N);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_PartitioningProblem) < 0) {
        croak("Type error in argument 1 of PartitioningProblem_printLargestCellStats. Expected %s", SWIGTYPE_p_PartitioningProblem->name);
        XSRETURN(1);
    }
    if (items > 1) {
        arg1 = (unsigned int )SvIV(ST(1));
    }
    arg0->printLargestCellStats(arg1);
    XSRETURN(argvi);
}


XS(_wrap_PartitioningProblem_getPinBalances) {
    PartitioningProblem *arg0 ;
    int argvi = 0;
    vector<unsigned> *result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: PartitioningProblem_getPinBalances(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_PartitioningProblem) < 0) {
        croak("Type error in argument 1 of PartitioningProblem_getPinBalances. Expected %s", SWIGTYPE_p_PartitioningProblem->name);
        XSRETURN(1);
    }
    result = new vector<unsigned> (arg0->getPinBalances());    ST(argvi) = sv_newmortal();
    SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_vector_unsigned_);
    XSRETURN(argvi);
}


XS(_wrap_PartitioningProblem_printPinBalances) {
    PartitioningProblem *arg0 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: PartitioningProblem_printPinBalances(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_PartitioningProblem) < 0) {
        croak("Type error in argument 1 of PartitioningProblem_printPinBalances. Expected %s", SWIGTYPE_p_PartitioningProblem->name);
        XSRETURN(1);
    }
    arg0->printPinBalances();
    XSRETURN(argvi);
}


XS(_wrap_PartitioningProblem_getAttributes) {
    PartitioningProblem *arg0 ;
    int argvi = 0;
    PartitioningProblem_Attributes *result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: PartitioningProblem_getAttributes(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_PartitioningProblem) < 0) {
        croak("Type error in argument 1 of PartitioningProblem_getAttributes. Expected %s", SWIGTYPE_p_PartitioningProblem->name);
        XSRETURN(1);
    }
    PartitioningProblem_Attributes const &_result_ref = arg0->getAttributes();
    result = (PartitioningProblem_Attributes *) &_result_ref;
    ST(argvi) = sv_newmortal();
    SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_PartitioningProblem_Attributes);
    XSRETURN(argvi);
}


XS(_wrap_PartitioningProblem_Parameters_verbosity_set) {
    PartitioningProblem_Parameters *arg0 ;
    Verbosity *arg1 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) 
    croak("Usage: PartitioningProblem_Parameters_verbosity_set(self,value);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_PartitioningProblem_Parameters) < 0) {
        croak("Type error in argument 1 of PartitioningProblem_Parameters_verbosity_set. Expected %s", SWIGTYPE_p_PartitioningProblem_Parameters->name);
        XSRETURN(1);
    }
    if (SWIG_ConvertPtr(ST(1),(void **) &arg1,SWIGTYPE_p_Verbosity) < 0) {
        croak("Type error in argument 2 of PartitioningProblem_Parameters_verbosity_set. Expected %s", SWIGTYPE_p_Verbosity->name);
        XSRETURN(1);
    }
    arg0->verbosity = *arg1;
    XSRETURN(argvi);
}


XS(_wrap_PartitioningProblem_Parameters_verbosity_get) {
    PartitioningProblem_Parameters *arg0 ;
    int argvi = 0;
    Verbosity *result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: PartitioningProblem_Parameters_verbosity_get(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_PartitioningProblem_Parameters) < 0) {
        croak("Type error in argument 1 of PartitioningProblem_Parameters_verbosity_get. Expected %s", SWIGTYPE_p_PartitioningProblem_Parameters->name);
        XSRETURN(1);
    }
    result = (Verbosity *)& (arg0->verbosity);
    ST(argvi) = sv_newmortal();
    SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_Verbosity);
    XSRETURN(argvi);
}


XS(_wrap_new_PartitioningProblem_Parameters) {
    int arg0 ;
    char **arg1 ;
    int n_arg ;
    int argvi = 0;
    PartitioningProblem_Parameters *result ;
    dXSARGS;
    
    {
        arg0=n_arg=items;
        items=1;
    }
    if ((items < 1) || (items > 1)) 
    croak("Usage: new_PartitioningProblem_Parameters(argv);");
    {
        arg1 = (char **)
        malloc(n_arg*sizeof(char *));
        for (; n_arg; --n_arg) {
            arg1[n_arg-1]=
            (char *)SvPV(ST(n_arg-1),PL_na);
        }
    }
    result = (PartitioningProblem_Parameters *)new PartitioningProblem_Parameters(arg0,(char const **)arg1);
    ST(argvi) = sv_newmortal();
    SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_PartitioningProblem_Parameters);
    XSRETURN(argvi);
}


XS(_wrap_PartitioningProblem_Attributes_hasMaxCap_set) {
    PartitioningProblem_Attributes *arg0 ;
    unsigned char arg1 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) 
    croak("Usage: PartitioningProblem_Attributes_hasMaxCap_set(self,value);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_PartitioningProblem_Attributes) < 0) {
        croak("Type error in argument 1 of PartitioningProblem_Attributes_hasMaxCap_set. Expected %s", SWIGTYPE_p_PartitioningProblem_Attributes->name);
        XSRETURN(1);
    }
    arg1 = (unsigned char )SvIV(ST(1));
    arg0->hasMaxCap = arg1;
    XSRETURN(argvi);
}


XS(_wrap_PartitioningProblem_Attributes_hasMaxCap_get) {
    PartitioningProblem_Attributes *arg0 ;
    int argvi = 0;
    unsigned char result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: PartitioningProblem_Attributes_hasMaxCap_get(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_PartitioningProblem_Attributes) < 0) {
        croak("Type error in argument 1 of PartitioningProblem_Attributes_hasMaxCap_get. Expected %s", SWIGTYPE_p_PartitioningProblem_Attributes->name);
        XSRETURN(1);
    }
    result = (unsigned char ) (arg0->hasMaxCap);
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) result);
    XSRETURN(argvi);
}


XS(_wrap_PartitioningProblem_Attributes_hasMinCap_set) {
    PartitioningProblem_Attributes *arg0 ;
    unsigned char arg1 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) 
    croak("Usage: PartitioningProblem_Attributes_hasMinCap_set(self,value);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_PartitioningProblem_Attributes) < 0) {
        croak("Type error in argument 1 of PartitioningProblem_Attributes_hasMinCap_set. Expected %s", SWIGTYPE_p_PartitioningProblem_Attributes->name);
        XSRETURN(1);
    }
    arg1 = (unsigned char )SvIV(ST(1));
    arg0->hasMinCap = arg1;
    XSRETURN(argvi);
}


XS(_wrap_PartitioningProblem_Attributes_hasMinCap_get) {
    PartitioningProblem_Attributes *arg0 ;
    int argvi = 0;
    unsigned char result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: PartitioningProblem_Attributes_hasMinCap_get(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_PartitioningProblem_Attributes) < 0) {
        croak("Type error in argument 1 of PartitioningProblem_Attributes_hasMinCap_get. Expected %s", SWIGTYPE_p_PartitioningProblem_Attributes->name);
        XSRETURN(1);
    }
    result = (unsigned char ) (arg0->hasMinCap);
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) result);
    XSRETURN(argvi);
}


XS(_wrap_PartitioningProblem_Attributes_hasCap_set) {
    PartitioningProblem_Attributes *arg0 ;
    unsigned char arg1 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) 
    croak("Usage: PartitioningProblem_Attributes_hasCap_set(self,value);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_PartitioningProblem_Attributes) < 0) {
        croak("Type error in argument 1 of PartitioningProblem_Attributes_hasCap_set. Expected %s", SWIGTYPE_p_PartitioningProblem_Attributes->name);
        XSRETURN(1);
    }
    arg1 = (unsigned char )SvIV(ST(1));
    arg0->hasCap = arg1;
    XSRETURN(argvi);
}


XS(_wrap_PartitioningProblem_Attributes_hasCap_get) {
    PartitioningProblem_Attributes *arg0 ;
    int argvi = 0;
    unsigned char result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: PartitioningProblem_Attributes_hasCap_get(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_PartitioningProblem_Attributes) < 0) {
        croak("Type error in argument 1 of PartitioningProblem_Attributes_hasCap_get. Expected %s", SWIGTYPE_p_PartitioningProblem_Attributes->name);
        XSRETURN(1);
    }
    result = (unsigned char ) (arg0->hasCap);
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) result);
    XSRETURN(argvi);
}


XS(_wrap_PartitioningProblem_Attributes_hasPartBBoxes_set) {
    PartitioningProblem_Attributes *arg0 ;
    unsigned char arg1 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) 
    croak("Usage: PartitioningProblem_Attributes_hasPartBBoxes_set(self,value);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_PartitioningProblem_Attributes) < 0) {
        croak("Type error in argument 1 of PartitioningProblem_Attributes_hasPartBBoxes_set. Expected %s", SWIGTYPE_p_PartitioningProblem_Attributes->name);
        XSRETURN(1);
    }
    arg1 = (unsigned char )SvIV(ST(1));
    arg0->hasPartBBoxes = arg1;
    XSRETURN(argvi);
}


XS(_wrap_PartitioningProblem_Attributes_hasPartBBoxes_get) {
    PartitioningProblem_Attributes *arg0 ;
    int argvi = 0;
    unsigned char result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: PartitioningProblem_Attributes_hasPartBBoxes_get(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_PartitioningProblem_Attributes) < 0) {
        croak("Type error in argument 1 of PartitioningProblem_Attributes_hasPartBBoxes_get. Expected %s", SWIGTYPE_p_PartitioningProblem_Attributes->name);
        XSRETURN(1);
    }
    result = (unsigned char ) (arg0->hasPartBBoxes);
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) result);
    XSRETURN(argvi);
}


XS(_wrap_PartitioningProblem_Attributes_hasPadBBoxes_set) {
    PartitioningProblem_Attributes *arg0 ;
    unsigned char arg1 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) 
    croak("Usage: PartitioningProblem_Attributes_hasPadBBoxes_set(self,value);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_PartitioningProblem_Attributes) < 0) {
        croak("Type error in argument 1 of PartitioningProblem_Attributes_hasPadBBoxes_set. Expected %s", SWIGTYPE_p_PartitioningProblem_Attributes->name);
        XSRETURN(1);
    }
    arg1 = (unsigned char )SvIV(ST(1));
    arg0->hasPadBBoxes = arg1;
    XSRETURN(argvi);
}


XS(_wrap_PartitioningProblem_Attributes_hasPadBBoxes_get) {
    PartitioningProblem_Attributes *arg0 ;
    int argvi = 0;
    unsigned char result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: PartitioningProblem_Attributes_hasPadBBoxes_get(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_PartitioningProblem_Attributes) < 0) {
        croak("Type error in argument 1 of PartitioningProblem_Attributes_hasPadBBoxes_get. Expected %s", SWIGTYPE_p_PartitioningProblem_Attributes->name);
        XSRETURN(1);
    }
    result = (unsigned char ) (arg0->hasPadBBoxes);
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) result);
    XSRETURN(argvi);
}


XS(_wrap_PartitioningProblem_Attributes_hasPartCenters_set) {
    PartitioningProblem_Attributes *arg0 ;
    unsigned char arg1 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) 
    croak("Usage: PartitioningProblem_Attributes_hasPartCenters_set(self,value);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_PartitioningProblem_Attributes) < 0) {
        croak("Type error in argument 1 of PartitioningProblem_Attributes_hasPartCenters_set. Expected %s", SWIGTYPE_p_PartitioningProblem_Attributes->name);
        XSRETURN(1);
    }
    arg1 = (unsigned char )SvIV(ST(1));
    arg0->hasPartCenters = arg1;
    XSRETURN(argvi);
}


XS(_wrap_PartitioningProblem_Attributes_hasPartCenters_get) {
    PartitioningProblem_Attributes *arg0 ;
    int argvi = 0;
    unsigned char result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: PartitioningProblem_Attributes_hasPartCenters_get(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_PartitioningProblem_Attributes) < 0) {
        croak("Type error in argument 1 of PartitioningProblem_Attributes_hasPartCenters_get. Expected %s", SWIGTYPE_p_PartitioningProblem_Attributes->name);
        XSRETURN(1);
    }
    result = (unsigned char ) (arg0->hasPartCenters);
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) result);
    XSRETURN(argvi);
}


XS(_wrap_PartitioningProblem_Attributes_hasPadCenters_set) {
    PartitioningProblem_Attributes *arg0 ;
    unsigned char arg1 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) 
    croak("Usage: PartitioningProblem_Attributes_hasPadCenters_set(self,value);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_PartitioningProblem_Attributes) < 0) {
        croak("Type error in argument 1 of PartitioningProblem_Attributes_hasPadCenters_set. Expected %s", SWIGTYPE_p_PartitioningProblem_Attributes->name);
        XSRETURN(1);
    }
    arg1 = (unsigned char )SvIV(ST(1));
    arg0->hasPadCenters = arg1;
    XSRETURN(argvi);
}


XS(_wrap_PartitioningProblem_Attributes_hasPadCenters_get) {
    PartitioningProblem_Attributes *arg0 ;
    int argvi = 0;
    unsigned char result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: PartitioningProblem_Attributes_hasPadCenters_get(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_PartitioningProblem_Attributes) < 0) {
        croak("Type error in argument 1 of PartitioningProblem_Attributes_hasPadCenters_get. Expected %s", SWIGTYPE_p_PartitioningProblem_Attributes->name);
        XSRETURN(1);
    }
    result = (unsigned char ) (arg0->hasPadCenters);
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) result);
    XSRETURN(argvi);
}


XS(_wrap_PartitioningProblem_Attributes_hasTotalWeight_set) {
    PartitioningProblem_Attributes *arg0 ;
    unsigned char arg1 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) 
    croak("Usage: PartitioningProblem_Attributes_hasTotalWeight_set(self,value);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_PartitioningProblem_Attributes) < 0) {
        croak("Type error in argument 1 of PartitioningProblem_Attributes_hasTotalWeight_set. Expected %s", SWIGTYPE_p_PartitioningProblem_Attributes->name);
        XSRETURN(1);
    }
    arg1 = (unsigned char )SvIV(ST(1));
    arg0->hasTotalWeight = arg1;
    XSRETURN(argvi);
}


XS(_wrap_PartitioningProblem_Attributes_hasTotalWeight_get) {
    PartitioningProblem_Attributes *arg0 ;
    int argvi = 0;
    unsigned char result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: PartitioningProblem_Attributes_hasTotalWeight_get(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_PartitioningProblem_Attributes) < 0) {
        croak("Type error in argument 1 of PartitioningProblem_Attributes_hasTotalWeight_get. Expected %s", SWIGTYPE_p_PartitioningProblem_Attributes->name);
        XSRETURN(1);
    }
    result = (unsigned char ) (arg0->hasTotalWeight);
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) result);
    XSRETURN(argvi);
}


XS(_wrap_PartitioningProblem_Attributes_hasClusterDegrees_set) {
    PartitioningProblem_Attributes *arg0 ;
    unsigned char arg1 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) 
    croak("Usage: PartitioningProblem_Attributes_hasClusterDegrees_set(self,value);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_PartitioningProblem_Attributes) < 0) {
        croak("Type error in argument 1 of PartitioningProblem_Attributes_hasClusterDegrees_set. Expected %s", SWIGTYPE_p_PartitioningProblem_Attributes->name);
        XSRETURN(1);
    }
    arg1 = (unsigned char )SvIV(ST(1));
    arg0->hasClusterDegrees = arg1;
    XSRETURN(argvi);
}


XS(_wrap_PartitioningProblem_Attributes_hasClusterDegrees_get) {
    PartitioningProblem_Attributes *arg0 ;
    int argvi = 0;
    unsigned char result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: PartitioningProblem_Attributes_hasClusterDegrees_get(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_PartitioningProblem_Attributes) < 0) {
        croak("Type error in argument 1 of PartitioningProblem_Attributes_hasClusterDegrees_get. Expected %s", SWIGTYPE_p_PartitioningProblem_Attributes->name);
        XSRETURN(1);
    }
    result = (unsigned char ) (arg0->hasClusterDegrees);
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) result);
    XSRETURN(argvi);
}


XS(_wrap_new_PartitioningProblem_Attributes) {
    int argvi = 0;
    PartitioningProblem_Attributes *result ;
    dXSARGS;
    
    if ((items < 0) || (items > 0)) 
    croak("Usage: new_PartitioningProblem_Attributes();");
    result = (PartitioningProblem_Attributes *)new PartitioningProblem_Attributes();
    ST(argvi) = sv_newmortal();
    SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_PartitioningProblem_Attributes);
    XSRETURN(argvi);
}


XS(_wrap_PartitioningProblem_Attributes_clearAll) {
    PartitioningProblem_Attributes *arg0 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: PartitioningProblem_Attributes_clearAll(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_PartitioningProblem_Attributes) < 0) {
        croak("Type error in argument 1 of PartitioningProblem_Attributes_clearAll. Expected %s", SWIGTYPE_p_PartitioningProblem_Attributes->name);
        XSRETURN(1);
    }
    arg0->clearAll();
    XSRETURN(argvi);
}


XS(_wrap_PartitioningProblem_Attributes_setAll) {
    PartitioningProblem_Attributes *arg0 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: PartitioningProblem_Attributes_setAll(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_PartitioningProblem_Attributes) < 0) {
        croak("Type error in argument 1 of PartitioningProblem_Attributes_setAll. Expected %s", SWIGTYPE_p_PartitioningProblem_Attributes->name);
        XSRETURN(1);
    }
    arg0->setAll();
    XSRETURN(argvi);
}


XS(_wrap_new_BaseMLPart) {
    PartitioningProblem *arg0 ;
    BaseMLPart_Parameters *arg1 ;
    FillableHierarchy *arg2 = NULL ;
    int argvi = 0;
    BaseMLPart *result ;
    dXSARGS;
    
    if ((items < 2) || (items > 3)) 
    croak("Usage: new_BaseMLPart(problem,params,hier);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_PartitioningProblem) < 0) {
        croak("Type error in argument 1 of new_BaseMLPart. Expected %s", SWIGTYPE_p_PartitioningProblem->name);
        XSRETURN(1);
    }
    if (SWIG_ConvertPtr(ST(1),(void **) &arg1,SWIGTYPE_p_BaseMLPart_Parameters) < 0) {
        croak("Type error in argument 2 of new_BaseMLPart. Expected %s", SWIGTYPE_p_BaseMLPart_Parameters->name);
        XSRETURN(1);
    }
    if (items > 2) {
        if (SWIG_ConvertPtr(ST(2),(void **) &arg2,SWIGTYPE_p_FillableHierarchy) < 0) {
            croak("Type error in argument 3 of new_BaseMLPart. Expected %s", SWIGTYPE_p_FillableHierarchy->name);
            XSRETURN(1);
        }
    }
    result = (BaseMLPart *)new BaseMLPart(*arg0,(BaseMLPart_Parameters const &)*arg1,arg2);
    ST(argvi) = sv_newmortal();
    SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_BaseMLPart);
    XSRETURN(argvi);
}


XS(_wrap_delete_BaseMLPart) {
    BaseMLPart *arg0 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: delete_BaseMLPart(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_BaseMLPart) < 0) {
        croak("Type error in argument 1 of delete_BaseMLPart. Expected %s", SWIGTYPE_p_BaseMLPart->name);
        XSRETURN(1);
    }
    delete arg0;
    XSRETURN(argvi);
}


XS(_wrap_BaseMLPart_getPartitionArea) {
    BaseMLPart *arg0 ;
    unsigned int arg1 ;
    int argvi = 0;
    double result ;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) 
    croak("Usage: BaseMLPart_getPartitionArea(self,partNumber);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_BaseMLPart) < 0) {
        croak("Type error in argument 1 of BaseMLPart_getPartitionArea. Expected %s", SWIGTYPE_p_BaseMLPart->name);
        XSRETURN(1);
    }
    arg1 = (unsigned int )SvIV(ST(1));
    result = (double )arg0->getPartitionArea(arg1);
    ST(argvi) = sv_newmortal();
    sv_setnv(ST(argvi++), (double) result);
    XSRETURN(argvi);
}


XS(_wrap_BaseMLPart_getPartitionRatio) {
    BaseMLPart *arg0 ;
    unsigned int arg1 ;
    int argvi = 0;
    double result ;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) 
    croak("Usage: BaseMLPart_getPartitionRatio(self,partNumber);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_BaseMLPart) < 0) {
        croak("Type error in argument 1 of BaseMLPart_getPartitionRatio. Expected %s", SWIGTYPE_p_BaseMLPart->name);
        XSRETURN(1);
    }
    arg1 = (unsigned int )SvIV(ST(1));
    result = (double )arg0->getPartitionRatio(arg1);
    ST(argvi) = sv_newmortal();
    sv_setnv(ST(argvi++), (double) result);
    XSRETURN(argvi);
}


XS(_wrap_BaseMLPart_getBestSolnCost) {
    BaseMLPart *arg0 ;
    int argvi = 0;
    double result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: BaseMLPart_getBestSolnCost(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_BaseMLPart) < 0) {
        croak("Type error in argument 1 of BaseMLPart_getBestSolnCost. Expected %s", SWIGTYPE_p_BaseMLPart->name);
        XSRETURN(1);
    }
    result = (double )arg0->getBestSolnCost();
    ST(argvi) = sv_newmortal();
    sv_setnv(ST(argvi++), (double) result);
    XSRETURN(argvi);
}


XS(_wrap_BaseMLPart_getAveSolnCost) {
    BaseMLPart *arg0 ;
    int argvi = 0;
    double result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: BaseMLPart_getAveSolnCost(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_BaseMLPart) < 0) {
        croak("Type error in argument 1 of BaseMLPart_getAveSolnCost. Expected %s", SWIGTYPE_p_BaseMLPart->name);
        XSRETURN(1);
    }
    result = (double )arg0->getAveSolnCost();
    ST(argvi) = sv_newmortal();
    sv_setnv(ST(argvi++), (double) result);
    XSRETURN(argvi);
}


XS(_wrap_BaseMLPart_getNumLegalSolns) {
    BaseMLPart *arg0 ;
    int argvi = 0;
    unsigned int result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: BaseMLPart_getNumLegalSolns(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_BaseMLPart) < 0) {
        croak("Type error in argument 1 of BaseMLPart_getNumLegalSolns. Expected %s", SWIGTYPE_p_BaseMLPart->name);
        XSRETURN(1);
    }
    result = (unsigned int )arg0->getNumLegalSolns();
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) result);
    XSRETURN(argvi);
}


XS(_wrap_BaseMLPart_getUserTime) {
    BaseMLPart *arg0 ;
    int argvi = 0;
    double result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: BaseMLPart_getUserTime(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_BaseMLPart) < 0) {
        croak("Type error in argument 1 of BaseMLPart_getUserTime. Expected %s", SWIGTYPE_p_BaseMLPart->name);
        XSRETURN(1);
    }
    result = (double )arg0->getUserTime();
    ST(argvi) = sv_newmortal();
    sv_setnv(ST(argvi++), (double) result);
    XSRETURN(argvi);
}


XS(_wrap_BaseMLPart_Parameters_savePartProb_set) {
    BaseMLPart_Parameters *arg0 ;
    int arg1 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) 
    croak("Usage: BaseMLPart_Parameters_savePartProb_set(self,value);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_BaseMLPart_Parameters) < 0) {
        croak("Type error in argument 1 of BaseMLPart_Parameters_savePartProb_set. Expected %s", SWIGTYPE_p_BaseMLPart_Parameters->name);
        XSRETURN(1);
    }
    arg1 = (int )SvIV(ST(1));
    arg0->savePartProb = (BaseMLPart_Parameters::SavePartProb )arg1;
    XSRETURN(argvi);
}


XS(_wrap_BaseMLPart_Parameters_savePartProb_get) {
    BaseMLPart_Parameters *arg0 ;
    int argvi = 0;
    int result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: BaseMLPart_Parameters_savePartProb_get(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_BaseMLPart_Parameters) < 0) {
        croak("Type error in argument 1 of BaseMLPart_Parameters_savePartProb_get. Expected %s", SWIGTYPE_p_BaseMLPart_Parameters->name);
        XSRETURN(1);
    }
    result = (int ) (arg0->savePartProb);
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) result);
    XSRETURN(argvi);
}


XS(_wrap_BaseMLPart_Parameters_flatPartitioner_set) {
    BaseMLPart_Parameters *arg0 ;
    PartitionerType *arg1 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) 
    croak("Usage: BaseMLPart_Parameters_flatPartitioner_set(self,value);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_BaseMLPart_Parameters) < 0) {
        croak("Type error in argument 1 of BaseMLPart_Parameters_flatPartitioner_set. Expected %s", SWIGTYPE_p_BaseMLPart_Parameters->name);
        XSRETURN(1);
    }
    if (SWIG_ConvertPtr(ST(1),(void **) &arg1,SWIGTYPE_p_PartitionerType) < 0) {
        croak("Type error in argument 2 of BaseMLPart_Parameters_flatPartitioner_set. Expected %s", SWIGTYPE_p_PartitionerType->name);
        XSRETURN(1);
    }
    arg0->flatPartitioner = *arg1;
    XSRETURN(argvi);
}


XS(_wrap_BaseMLPart_Parameters_flatPartitioner_get) {
    BaseMLPart_Parameters *arg0 ;
    int argvi = 0;
    PartitionerType *result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: BaseMLPart_Parameters_flatPartitioner_get(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_BaseMLPart_Parameters) < 0) {
        croak("Type error in argument 1 of BaseMLPart_Parameters_flatPartitioner_get. Expected %s", SWIGTYPE_p_BaseMLPart_Parameters->name);
        XSRETURN(1);
    }
    result = (PartitionerType *)& (arg0->flatPartitioner);
    ST(argvi) = sv_newmortal();
    SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_PartitionerType);
    XSRETURN(argvi);
}


XS(_wrap_BaseMLPart_Parameters_useBBonTop_set) {
    BaseMLPart_Parameters *arg0 ;
    bool arg1 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) 
    croak("Usage: BaseMLPart_Parameters_useBBonTop_set(self,value);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_BaseMLPart_Parameters) < 0) {
        croak("Type error in argument 1 of BaseMLPart_Parameters_useBBonTop_set. Expected %s", SWIGTYPE_p_BaseMLPart_Parameters->name);
        XSRETURN(1);
    }
    arg1 = (bool )SvIV(ST(1));
    arg0->useBBonTop = arg1;
    XSRETURN(argvi);
}


XS(_wrap_BaseMLPart_Parameters_useBBonTop_get) {
    BaseMLPart_Parameters *arg0 ;
    int argvi = 0;
    bool result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: BaseMLPart_Parameters_useBBonTop_get(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_BaseMLPart_Parameters) < 0) {
        croak("Type error in argument 1 of BaseMLPart_Parameters_useBBonTop_get. Expected %s", SWIGTYPE_p_BaseMLPart_Parameters->name);
        XSRETURN(1);
    }
    result = (bool ) (arg0->useBBonTop);
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) result);
    XSRETURN(argvi);
}


XS(_wrap_BaseMLPart_Parameters_partFuzziness_set) {
    BaseMLPart_Parameters *arg0 ;
    double arg1 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) 
    croak("Usage: BaseMLPart_Parameters_partFuzziness_set(self,value);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_BaseMLPart_Parameters) < 0) {
        croak("Type error in argument 1 of BaseMLPart_Parameters_partFuzziness_set. Expected %s", SWIGTYPE_p_BaseMLPart_Parameters->name);
        XSRETURN(1);
    }
    arg1 = (double )SvNV(ST(1));
    arg0->partFuzziness = arg1;
    XSRETURN(argvi);
}


XS(_wrap_BaseMLPart_Parameters_partFuzziness_get) {
    BaseMLPart_Parameters *arg0 ;
    int argvi = 0;
    double result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: BaseMLPart_Parameters_partFuzziness_get(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_BaseMLPart_Parameters) < 0) {
        croak("Type error in argument 1 of BaseMLPart_Parameters_partFuzziness_get. Expected %s", SWIGTYPE_p_BaseMLPart_Parameters->name);
        XSRETURN(1);
    }
    result = (double ) (arg0->partFuzziness);
    ST(argvi) = sv_newmortal();
    sv_setnv(ST(argvi++), (double) result);
    XSRETURN(argvi);
}


XS(_wrap_BaseMLPart_Parameters_runsPerClTree_set) {
    BaseMLPart_Parameters *arg0 ;
    unsigned int arg1 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) 
    croak("Usage: BaseMLPart_Parameters_runsPerClTree_set(self,value);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_BaseMLPart_Parameters) < 0) {
        croak("Type error in argument 1 of BaseMLPart_Parameters_runsPerClTree_set. Expected %s", SWIGTYPE_p_BaseMLPart_Parameters->name);
        XSRETURN(1);
    }
    arg1 = (unsigned int )SvIV(ST(1));
    arg0->runsPerClTree = arg1;
    XSRETURN(argvi);
}


XS(_wrap_BaseMLPart_Parameters_runsPerClTree_get) {
    BaseMLPart_Parameters *arg0 ;
    int argvi = 0;
    unsigned int result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: BaseMLPart_Parameters_runsPerClTree_get(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_BaseMLPart_Parameters) < 0) {
        croak("Type error in argument 1 of BaseMLPart_Parameters_runsPerClTree_get. Expected %s", SWIGTYPE_p_BaseMLPart_Parameters->name);
        XSRETURN(1);
    }
    result = (unsigned int ) (arg0->runsPerClTree);
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) result);
    XSRETURN(argvi);
}


XS(_wrap_BaseMLPart_Parameters_solnPoolOnTopLevel_set) {
    BaseMLPart_Parameters *arg0 ;
    unsigned int arg1 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) 
    croak("Usage: BaseMLPart_Parameters_solnPoolOnTopLevel_set(self,value);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_BaseMLPart_Parameters) < 0) {
        croak("Type error in argument 1 of BaseMLPart_Parameters_solnPoolOnTopLevel_set. Expected %s", SWIGTYPE_p_BaseMLPart_Parameters->name);
        XSRETURN(1);
    }
    arg1 = (unsigned int )SvIV(ST(1));
    arg0->solnPoolOnTopLevel = arg1;
    XSRETURN(argvi);
}


XS(_wrap_BaseMLPart_Parameters_solnPoolOnTopLevel_get) {
    BaseMLPart_Parameters *arg0 ;
    int argvi = 0;
    unsigned int result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: BaseMLPart_Parameters_solnPoolOnTopLevel_get(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_BaseMLPart_Parameters) < 0) {
        croak("Type error in argument 1 of BaseMLPart_Parameters_solnPoolOnTopLevel_get. Expected %s", SWIGTYPE_p_BaseMLPart_Parameters->name);
        XSRETURN(1);
    }
    result = (unsigned int ) (arg0->solnPoolOnTopLevel);
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) result);
    XSRETURN(argvi);
}


XS(_wrap_BaseMLPart_Parameters_toleranceMultiple_set) {
    BaseMLPart_Parameters *arg0 ;
    double arg1 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) 
    croak("Usage: BaseMLPart_Parameters_toleranceMultiple_set(self,value);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_BaseMLPart_Parameters) < 0) {
        croak("Type error in argument 1 of BaseMLPart_Parameters_toleranceMultiple_set. Expected %s", SWIGTYPE_p_BaseMLPart_Parameters->name);
        XSRETURN(1);
    }
    arg1 = (double )SvNV(ST(1));
    arg0->toleranceMultiple = arg1;
    XSRETURN(argvi);
}


XS(_wrap_BaseMLPart_Parameters_toleranceMultiple_get) {
    BaseMLPart_Parameters *arg0 ;
    int argvi = 0;
    double result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: BaseMLPart_Parameters_toleranceMultiple_get(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_BaseMLPart_Parameters) < 0) {
        croak("Type error in argument 1 of BaseMLPart_Parameters_toleranceMultiple_get. Expected %s", SWIGTYPE_p_BaseMLPart_Parameters->name);
        XSRETURN(1);
    }
    result = (double ) (arg0->toleranceMultiple);
    ST(argvi) = sv_newmortal();
    sv_setnv(ST(argvi++), (double) result);
    XSRETURN(argvi);
}


XS(_wrap_BaseMLPart_Parameters_toleranceAlpha_set) {
    BaseMLPart_Parameters *arg0 ;
    double arg1 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) 
    croak("Usage: BaseMLPart_Parameters_toleranceAlpha_set(self,value);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_BaseMLPart_Parameters) < 0) {
        croak("Type error in argument 1 of BaseMLPart_Parameters_toleranceAlpha_set. Expected %s", SWIGTYPE_p_BaseMLPart_Parameters->name);
        XSRETURN(1);
    }
    arg1 = (double )SvNV(ST(1));
    arg0->toleranceAlpha = arg1;
    XSRETURN(argvi);
}


XS(_wrap_BaseMLPart_Parameters_toleranceAlpha_get) {
    BaseMLPart_Parameters *arg0 ;
    int argvi = 0;
    double result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: BaseMLPart_Parameters_toleranceAlpha_get(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_BaseMLPart_Parameters) < 0) {
        croak("Type error in argument 1 of BaseMLPart_Parameters_toleranceAlpha_get. Expected %s", SWIGTYPE_p_BaseMLPart_Parameters->name);
        XSRETURN(1);
    }
    result = (double ) (arg0->toleranceAlpha);
    ST(argvi) = sv_newmortal();
    sv_setnv(ST(argvi++), (double) result);
    XSRETURN(argvi);
}


XS(_wrap_BaseMLPart_Parameters_useTwoPartCalls_set) {
    BaseMLPart_Parameters *arg0 ;
    int arg1 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) 
    croak("Usage: BaseMLPart_Parameters_useTwoPartCalls_set(self,value);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_BaseMLPart_Parameters) < 0) {
        croak("Type error in argument 1 of BaseMLPart_Parameters_useTwoPartCalls_set. Expected %s", SWIGTYPE_p_BaseMLPart_Parameters->name);
        XSRETURN(1);
    }
    arg1 = (int )SvIV(ST(1));
    arg0->useTwoPartCalls = (BaseMLPart_Parameters::TwoPartCalls )arg1;
    XSRETURN(argvi);
}


XS(_wrap_BaseMLPart_Parameters_useTwoPartCalls_get) {
    BaseMLPart_Parameters *arg0 ;
    int argvi = 0;
    int result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: BaseMLPart_Parameters_useTwoPartCalls_get(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_BaseMLPart_Parameters) < 0) {
        croak("Type error in argument 1 of BaseMLPart_Parameters_useTwoPartCalls_get. Expected %s", SWIGTYPE_p_BaseMLPart_Parameters->name);
        XSRETURN(1);
    }
    result = (int ) (arg0->useTwoPartCalls);
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) result);
    XSRETURN(argvi);
}


XS(_wrap_BaseMLPart_Parameters_netThreshold_set) {
    BaseMLPart_Parameters *arg0 ;
    unsigned int arg1 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) 
    croak("Usage: BaseMLPart_Parameters_netThreshold_set(self,value);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_BaseMLPart_Parameters) < 0) {
        croak("Type error in argument 1 of BaseMLPart_Parameters_netThreshold_set. Expected %s", SWIGTYPE_p_BaseMLPart_Parameters->name);
        XSRETURN(1);
    }
    arg1 = (unsigned int )SvIV(ST(1));
    arg0->netThreshold = arg1;
    XSRETURN(argvi);
}


XS(_wrap_BaseMLPart_Parameters_netThreshold_get) {
    BaseMLPart_Parameters *arg0 ;
    int argvi = 0;
    unsigned int result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: BaseMLPart_Parameters_netThreshold_get(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_BaseMLPart_Parameters) < 0) {
        croak("Type error in argument 1 of BaseMLPart_Parameters_netThreshold_get. Expected %s", SWIGTYPE_p_BaseMLPart_Parameters->name);
        XSRETURN(1);
    }
    result = (unsigned int ) (arg0->netThreshold);
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) result);
    XSRETURN(argvi);
}


XS(_wrap_BaseMLPart_Parameters_Vcycling_set) {
    BaseMLPart_Parameters *arg0 ;
    int arg1 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) 
    croak("Usage: BaseMLPart_Parameters_Vcycling_set(self,value);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_BaseMLPart_Parameters) < 0) {
        croak("Type error in argument 1 of BaseMLPart_Parameters_Vcycling_set. Expected %s", SWIGTYPE_p_BaseMLPart_Parameters->name);
        XSRETURN(1);
    }
    arg1 = (int )SvIV(ST(1));
    arg0->Vcycling = (BaseMLPart_Parameters::VcyclType )arg1;
    XSRETURN(argvi);
}


XS(_wrap_BaseMLPart_Parameters_Vcycling_get) {
    BaseMLPart_Parameters *arg0 ;
    int argvi = 0;
    int result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: BaseMLPart_Parameters_Vcycling_get(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_BaseMLPart_Parameters) < 0) {
        croak("Type error in argument 1 of BaseMLPart_Parameters_Vcycling_get. Expected %s", SWIGTYPE_p_BaseMLPart_Parameters->name);
        XSRETURN(1);
    }
    result = (int ) (arg0->Vcycling);
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) result);
    XSRETURN(argvi);
}


XS(_wrap_BaseMLPart_Parameters_timeLimit_set) {
    BaseMLPart_Parameters *arg0 ;
    unsigned int arg1 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) 
    croak("Usage: BaseMLPart_Parameters_timeLimit_set(self,value);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_BaseMLPart_Parameters) < 0) {
        croak("Type error in argument 1 of BaseMLPart_Parameters_timeLimit_set. Expected %s", SWIGTYPE_p_BaseMLPart_Parameters->name);
        XSRETURN(1);
    }
    arg1 = (unsigned int )SvIV(ST(1));
    arg0->timeLimit = arg1;
    XSRETURN(argvi);
}


XS(_wrap_BaseMLPart_Parameters_timeLimit_get) {
    BaseMLPart_Parameters *arg0 ;
    int argvi = 0;
    unsigned int result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: BaseMLPart_Parameters_timeLimit_get(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_BaseMLPart_Parameters) < 0) {
        croak("Type error in argument 1 of BaseMLPart_Parameters_timeLimit_get. Expected %s", SWIGTYPE_p_BaseMLPart_Parameters->name);
        XSRETURN(1);
    }
    result = (unsigned int ) (arg0->timeLimit);
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) result);
    XSRETURN(argvi);
}


XS(_wrap_BaseMLPart_Parameters_expPrint2Costs_set) {
    BaseMLPart_Parameters *arg0 ;
    bool arg1 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) 
    croak("Usage: BaseMLPart_Parameters_expPrint2Costs_set(self,value);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_BaseMLPart_Parameters) < 0) {
        croak("Type error in argument 1 of BaseMLPart_Parameters_expPrint2Costs_set. Expected %s", SWIGTYPE_p_BaseMLPart_Parameters->name);
        XSRETURN(1);
    }
    arg1 = (bool )SvIV(ST(1));
    arg0->expPrint2Costs = arg1;
    XSRETURN(argvi);
}


XS(_wrap_BaseMLPart_Parameters_expPrint2Costs_get) {
    BaseMLPart_Parameters *arg0 ;
    int argvi = 0;
    bool result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: BaseMLPart_Parameters_expPrint2Costs_get(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_BaseMLPart_Parameters) < 0) {
        croak("Type error in argument 1 of BaseMLPart_Parameters_expPrint2Costs_get. Expected %s", SWIGTYPE_p_BaseMLPart_Parameters->name);
        XSRETURN(1);
    }
    result = (bool ) (arg0->expPrint2Costs);
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) result);
    XSRETURN(argvi);
}


XS(_wrap_BaseMLPart_Parameters_clusterToTerminals_set) {
    BaseMLPart_Parameters *arg0 ;
    bool arg1 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) 
    croak("Usage: BaseMLPart_Parameters_clusterToTerminals_set(self,value);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_BaseMLPart_Parameters) < 0) {
        croak("Type error in argument 1 of BaseMLPart_Parameters_clusterToTerminals_set. Expected %s", SWIGTYPE_p_BaseMLPart_Parameters->name);
        XSRETURN(1);
    }
    arg1 = (bool )SvIV(ST(1));
    arg0->clusterToTerminals = arg1;
    XSRETURN(argvi);
}


XS(_wrap_BaseMLPart_Parameters_clusterToTerminals_get) {
    BaseMLPart_Parameters *arg0 ;
    int argvi = 0;
    bool result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: BaseMLPart_Parameters_clusterToTerminals_get(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_BaseMLPart_Parameters) < 0) {
        croak("Type error in argument 1 of BaseMLPart_Parameters_clusterToTerminals_get. Expected %s", SWIGTYPE_p_BaseMLPart_Parameters->name);
        XSRETURN(1);
    }
    result = (bool ) (arg0->clusterToTerminals);
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) result);
    XSRETURN(argvi);
}


XS(_wrap_BaseMLPart_Parameters_seedTopLvlSoln_set) {
    BaseMLPart_Parameters *arg0 ;
    bool arg1 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) 
    croak("Usage: BaseMLPart_Parameters_seedTopLvlSoln_set(self,value);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_BaseMLPart_Parameters) < 0) {
        croak("Type error in argument 1 of BaseMLPart_Parameters_seedTopLvlSoln_set. Expected %s", SWIGTYPE_p_BaseMLPart_Parameters->name);
        XSRETURN(1);
    }
    arg1 = (bool )SvIV(ST(1));
    arg0->seedTopLvlSoln = arg1;
    XSRETURN(argvi);
}


XS(_wrap_BaseMLPart_Parameters_seedTopLvlSoln_get) {
    BaseMLPart_Parameters *arg0 ;
    int argvi = 0;
    bool result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: BaseMLPart_Parameters_seedTopLvlSoln_get(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_BaseMLPart_Parameters) < 0) {
        croak("Type error in argument 1 of BaseMLPart_Parameters_seedTopLvlSoln_get. Expected %s", SWIGTYPE_p_BaseMLPart_Parameters->name);
        XSRETURN(1);
    }
    result = (bool ) (arg0->seedTopLvlSoln);
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) result);
    XSRETURN(argvi);
}


XS(_wrap_BaseMLPart_Parameters_pruningPercent_set) {
    BaseMLPart_Parameters *arg0 ;
    unsigned int arg1 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) 
    croak("Usage: BaseMLPart_Parameters_pruningPercent_set(self,value);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_BaseMLPart_Parameters) < 0) {
        croak("Type error in argument 1 of BaseMLPart_Parameters_pruningPercent_set. Expected %s", SWIGTYPE_p_BaseMLPart_Parameters->name);
        XSRETURN(1);
    }
    arg1 = (unsigned int )SvIV(ST(1));
    arg0->pruningPercent = arg1;
    XSRETURN(argvi);
}


XS(_wrap_BaseMLPart_Parameters_pruningPercent_get) {
    BaseMLPart_Parameters *arg0 ;
    int argvi = 0;
    unsigned int result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: BaseMLPart_Parameters_pruningPercent_get(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_BaseMLPart_Parameters) < 0) {
        croak("Type error in argument 1 of BaseMLPart_Parameters_pruningPercent_get. Expected %s", SWIGTYPE_p_BaseMLPart_Parameters->name);
        XSRETURN(1);
    }
    result = (unsigned int ) (arg0->pruningPercent);
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) result);
    XSRETURN(argvi);
}


XS(_wrap_BaseMLPart_Parameters_pruningPoint_set) {
    BaseMLPart_Parameters *arg0 ;
    double arg1 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) 
    croak("Usage: BaseMLPart_Parameters_pruningPoint_set(self,value);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_BaseMLPart_Parameters) < 0) {
        croak("Type error in argument 1 of BaseMLPart_Parameters_pruningPoint_set. Expected %s", SWIGTYPE_p_BaseMLPart_Parameters->name);
        XSRETURN(1);
    }
    arg1 = (double )SvNV(ST(1));
    arg0->pruningPoint = arg1;
    XSRETURN(argvi);
}


XS(_wrap_BaseMLPart_Parameters_pruningPoint_get) {
    BaseMLPart_Parameters *arg0 ;
    int argvi = 0;
    double result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: BaseMLPart_Parameters_pruningPoint_get(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_BaseMLPart_Parameters) < 0) {
        croak("Type error in argument 1 of BaseMLPart_Parameters_pruningPoint_get. Expected %s", SWIGTYPE_p_BaseMLPart_Parameters->name);
        XSRETURN(1);
    }
    result = (double ) (arg0->pruningPoint);
    ST(argvi) = sv_newmortal();
    sv_setnv(ST(argvi++), (double) result);
    XSRETURN(argvi);
}


XS(_wrap_BaseMLPart_Parameters_maxNumPassesAtBottom_set) {
    BaseMLPart_Parameters *arg0 ;
    unsigned int arg1 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) 
    croak("Usage: BaseMLPart_Parameters_maxNumPassesAtBottom_set(self,value);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_BaseMLPart_Parameters) < 0) {
        croak("Type error in argument 1 of BaseMLPart_Parameters_maxNumPassesAtBottom_set. Expected %s", SWIGTYPE_p_BaseMLPart_Parameters->name);
        XSRETURN(1);
    }
    arg1 = (unsigned int )SvIV(ST(1));
    arg0->maxNumPassesAtBottom = arg1;
    XSRETURN(argvi);
}


XS(_wrap_BaseMLPart_Parameters_maxNumPassesAtBottom_get) {
    BaseMLPart_Parameters *arg0 ;
    int argvi = 0;
    unsigned int result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: BaseMLPart_Parameters_maxNumPassesAtBottom_get(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_BaseMLPart_Parameters) < 0) {
        croak("Type error in argument 1 of BaseMLPart_Parameters_maxNumPassesAtBottom_get. Expected %s", SWIGTYPE_p_BaseMLPart_Parameters->name);
        XSRETURN(1);
    }
    result = (unsigned int ) (arg0->maxNumPassesAtBottom);
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) result);
    XSRETURN(argvi);
}


XS(_wrap_BaseMLPart_Parameters_vcNumFailures_set) {
    BaseMLPart_Parameters *arg0 ;
    unsigned int arg1 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) 
    croak("Usage: BaseMLPart_Parameters_vcNumFailures_set(self,value);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_BaseMLPart_Parameters) < 0) {
        croak("Type error in argument 1 of BaseMLPart_Parameters_vcNumFailures_set. Expected %s", SWIGTYPE_p_BaseMLPart_Parameters->name);
        XSRETURN(1);
    }
    arg1 = (unsigned int )SvIV(ST(1));
    arg0->vcNumFailures = arg1;
    XSRETURN(argvi);
}


XS(_wrap_BaseMLPart_Parameters_vcNumFailures_get) {
    BaseMLPart_Parameters *arg0 ;
    int argvi = 0;
    unsigned int result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: BaseMLPart_Parameters_vcNumFailures_get(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_BaseMLPart_Parameters) < 0) {
        croak("Type error in argument 1 of BaseMLPart_Parameters_vcNumFailures_get. Expected %s", SWIGTYPE_p_BaseMLPart_Parameters->name);
        XSRETURN(1);
    }
    result = (unsigned int ) (arg0->vcNumFailures);
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) result);
    XSRETURN(argvi);
}


XS(_wrap_BaseMLPart_Parameters_vcImproveRatio_set) {
    BaseMLPart_Parameters *arg0 ;
    double arg1 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) 
    croak("Usage: BaseMLPart_Parameters_vcImproveRatio_set(self,value);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_BaseMLPart_Parameters) < 0) {
        croak("Type error in argument 1 of BaseMLPart_Parameters_vcImproveRatio_set. Expected %s", SWIGTYPE_p_BaseMLPart_Parameters->name);
        XSRETURN(1);
    }
    arg1 = (double )SvNV(ST(1));
    arg0->vcImproveRatio = arg1;
    XSRETURN(argvi);
}


XS(_wrap_BaseMLPart_Parameters_vcImproveRatio_get) {
    BaseMLPart_Parameters *arg0 ;
    int argvi = 0;
    double result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: BaseMLPart_Parameters_vcImproveRatio_get(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_BaseMLPart_Parameters) < 0) {
        croak("Type error in argument 1 of BaseMLPart_Parameters_vcImproveRatio_get. Expected %s", SWIGTYPE_p_BaseMLPart_Parameters->name);
        XSRETURN(1);
    }
    result = (double ) (arg0->vcImproveRatio);
    ST(argvi) = sv_newmortal();
    sv_setnv(ST(argvi++), (double) result);
    XSRETURN(argvi);
}


XS(_wrap_BaseMLPart_Parameters_vc1ClusterRatio_set) {
    BaseMLPart_Parameters *arg0 ;
    double arg1 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) 
    croak("Usage: BaseMLPart_Parameters_vc1ClusterRatio_set(self,value);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_BaseMLPart_Parameters) < 0) {
        croak("Type error in argument 1 of BaseMLPart_Parameters_vc1ClusterRatio_set. Expected %s", SWIGTYPE_p_BaseMLPart_Parameters->name);
        XSRETURN(1);
    }
    arg1 = (double )SvNV(ST(1));
    arg0->vc1ClusterRatio = arg1;
    XSRETURN(argvi);
}


XS(_wrap_BaseMLPart_Parameters_vc1ClusterRatio_get) {
    BaseMLPart_Parameters *arg0 ;
    int argvi = 0;
    double result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: BaseMLPart_Parameters_vc1ClusterRatio_get(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_BaseMLPart_Parameters) < 0) {
        croak("Type error in argument 1 of BaseMLPart_Parameters_vc1ClusterRatio_get. Expected %s", SWIGTYPE_p_BaseMLPart_Parameters->name);
        XSRETURN(1);
    }
    result = (double ) (arg0->vc1ClusterRatio);
    ST(argvi) = sv_newmortal();
    sv_setnv(ST(argvi++), (double) result);
    XSRETURN(argvi);
}


XS(_wrap_BaseMLPart_Parameters_vc1FirstLevel_set) {
    BaseMLPart_Parameters *arg0 ;
    unsigned int arg1 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) 
    croak("Usage: BaseMLPart_Parameters_vc1FirstLevel_set(self,value);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_BaseMLPart_Parameters) < 0) {
        croak("Type error in argument 1 of BaseMLPart_Parameters_vc1FirstLevel_set. Expected %s", SWIGTYPE_p_BaseMLPart_Parameters->name);
        XSRETURN(1);
    }
    arg1 = (unsigned int )SvIV(ST(1));
    arg0->vc1FirstLevel = arg1;
    XSRETURN(argvi);
}


XS(_wrap_BaseMLPart_Parameters_vc1FirstLevel_get) {
    BaseMLPart_Parameters *arg0 ;
    int argvi = 0;
    unsigned int result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: BaseMLPart_Parameters_vc1FirstLevel_get(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_BaseMLPart_Parameters) < 0) {
        croak("Type error in argument 1 of BaseMLPart_Parameters_vc1FirstLevel_get. Expected %s", SWIGTYPE_p_BaseMLPart_Parameters->name);
        XSRETURN(1);
    }
    result = (unsigned int ) (arg0->vc1FirstLevel);
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) result);
    XSRETURN(argvi);
}


XS(_wrap_BaseMLPart_Parameters_vc1LevelGrowth_set) {
    BaseMLPart_Parameters *arg0 ;
    double arg1 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) 
    croak("Usage: BaseMLPart_Parameters_vc1LevelGrowth_set(self,value);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_BaseMLPart_Parameters) < 0) {
        croak("Type error in argument 1 of BaseMLPart_Parameters_vc1LevelGrowth_set. Expected %s", SWIGTYPE_p_BaseMLPart_Parameters->name);
        XSRETURN(1);
    }
    arg1 = (double )SvNV(ST(1));
    arg0->vc1LevelGrowth = arg1;
    XSRETURN(argvi);
}


XS(_wrap_BaseMLPart_Parameters_vc1LevelGrowth_get) {
    BaseMLPart_Parameters *arg0 ;
    int argvi = 0;
    double result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: BaseMLPart_Parameters_vc1LevelGrowth_get(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_BaseMLPart_Parameters) < 0) {
        croak("Type error in argument 1 of BaseMLPart_Parameters_vc1LevelGrowth_get. Expected %s", SWIGTYPE_p_BaseMLPart_Parameters->name);
        XSRETURN(1);
    }
    result = (double ) (arg0->vc1LevelGrowth);
    ST(argvi) = sv_newmortal();
    sv_setnv(ST(argvi++), (double) result);
    XSRETURN(argvi);
}


XS(_wrap_BaseMLPart_Parameters_vc2ClusterRatio_set) {
    BaseMLPart_Parameters *arg0 ;
    double arg1 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) 
    croak("Usage: BaseMLPart_Parameters_vc2ClusterRatio_set(self,value);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_BaseMLPart_Parameters) < 0) {
        croak("Type error in argument 1 of BaseMLPart_Parameters_vc2ClusterRatio_set. Expected %s", SWIGTYPE_p_BaseMLPart_Parameters->name);
        XSRETURN(1);
    }
    arg1 = (double )SvNV(ST(1));
    arg0->vc2ClusterRatio = arg1;
    XSRETURN(argvi);
}


XS(_wrap_BaseMLPart_Parameters_vc2ClusterRatio_get) {
    BaseMLPart_Parameters *arg0 ;
    int argvi = 0;
    double result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: BaseMLPart_Parameters_vc2ClusterRatio_get(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_BaseMLPart_Parameters) < 0) {
        croak("Type error in argument 1 of BaseMLPart_Parameters_vc2ClusterRatio_get. Expected %s", SWIGTYPE_p_BaseMLPart_Parameters->name);
        XSRETURN(1);
    }
    result = (double ) (arg0->vc2ClusterRatio);
    ST(argvi) = sv_newmortal();
    sv_setnv(ST(argvi++), (double) result);
    XSRETURN(argvi);
}


XS(_wrap_BaseMLPart_Parameters_vc2FirstLevel_set) {
    BaseMLPart_Parameters *arg0 ;
    unsigned int arg1 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) 
    croak("Usage: BaseMLPart_Parameters_vc2FirstLevel_set(self,value);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_BaseMLPart_Parameters) < 0) {
        croak("Type error in argument 1 of BaseMLPart_Parameters_vc2FirstLevel_set. Expected %s", SWIGTYPE_p_BaseMLPart_Parameters->name);
        XSRETURN(1);
    }
    arg1 = (unsigned int )SvIV(ST(1));
    arg0->vc2FirstLevel = arg1;
    XSRETURN(argvi);
}


XS(_wrap_BaseMLPart_Parameters_vc2FirstLevel_get) {
    BaseMLPart_Parameters *arg0 ;
    int argvi = 0;
    unsigned int result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: BaseMLPart_Parameters_vc2FirstLevel_get(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_BaseMLPart_Parameters) < 0) {
        croak("Type error in argument 1 of BaseMLPart_Parameters_vc2FirstLevel_get. Expected %s", SWIGTYPE_p_BaseMLPart_Parameters->name);
        XSRETURN(1);
    }
    result = (unsigned int ) (arg0->vc2FirstLevel);
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) result);
    XSRETURN(argvi);
}


XS(_wrap_BaseMLPart_Parameters_vc2LevelGrowth_set) {
    BaseMLPart_Parameters *arg0 ;
    double arg1 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) 
    croak("Usage: BaseMLPart_Parameters_vc2LevelGrowth_set(self,value);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_BaseMLPart_Parameters) < 0) {
        croak("Type error in argument 1 of BaseMLPart_Parameters_vc2LevelGrowth_set. Expected %s", SWIGTYPE_p_BaseMLPart_Parameters->name);
        XSRETURN(1);
    }
    arg1 = (double )SvNV(ST(1));
    arg0->vc2LevelGrowth = arg1;
    XSRETURN(argvi);
}


XS(_wrap_BaseMLPart_Parameters_vc2LevelGrowth_get) {
    BaseMLPart_Parameters *arg0 ;
    int argvi = 0;
    double result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: BaseMLPart_Parameters_vc2LevelGrowth_get(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_BaseMLPart_Parameters) < 0) {
        croak("Type error in argument 1 of BaseMLPart_Parameters_vc2LevelGrowth_get. Expected %s", SWIGTYPE_p_BaseMLPart_Parameters->name);
        XSRETURN(1);
    }
    result = (double ) (arg0->vc2LevelGrowth);
    ST(argvi) = sv_newmortal();
    sv_setnv(ST(argvi++), (double) result);
    XSRETURN(argvi);
}


XS(_wrap_BaseMLPart_Parameters_clParams_set) {
    BaseMLPart_Parameters *arg0 ;
    ClustHGraphParameters *arg1 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) 
    croak("Usage: BaseMLPart_Parameters_clParams_set(self,value);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_BaseMLPart_Parameters) < 0) {
        croak("Type error in argument 1 of BaseMLPart_Parameters_clParams_set. Expected %s", SWIGTYPE_p_BaseMLPart_Parameters->name);
        XSRETURN(1);
    }
    if (SWIG_ConvertPtr(ST(1),(void **) &arg1,SWIGTYPE_p_ClustHGraphParameters) < 0) {
        croak("Type error in argument 2 of BaseMLPart_Parameters_clParams_set. Expected %s", SWIGTYPE_p_ClustHGraphParameters->name);
        XSRETURN(1);
    }
    arg0->clParams = *arg1;
    XSRETURN(argvi);
}


XS(_wrap_BaseMLPart_Parameters_clParams_get) {
    BaseMLPart_Parameters *arg0 ;
    int argvi = 0;
    ClustHGraphParameters *result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: BaseMLPart_Parameters_clParams_get(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_BaseMLPart_Parameters) < 0) {
        croak("Type error in argument 1 of BaseMLPart_Parameters_clParams_get. Expected %s", SWIGTYPE_p_BaseMLPart_Parameters->name);
        XSRETURN(1);
    }
    result = (ClustHGraphParameters *)& (arg0->clParams);
    ST(argvi) = sv_newmortal();
    SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_ClustHGraphParameters);
    XSRETURN(argvi);
}


XS(_wrap_new_BaseMLPart_Parameters) {
    int arg0 ;
    char **arg1 ;
    int n_arg ;
    int argvi = 0;
    BaseMLPart_Parameters *result ;
    dXSARGS;
    
    {
        arg0=n_arg=items;
        items=1;
    }
    if ((items < 1) || (items > 1)) 
    croak("Usage: new_BaseMLPart_Parameters(argv);");
    {
        arg1 = (char **)
        malloc(n_arg*sizeof(char *));
        for (; n_arg; --n_arg) {
            arg1[n_arg-1]=
            (char *)SvPV(ST(n_arg-1),PL_na);
        }
    }
    result = (BaseMLPart_Parameters *)new BaseMLPart_Parameters(arg0,(char const **)arg1);
    ST(argvi) = sv_newmortal();
    SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_BaseMLPart_Parameters);
    XSRETURN(argvi);
}


XS(_wrap_new_MLPart) {
    PartitioningProblem *arg0 ;
    BaseMLPart_Parameters *arg1 ;
    FillableHierarchy *arg2 = NULL ;
    int argvi = 0;
    MLPart *result ;
    dXSARGS;
    
    if ((items < 2) || (items > 3)) 
    croak("Usage: new_MLPart(problem,params,hier);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_PartitioningProblem) < 0) {
        croak("Type error in argument 1 of new_MLPart. Expected %s", SWIGTYPE_p_PartitioningProblem->name);
        XSRETURN(1);
    }
    if (SWIG_ConvertPtr(ST(1),(void **) &arg1,SWIGTYPE_p_BaseMLPart_Parameters) < 0) {
        croak("Type error in argument 2 of new_MLPart. Expected %s", SWIGTYPE_p_BaseMLPart_Parameters->name);
        XSRETURN(1);
    }
    if (items > 2) {
        if (SWIG_ConvertPtr(ST(2),(void **) &arg2,SWIGTYPE_p_FillableHierarchy) < 0) {
            croak("Type error in argument 3 of new_MLPart. Expected %s", SWIGTYPE_p_FillableHierarchy->name);
            XSRETURN(1);
        }
    }
    result = (MLPart *)new MLPart(*arg0,(BaseMLPart_Parameters const &)*arg1,arg2);
    ST(argvi) = sv_newmortal();
    SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_MLPart);
    XSRETURN(argvi);
}


XS(_wrap_delete_MLPart) {
    MLPart *arg0 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: delete_MLPart(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_MLPart) < 0) {
        croak("Type error in argument 1 of delete_MLPart. Expected %s", SWIGTYPE_p_MLPart->name);
        XSRETURN(1);
    }
    delete arg0;
    XSRETURN(argvi);
}


XS(_wrap_HGraphFixed__nodeNames_set) {
    HGraphFixed *arg0 ;
    vector<const char*> *arg1 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) 
    croak("Usage: HGraphFixed__nodeNames_set(self,value);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_HGraphFixed) < 0) {
        croak("Type error in argument 1 of HGraphFixed__nodeNames_set. Expected %s", SWIGTYPE_p_HGraphFixed->name);
        XSRETURN(1);
    }
    if (SWIG_ConvertPtr(ST(1),(void **) &arg1,SWIGTYPE_p_vector_const_char__) < 0) {
        croak("Type error in argument 2 of HGraphFixed__nodeNames_set. Expected %s", SWIGTYPE_p_vector_const_char__->name);
        XSRETURN(1);
    }
    arg0->_nodeNames = *arg1;
    XSRETURN(argvi);
}


XS(_wrap_HGraphFixed__nodeNames_get) {
    HGraphFixed *arg0 ;
    int argvi = 0;
    vector<const char*> *result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: HGraphFixed__nodeNames_get(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_HGraphFixed) < 0) {
        croak("Type error in argument 1 of HGraphFixed__nodeNames_get. Expected %s", SWIGTYPE_p_HGraphFixed->name);
        XSRETURN(1);
    }
    result = (vector<const char*> *)& (arg0->_nodeNames);
    ST(argvi) = sv_newmortal();
    SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_vector_const_char__);
    XSRETURN(argvi);
}


XS(_wrap_HGraphFixed__netNames_set) {
    HGraphFixed *arg0 ;
    vector<const char*> *arg1 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) 
    croak("Usage: HGraphFixed__netNames_set(self,value);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_HGraphFixed) < 0) {
        croak("Type error in argument 1 of HGraphFixed__netNames_set. Expected %s", SWIGTYPE_p_HGraphFixed->name);
        XSRETURN(1);
    }
    if (SWIG_ConvertPtr(ST(1),(void **) &arg1,SWIGTYPE_p_vector_const_char__) < 0) {
        croak("Type error in argument 2 of HGraphFixed__netNames_set. Expected %s", SWIGTYPE_p_vector_const_char__->name);
        XSRETURN(1);
    }
    arg0->_netNames = *arg1;
    XSRETURN(argvi);
}


XS(_wrap_HGraphFixed__netNames_get) {
    HGraphFixed *arg0 ;
    int argvi = 0;
    vector<const char*> *result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: HGraphFixed__netNames_get(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_HGraphFixed) < 0) {
        croak("Type error in argument 1 of HGraphFixed__netNames_get. Expected %s", SWIGTYPE_p_HGraphFixed->name);
        XSRETURN(1);
    }
    result = (vector<const char*> *)& (arg0->_netNames);
    ST(argvi) = sv_newmortal();
    SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_vector_const_char__);
    XSRETURN(argvi);
}


XS(_wrap_HGraphFixed__nodeNamesMap_set) {
    HGraphFixed *arg0 ;
    HGNodeNamesMap *arg1 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) 
    croak("Usage: HGraphFixed__nodeNamesMap_set(self,value);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_HGraphFixed) < 0) {
        croak("Type error in argument 1 of HGraphFixed__nodeNamesMap_set. Expected %s", SWIGTYPE_p_HGraphFixed->name);
        XSRETURN(1);
    }
    if (SWIG_ConvertPtr(ST(1),(void **) &arg1,SWIGTYPE_p_HGNodeNamesMap) < 0) {
        croak("Type error in argument 2 of HGraphFixed__nodeNamesMap_set. Expected %s", SWIGTYPE_p_HGNodeNamesMap->name);
        XSRETURN(1);
    }
    arg0->_nodeNamesMap = *arg1;
    XSRETURN(argvi);
}


XS(_wrap_HGraphFixed__nodeNamesMap_get) {
    HGraphFixed *arg0 ;
    int argvi = 0;
    HGNodeNamesMap *result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: HGraphFixed__nodeNamesMap_get(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_HGraphFixed) < 0) {
        croak("Type error in argument 1 of HGraphFixed__nodeNamesMap_get. Expected %s", SWIGTYPE_p_HGraphFixed->name);
        XSRETURN(1);
    }
    result = (HGNodeNamesMap *)& (arg0->_nodeNamesMap);
    ST(argvi) = sv_newmortal();
    SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_HGNodeNamesMap);
    XSRETURN(argvi);
}


XS(_wrap_HGraphFixed__netNamesMap_set) {
    HGraphFixed *arg0 ;
    HGNetNamesMap *arg1 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) 
    croak("Usage: HGraphFixed__netNamesMap_set(self,value);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_HGraphFixed) < 0) {
        croak("Type error in argument 1 of HGraphFixed__netNamesMap_set. Expected %s", SWIGTYPE_p_HGraphFixed->name);
        XSRETURN(1);
    }
    if (SWIG_ConvertPtr(ST(1),(void **) &arg1,SWIGTYPE_p_HGNetNamesMap) < 0) {
        croak("Type error in argument 2 of HGraphFixed__netNamesMap_set. Expected %s", SWIGTYPE_p_HGNetNamesMap->name);
        XSRETURN(1);
    }
    arg0->_netNamesMap = *arg1;
    XSRETURN(argvi);
}


XS(_wrap_HGraphFixed__netNamesMap_get) {
    HGraphFixed *arg0 ;
    int argvi = 0;
    HGNetNamesMap *result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: HGraphFixed__netNamesMap_get(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_HGraphFixed) < 0) {
        croak("Type error in argument 1 of HGraphFixed__netNamesMap_get. Expected %s", SWIGTYPE_p_HGraphFixed->name);
        XSRETURN(1);
    }
    result = (HGNetNamesMap *)& (arg0->_netNamesMap);
    ST(argvi) = sv_newmortal();
    SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_HGNetNamesMap);
    XSRETURN(argvi);
}


XS(_wrap_new_HGraphFixed) {
    unsigned int arg0 ;
    unsigned int arg1 ;
    HGraphParameters *arg2 ;
    int argvi = 0;
    HGraphFixed *result ;
    dXSARGS;
    
    if ((items < 3) || (items > 3)) 
    croak("Usage: new_HGraphFixed(numNodes,numWeights,param);");
    arg0 = (unsigned int )SvIV(ST(0));
    arg1 = (unsigned int )SvIV(ST(1));
    if (SWIG_ConvertPtr(ST(2),(void **) &arg2,SWIGTYPE_p_HGraphParameters) < 0) {
        croak("Type error in argument 3 of new_HGraphFixed. Expected %s", SWIGTYPE_p_HGraphParameters->name);
        XSRETURN(1);
    }
    result = (HGraphFixed *)new HGraphFixed(arg0,arg1,*arg2);
    ST(argvi) = sv_newmortal();
    SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_HGraphFixed);
    XSRETURN(argvi);
}


XS(_wrap_HGraphFixed_getNumNodes) {
    HGraphFixed *arg0 ;
    int argvi = 0;
    unsigned int result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: HGraphFixed_getNumNodes(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_HGraphFixed) < 0) {
        croak("Type error in argument 1 of HGraphFixed_getNumNodes. Expected %s", SWIGTYPE_p_HGraphFixed->name);
        XSRETURN(1);
    }
    result = (unsigned int )arg0->getNumNodes();
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) result);
    XSRETURN(argvi);
}


XS(_wrap_HGraphFixed_getNumEdges) {
    HGraphFixed *arg0 ;
    int argvi = 0;
    unsigned int result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: HGraphFixed_getNumEdges(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_HGraphFixed) < 0) {
        croak("Type error in argument 1 of HGraphFixed_getNumEdges. Expected %s", SWIGTYPE_p_HGraphFixed->name);
        XSRETURN(1);
    }
    result = (unsigned int )arg0->getNumEdges();
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) result);
    XSRETURN(argvi);
}


XS(_wrap_HGraphFixed_getAvgNodeDegree) {
    HGraphFixed *arg0 ;
    int argvi = 0;
    double result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: HGraphFixed_getAvgNodeDegree(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_HGraphFixed) < 0) {
        croak("Type error in argument 1 of HGraphFixed_getAvgNodeDegree. Expected %s", SWIGTYPE_p_HGraphFixed->name);
        XSRETURN(1);
    }
    result = (double )arg0->getAvgNodeDegree();
    ST(argvi) = sv_newmortal();
    sv_setnv(ST(argvi++), (double) result);
    XSRETURN(argvi);
}


XS(_wrap_HGraphFixed_getAvgEdgeDegree) {
    HGraphFixed *arg0 ;
    int argvi = 0;
    double result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: HGraphFixed_getAvgEdgeDegree(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_HGraphFixed) < 0) {
        croak("Type error in argument 1 of HGraphFixed_getAvgEdgeDegree. Expected %s", SWIGTYPE_p_HGraphFixed->name);
        XSRETURN(1);
    }
    result = (double )arg0->getAvgEdgeDegree();
    ST(argvi) = sv_newmortal();
    sv_setnv(ST(argvi++), (double) result);
    XSRETURN(argvi);
}


XS(_wrap_HGraphFixed_nodesBegin) {
    HGraphFixed *arg0 ;
    int argvi = 0;
    itHGFNodeGlobal *result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: HGraphFixed_nodesBegin(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_HGraphFixed) < 0) {
        croak("Type error in argument 1 of HGraphFixed_nodesBegin. Expected %s", SWIGTYPE_p_HGraphFixed->name);
        XSRETURN(1);
    }
    result = new itHGFNodeGlobal (arg0->nodesBegin());    ST(argvi) = sv_newmortal();
    SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_itHGFNodeGlobal);
    XSRETURN(argvi);
}


XS(_wrap_HGraphFixed_nodesEnd) {
    HGraphFixed *arg0 ;
    int argvi = 0;
    itHGFNodeGlobal *result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: HGraphFixed_nodesEnd(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_HGraphFixed) < 0) {
        croak("Type error in argument 1 of HGraphFixed_nodesEnd. Expected %s", SWIGTYPE_p_HGraphFixed->name);
        XSRETURN(1);
    }
    result = new itHGFNodeGlobal (arg0->nodesEnd());    ST(argvi) = sv_newmortal();
    SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_itHGFNodeGlobal);
    XSRETURN(argvi);
}


XS(_wrap_HGraphFixed_terminalsBegin) {
    HGraphFixed *arg0 ;
    int argvi = 0;
    itHGFNodeGlobal *result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: HGraphFixed_terminalsBegin(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_HGraphFixed) < 0) {
        croak("Type error in argument 1 of HGraphFixed_terminalsBegin. Expected %s", SWIGTYPE_p_HGraphFixed->name);
        XSRETURN(1);
    }
    result = new itHGFNodeGlobal (arg0->terminalsBegin());    ST(argvi) = sv_newmortal();
    SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_itHGFNodeGlobal);
    XSRETURN(argvi);
}


XS(_wrap_HGraphFixed_terminalsEnd) {
    HGraphFixed *arg0 ;
    int argvi = 0;
    itHGFNodeGlobal *result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: HGraphFixed_terminalsEnd(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_HGraphFixed) < 0) {
        croak("Type error in argument 1 of HGraphFixed_terminalsEnd. Expected %s", SWIGTYPE_p_HGraphFixed->name);
        XSRETURN(1);
    }
    result = new itHGFNodeGlobal (arg0->terminalsEnd());    ST(argvi) = sv_newmortal();
    SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_itHGFNodeGlobal);
    XSRETURN(argvi);
}


XS(_wrap_HGraphFixed_edgesBegin) {
    HGraphFixed *arg0 ;
    int argvi = 0;
    itHGFEdgeGlobal *result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: HGraphFixed_edgesBegin(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_HGraphFixed) < 0) {
        croak("Type error in argument 1 of HGraphFixed_edgesBegin. Expected %s", SWIGTYPE_p_HGraphFixed->name);
        XSRETURN(1);
    }
    result = new itHGFEdgeGlobal (arg0->edgesBegin());    ST(argvi) = sv_newmortal();
    SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_itHGFEdgeGlobal);
    XSRETURN(argvi);
}


XS(_wrap_HGraphFixed_edgesEnd) {
    HGraphFixed *arg0 ;
    int argvi = 0;
    itHGFEdgeGlobal *result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: HGraphFixed_edgesEnd(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_HGraphFixed) < 0) {
        croak("Type error in argument 1 of HGraphFixed_edgesEnd. Expected %s", SWIGTYPE_p_HGraphFixed->name);
        XSRETURN(1);
    }
    result = new itHGFEdgeGlobal (arg0->edgesEnd());    ST(argvi) = sv_newmortal();
    SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_itHGFEdgeGlobal);
    XSRETURN(argvi);
}


XS(_wrap_HGraphFixed_getNodeByIdx) {
    HGraphFixed *arg0 ;
    unsigned int arg1 ;
    int argvi = 0;
    HGFNode *result ;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) 
    croak("Usage: HGraphFixed_getNodeByIdx(self,nodeIndex);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_HGraphFixed) < 0) {
        croak("Type error in argument 1 of HGraphFixed_getNodeByIdx. Expected %s", SWIGTYPE_p_HGraphFixed->name);
        XSRETURN(1);
    }
    arg1 = (unsigned int )SvIV(ST(1));
    HGFNode const &_result_ref = arg0->getNodeByIdx(arg1);
    result = (HGFNode *) &_result_ref;
    ST(argvi) = sv_newmortal();
    SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_HGFNode);
    XSRETURN(argvi);
}


XS(_wrap_HGraphFixed_haveSuchNode) {
    HGraphFixed *arg0 ;
    char *arg1 ;
    int argvi = 0;
    bool result ;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) 
    croak("Usage: HGraphFixed_haveSuchNode(self,name);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_HGraphFixed) < 0) {
        croak("Type error in argument 1 of HGraphFixed_haveSuchNode. Expected %s", SWIGTYPE_p_HGraphFixed->name);
        XSRETURN(1);
    }
    if (! SvOK((SV*) ST(1))) {
        arg1 = 0; 
    }
    else {
        arg1 = (char *) SvPV(ST(1),PL_na); 
    }
    result = (bool )arg0->haveSuchNode((char const *)arg1);
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) result);
    XSRETURN(argvi);
}


XS(_wrap_HGraphFixed_haveSuchNet) {
    HGraphFixed *arg0 ;
    char *arg1 ;
    int argvi = 0;
    bool result ;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) 
    croak("Usage: HGraphFixed_haveSuchNet(self,name);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_HGraphFixed) < 0) {
        croak("Type error in argument 1 of HGraphFixed_haveSuchNet. Expected %s", SWIGTYPE_p_HGraphFixed->name);
        XSRETURN(1);
    }
    if (! SvOK((SV*) ST(1))) {
        arg1 = 0; 
    }
    else {
        arg1 = (char *) SvPV(ST(1),PL_na); 
    }
    result = (bool )arg0->haveSuchNet((char const *)arg1);
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) result);
    XSRETURN(argvi);
}


XS(_wrap_HGraphFixed_getNodeByName) {
    HGraphFixed *arg0 ;
    char *arg1 ;
    int argvi = 0;
    HGFNode *result ;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) 
    croak("Usage: HGraphFixed_getNodeByName(self,name);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_HGraphFixed) < 0) {
        croak("Type error in argument 1 of HGraphFixed_getNodeByName. Expected %s", SWIGTYPE_p_HGraphFixed->name);
        XSRETURN(1);
    }
    if (! SvOK((SV*) ST(1))) {
        arg1 = 0; 
    }
    else {
        arg1 = (char *) SvPV(ST(1),PL_na); 
    }
    HGFNode const &_result_ref = arg0->getNodeByName((char const *)arg1);
    result = (HGFNode *) &_result_ref;
    ST(argvi) = sv_newmortal();
    SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_HGFNode);
    XSRETURN(argvi);
}


XS(_wrap_HGraphFixed_getNetByName) {
    HGraphFixed *arg0 ;
    char *arg1 ;
    int argvi = 0;
    HGFEdge *result ;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) 
    croak("Usage: HGraphFixed_getNetByName(self,name);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_HGraphFixed) < 0) {
        croak("Type error in argument 1 of HGraphFixed_getNetByName. Expected %s", SWIGTYPE_p_HGraphFixed->name);
        XSRETURN(1);
    }
    if (! SvOK((SV*) ST(1))) {
        arg1 = 0; 
    }
    else {
        arg1 = (char *) SvPV(ST(1),PL_na); 
    }
    HGFEdge const &_result_ref = arg0->getNetByName((char const *)arg1);
    result = (HGFEdge *) &_result_ref;
    ST(argvi) = sv_newmortal();
    SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_HGFEdge);
    XSRETURN(argvi);
}


XS(_wrap_HGraphFixed_getEdgeByIdx) {
    HGraphFixed *arg0 ;
    unsigned int arg1 ;
    int argvi = 0;
    HGFEdge *result ;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) 
    croak("Usage: HGraphFixed_getEdgeByIdx(self,edgeIndex);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_HGraphFixed) < 0) {
        croak("Type error in argument 1 of HGraphFixed_getEdgeByIdx. Expected %s", SWIGTYPE_p_HGraphFixed->name);
        XSRETURN(1);
    }
    arg1 = (unsigned int )SvIV(ST(1));
    HGFEdge const &_result_ref = arg0->getEdgeByIdx(arg1);
    result = (HGFEdge *) &_result_ref;
    ST(argvi) = sv_newmortal();
    SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_HGFEdge);
    XSRETURN(argvi);
}


XS(_wrap_HGraphFixed_getNodesSortedByWeights) {
    HGraphFixed *arg0 ;
    int argvi = 0;
    Permutation *result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: HGraphFixed_getNodesSortedByWeights(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_HGraphFixed) < 0) {
        croak("Type error in argument 1 of HGraphFixed_getNodesSortedByWeights. Expected %s", SWIGTYPE_p_HGraphFixed->name);
        XSRETURN(1);
    }
    Permutation const &_result_ref = arg0->getNodesSortedByWeights();
    result = (Permutation *) &_result_ref;
    ST(argvi) = sv_newmortal();
    SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_Permutation);
    XSRETURN(argvi);
}


XS(_wrap_HGraphFixed_getNodesSortedByDegrees) {
    HGraphFixed *arg0 ;
    int argvi = 0;
    Permutation *result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: HGraphFixed_getNodesSortedByDegrees(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_HGraphFixed) < 0) {
        croak("Type error in argument 1 of HGraphFixed_getNodesSortedByDegrees. Expected %s", SWIGTYPE_p_HGraphFixed->name);
        XSRETURN(1);
    }
    Permutation const &_result_ref = arg0->getNodesSortedByDegrees();
    result = (Permutation *) &_result_ref;
    ST(argvi) = sv_newmortal();
    SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_Permutation);
    XSRETURN(argvi);
}


XS(_wrap_HGraphFixed_maxNodeIndex) {
    HGraphFixed *arg0 ;
    int argvi = 0;
    unsigned int result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: HGraphFixed_maxNodeIndex(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_HGraphFixed) < 0) {
        croak("Type error in argument 1 of HGraphFixed_maxNodeIndex. Expected %s", SWIGTYPE_p_HGraphFixed->name);
        XSRETURN(1);
    }
    result = (unsigned int )arg0->maxNodeIndex();
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) result);
    XSRETURN(argvi);
}


XS(_wrap_HGraphFixed_maxEdgeIndex) {
    HGraphFixed *arg0 ;
    int argvi = 0;
    unsigned int result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: HGraphFixed_maxEdgeIndex(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_HGraphFixed) < 0) {
        croak("Type error in argument 1 of HGraphFixed_maxEdgeIndex. Expected %s", SWIGTYPE_p_HGraphFixed->name);
        XSRETURN(1);
    }
    result = (unsigned int )arg0->maxEdgeIndex();
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) result);
    XSRETURN(argvi);
}


XS(_wrap_HGraphFixed_addEdge) {
    HGraphFixed *arg0 ;
    HGWeight *arg1 ;
    int argvi = 0;
    HGFEdge *result ;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) 
    croak("Usage: HGraphFixed_addEdge(self,weight);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_HGraphFixed) < 0) {
        croak("Type error in argument 1 of HGraphFixed_addEdge. Expected %s", SWIGTYPE_p_HGraphFixed->name);
        XSRETURN(1);
    }
    if (SWIG_ConvertPtr(ST(1),(void **) &arg1,SWIGTYPE_p_HGWeight) < 0) {
        croak("Type error in argument 2 of HGraphFixed_addEdge. Expected %s", SWIGTYPE_p_HGWeight->name);
        XSRETURN(1);
    }
    result = (HGFEdge *)arg0->addEdge(*arg1);
    ST(argvi) = sv_newmortal();
    SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_HGFEdge);
    XSRETURN(argvi);
}


XS(_wrap_HGraphFixed_fastAddEdge) {
    HGraphFixed *arg0 ;
    unsigned int arg1 ;
    HGWeight *arg2 ;
    int argvi = 0;
    HGFEdge *result ;
    dXSARGS;
    
    if ((items < 3) || (items > 3)) 
    croak("Usage: HGraphFixed_fastAddEdge(self,numPins,weight);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_HGraphFixed) < 0) {
        croak("Type error in argument 1 of HGraphFixed_fastAddEdge. Expected %s", SWIGTYPE_p_HGraphFixed->name);
        XSRETURN(1);
    }
    arg1 = (unsigned int )SvIV(ST(1));
    if (SWIG_ConvertPtr(ST(2),(void **) &arg2,SWIGTYPE_p_HGWeight) < 0) {
        croak("Type error in argument 3 of HGraphFixed_fastAddEdge. Expected %s", SWIGTYPE_p_HGWeight->name);
        XSRETURN(1);
    }
    result = (HGFEdge *)arg0->fastAddEdge(arg1,*arg2);
    ST(argvi) = sv_newmortal();
    SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_HGFEdge);
    XSRETURN(argvi);
}


XS(_wrap_HGraphFixed_adviseNodeDegrees) {
    HGraphFixed *arg0 ;
    vector<unsigned> *arg1 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) 
    croak("Usage: HGraphFixed_adviseNodeDegrees(self,nodeDegrees);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_HGraphFixed) < 0) {
        croak("Type error in argument 1 of HGraphFixed_adviseNodeDegrees. Expected %s", SWIGTYPE_p_HGraphFixed->name);
        XSRETURN(1);
    }
    if (SWIG_ConvertPtr(ST(1),(void **) &arg1,SWIGTYPE_p_vector_unsigned_) < 0) {
        croak("Type error in argument 2 of HGraphFixed_adviseNodeDegrees. Expected %s", SWIGTYPE_p_vector_unsigned_->name);
        XSRETURN(1);
    }
    arg0->adviseNodeDegrees((vector<unsigned> const &)*arg1);
    XSRETURN(argvi);
}


XS(_wrap_HGraphFixed_finalize) {
    HGraphFixed *arg0 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: HGraphFixed_finalize(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_HGraphFixed) < 0) {
        croak("Type error in argument 1 of HGraphFixed_finalize. Expected %s", SWIGTYPE_p_HGraphFixed->name);
        XSRETURN(1);
    }
    arg0->finalize();
    XSRETURN(argvi);
}


XS(_wrap_HGraphFixed_saveAsNetDAre) {
    HGraphFixed *arg0 ;
    char *arg1 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) 
    croak("Usage: HGraphFixed_saveAsNetDAre(self,baseName);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_HGraphFixed) < 0) {
        croak("Type error in argument 1 of HGraphFixed_saveAsNetDAre. Expected %s", SWIGTYPE_p_HGraphFixed->name);
        XSRETURN(1);
    }
    if (! SvOK((SV*) ST(1))) {
        arg1 = 0; 
    }
    else {
        arg1 = (char *) SvPV(ST(1),PL_na); 
    }
    arg0->saveAsNetDAre((char const *)arg1);
    XSRETURN(argvi);
}


XS(_wrap_HGraphFixed_saveAsNodesNetsWts) {
    HGraphFixed *arg0 ;
    char *arg1 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) 
    croak("Usage: HGraphFixed_saveAsNodesNetsWts(self,baseName);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_HGraphFixed) < 0) {
        croak("Type error in argument 1 of HGraphFixed_saveAsNodesNetsWts. Expected %s", SWIGTYPE_p_HGraphFixed->name);
        XSRETURN(1);
    }
    if (! SvOK((SV*) ST(1))) {
        arg1 = 0; 
    }
    else {
        arg1 = (char *) SvPV(ST(1),PL_na); 
    }
    arg0->saveAsNodesNetsWts((char const *)arg1);
    XSRETURN(argvi);
}


XS(_wrap_HGraphFixed_isConsistent) {
    HGraphFixed *arg0 ;
    int argvi = 0;
    bool result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: HGraphFixed_isConsistent(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_HGraphFixed) < 0) {
        croak("Type error in argument 1 of HGraphFixed_isConsistent. Expected %s", SWIGTYPE_p_HGraphFixed->name);
        XSRETURN(1);
    }
    result = (bool )arg0->isConsistent();
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) result);
    XSRETURN(argvi);
}


XS(_wrap_HGraphFixed_sortAsDB) {
    HGraphFixed *arg0 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: HGraphFixed_sortAsDB(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_HGraphFixed) < 0) {
        croak("Type error in argument 1 of HGraphFixed_sortAsDB. Expected %s", SWIGTYPE_p_HGraphFixed->name);
        XSRETURN(1);
    }
    arg0->sortAsDB();
    XSRETURN(argvi);
}


XS(_wrap_HGraphFixed_printEdgeSizeStats) {
    HGraphFixed *arg0 ;
    ostream *arg1 = (ostream *) &cout ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 1) || (items > 2)) 
    croak("Usage: HGraphFixed_printEdgeSizeStats(self,str);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_HGraphFixed) < 0) {
        croak("Type error in argument 1 of HGraphFixed_printEdgeSizeStats. Expected %s", SWIGTYPE_p_HGraphFixed->name);
        XSRETURN(1);
    }
    if (items > 1) {
        if (SWIG_ConvertPtr(ST(1),(void **) &arg1,SWIGTYPE_p_ostream) < 0) {
            croak("Type error in argument 2 of HGraphFixed_printEdgeSizeStats. Expected %s", SWIGTYPE_p_ostream->name);
            XSRETURN(1);
        }
    }
    arg0->printEdgeSizeStats(*arg1);
    XSRETURN(argvi);
}


XS(_wrap_HGraphFixed_printEdgeWtStats) {
    HGraphFixed *arg0 ;
    ostream *arg1 = (ostream *) &cout ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 1) || (items > 2)) 
    croak("Usage: HGraphFixed_printEdgeWtStats(self,str);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_HGraphFixed) < 0) {
        croak("Type error in argument 1 of HGraphFixed_printEdgeWtStats. Expected %s", SWIGTYPE_p_HGraphFixed->name);
        XSRETURN(1);
    }
    if (items > 1) {
        if (SWIG_ConvertPtr(ST(1),(void **) &arg1,SWIGTYPE_p_ostream) < 0) {
            croak("Type error in argument 2 of HGraphFixed_printEdgeWtStats. Expected %s", SWIGTYPE_p_ostream->name);
            XSRETURN(1);
        }
    }
    arg0->printEdgeWtStats(*arg1);
    XSRETURN(argvi);
}


XS(_wrap_HGraphFixed_printNodeWtStats) {
    HGraphFixed *arg0 ;
    ostream *arg1 = (ostream *) &cout ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 1) || (items > 2)) 
    croak("Usage: HGraphFixed_printNodeWtStats(self,str);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_HGraphFixed) < 0) {
        croak("Type error in argument 1 of HGraphFixed_printNodeWtStats. Expected %s", SWIGTYPE_p_HGraphFixed->name);
        XSRETURN(1);
    }
    if (items > 1) {
        if (SWIG_ConvertPtr(ST(1),(void **) &arg1,SWIGTYPE_p_ostream) < 0) {
            croak("Type error in argument 2 of HGraphFixed_printNodeWtStats. Expected %s", SWIGTYPE_p_ostream->name);
            XSRETURN(1);
        }
    }
    arg0->printNodeWtStats(*arg1);
    XSRETURN(argvi);
}


XS(_wrap_HGraphFixed_printNodeDegreeStats) {
    HGraphFixed *arg0 ;
    ostream *arg1 = (ostream *) &cout ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 1) || (items > 2)) 
    croak("Usage: HGraphFixed_printNodeDegreeStats(self,str);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_HGraphFixed) < 0) {
        croak("Type error in argument 1 of HGraphFixed_printNodeDegreeStats. Expected %s", SWIGTYPE_p_HGraphFixed->name);
        XSRETURN(1);
    }
    if (items > 1) {
        if (SWIG_ConvertPtr(ST(1),(void **) &arg1,SWIGTYPE_p_ostream) < 0) {
            croak("Type error in argument 2 of HGraphFixed_printNodeDegreeStats. Expected %s", SWIGTYPE_p_ostream->name);
            XSRETURN(1);
        }
    }
    arg0->printNodeDegreeStats(*arg1);
    XSRETURN(argvi);
}


XS(_wrap_new_HGfromDB) {
    DB *arg0 ;
    int argvi = 0;
    HGfromDB *result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: new_HGfromDB(db);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_DB) < 0) {
        croak("Type error in argument 1 of new_HGfromDB. Expected %s", SWIGTYPE_p_DB->name);
        XSRETURN(1);
    }
    result = (HGfromDB *)new HGfromDB((DB const &)*arg0);
    ST(argvi) = sv_newmortal();
    SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_HGfromDB);
    XSRETURN(argvi);
}



/* -------- TYPE CONVERSION AND EQUIVALENCE RULES (BEGIN) -------- */

static void *_p_MLPartTo_p_BaseMLPart(void *x) {
    return (void *)((BaseMLPart *) ((MLPart *) x));
}
static void *_p_HGfromDBTo_p_HGraphFixed(void *x) {
    return (void *)((HGraphFixed *) ((HGfromDB *) x));
}
static swig_type_info _swigt__p_Constraints[] = {{"_p_Constraints", 0, "Constraints *"},{"_p_Constraints"},{0}};
static swig_type_info _swigt__p_PartitioningProblemForCapo[] = {{"PartitioningProblemForCapo", 0, "PartitioningProblemForCapo *"},{"PartitioningProblemForCapo"},{0}};
static swig_type_info _swigt__p_CapoPlacer[] = {{"CapoPlacer", 0, "CapoPlacer *"},{"CapoPlacer"},{0}};
static swig_type_info _swigt__p_MetaPlacer[] = {{"MetaPlacer", 0, "MetaPlacer *"},{"MetaPlacer"},{0}};
static swig_type_info _swigt__p_Orientation[] = {{"_p_Orientation", 0, "Orientation *"},{"_p_Orientation"},{0}};
static swig_type_info _swigt__p_dbCellType[] = {{"dbCellType", 0, "dbCellType *"},{"dbCellType"},{0}};
static swig_type_info _swigt__p_dbMasterCellType[] = {{"dbMasterCellType", 0, "dbMasterCellType *"},{"dbMasterCellType"},{0}};
static swig_type_info _swigt__p_PartitioningProblem[] = {{"PartitioningProblem", 0, "PartitioningProblem *"},{"PartitioningProblem"},{0}};
static swig_type_info _swigt__p_FillableHierarchy[] = {{"FillableHierarchy", 0, "FillableHierarchy *"},{"FillableHierarchy"},{0}};
static swig_type_info _swigt__p_ComparePinsByCellIndexAndDir[] = {{"ComparePinsByCellIndexAndDir", 0, "ComparePinsByCellIndexAndDir *"},{"ComparePinsByCellIndexAndDir"},{0}};
static swig_type_info _swigt__p_vector_Point_[] = {{"_p_vector_Point_", 0, "vector<Point> *"},{"_p_vector_Point_"},{0}};
static swig_type_info _swigt__p_itCellLocal[] = {{"_p_itCellLocal", 0, "itCellLocal *"},{"_p_itCellLocal"},{0}};
static swig_type_info _swigt__p_dbNetType[] = {{"dbNetType", 0, "dbNetType *"},{"dbNetType"},{0}};
static swig_type_info _swigt__p_CompareCellIdsByX[] = {{"CompareCellIdsByX", 0, "CompareCellIdsByX *"},{"CompareCellIdsByX"},{0}};
static swig_type_info _swigt__p_dbSpatial[] = {{"dbSpatial", 0, "dbSpatial *"},{"dbSpatial"},{0}};
static swig_type_info _swigt__p_vector__vector_unsigned___[] = {{"_p_vector__vector_unsigned___", 0, "vector< vector<unsigned> > *"},{"_p_vector__vector_unsigned___"},{0}};
static swig_type_info _swigt__p_HGWeight[] = {{"_p_HGWeight", 0, "HGWeight *"},{"_p_HGWeight"},{0}};
static swig_type_info _swigt__p_dbSite[] = {{"dbSite", 0, "dbSite *"},{"dbSite"},{0}};
static swig_type_info _swigt__p_ISPairLayer[] = {{"_p_ISPairLayer", 0, "ISPairLayer *"},{"_p_ISPairLayer"},{0}};
static swig_type_info _swigt__p_Placement[] = {{"_p_Placement", 0, "Placement *"},{"_p_Placement"},{0}};
static swig_type_info _swigt__p_Subset[] = {{"_p_Subset", 0, "Subset *"},{"_p_Subset"},{0}};
static swig_type_info _swigt__p_RBPlacement[] = {{"RBPlacement", 0, "RBPlacement *"},{"RBPlacement"},{0}};
static swig_type_info _swigt__p_dbPin[] = {{"dbPin", 0, "dbPin *"},{"dbPin"},{0}};
static swig_type_info _swigt__p_HGfromDB[] = {{"HGfromDB", 0, "HGfromDB *"},{"HGfromDB"},{0}};
static swig_type_info _swigt__p_dbGCellGrid[] = {{"dbGCellGrid", 0, "dbGCellGrid *"},{"dbGCellGrid"},{0}};
static swig_type_info _swigt__p_itGCellGridLocal[] = {{"_p_itGCellGridLocal", 0, "itGCellGridLocal *"},{"_p_itGCellGridLocal"},{0}};
static swig_type_info _swigt__p_vector_char__[] = {{"_p_vector_char__", 0, "vector<char*> *"},{"_p_vector_char__"},{0}};
static swig_type_info _swigt__p_vector_const_char__[] = {{"_p_vector_const_char__", 0, "vector<const char*> *"},{"_p_vector_const_char__"},{0}};
static swig_type_info _swigt__p_Point[] = {{"_p_Point", 0, "Point *"},{"_p_Point"},{0}};
static swig_type_info _swigt__p_HGFNode[] = {{"_p_HGFNode", 0, "HGFNode *"},{"_p_HGFNode"},{0}};
static swig_type_info _swigt__p_RBPCoreRow[] = {{"_p_RBPCoreRow", 0, "RBPCoreRow *"},{"_p_RBPCoreRow"},{0}};
static swig_type_info _swigt__p_itRBPCoreRow[] = {{"_p_itRBPCoreRow", 0, "itRBPCoreRow *"},{"_p_itRBPCoreRow"},{0}};
static swig_type_info _swigt__p_Partitioning[] = {{"Partitioning", 0, "Partitioning *"},{"Partitioning"},{0}};
static swig_type_info _swigt__p_HGraphWDimensions[] = {{"_p_HGraphWDimensions", 0, "HGraphWDimensions *"},{"_p_HGraphWDimensions"},{0}};
static swig_type_info _swigt__p_ctainerLayerGeoms[] = {{"_p_ctainerLayerGeoms", 0, "ctainerLayerGeoms *"},{"_p_ctainerLayerGeoms"},{0}};
static swig_type_info _swigt__r_q_const__ctainerLayerGeoms[] = {{"_r_q_const__ctainerLayerGeoms", 0, "ctainerLayerGeoms const &"},{"_r_q_const__ctainerLayerGeoms"},{0}};
static swig_type_info _swigt__p_Permutation[] = {{"_p_Permutation", 0, "Permutation *"},{"_p_Permutation"},{0}};
static swig_type_info _swigt__p_vector_const_CapoBlock__[] = {{"_p_vector_const_CapoBlock__", 0, "vector<const CapoBlock*> *"},{"_p_vector_const_CapoBlock__"},{0}};
static swig_type_info _swigt__p_Verbosity[] = {{"_p_Verbosity", 0, "Verbosity *"},{"_p_Verbosity"},{0}};
static swig_type_info _swigt__p_Symmetry[] = {{"Symmetry", 0, "Symmetry *"},{"Symmetry"},{0}};
static swig_type_info _swigt__p_RBCellCoord[] = {{"_p_RBCellCoord", 0, "RBCellCoord *"},{"_p_RBCellCoord"},{0}};
static swig_type_info _swigt__p_ComparePinsByDirAndName[] = {{"ComparePinsByDirAndName", 0, "ComparePinsByDirAndName *"},{"ComparePinsByDirAndName"},{0}};
static swig_type_info _swigt__p_bit_vector[] = {{"_p_bit_vector", 0, "bit_vector *"},{"_p_bit_vector"},{0}};
static swig_type_info _swigt__p_Rectangle[] = {{"_p_Rectangle", 0, "Rectangle *"},{"_p_Rectangle"},{0}};
static swig_type_info _swigt__r_q_const__dbLayout[] = {{"_r_q_const__dbLayout", 0, "dbLayout const &"},{"_r_q_const__dbLayout"},{"dbContext"},{0}};
static swig_type_info _swigt__p_PartitioningProblem_Attributes[] = {{"PartitioningProblem_Attributes", 0, "PartitioningProblem_Attributes *"},{"PartitioningProblem_Attributes"},{0}};
static swig_type_info _swigt__p_ifstream[] = {{"_p_ifstream", 0, "ifstream *"},{"_p_ifstream"},{0}};
static swig_type_info _swigt__p_itSite[] = {{"_p_itSite", 0, "itSite *"},{"_p_itSite"},{0}};
static swig_type_info _swigt__p_itLayerGeom[] = {{"_p_itLayerGeom", 0, "itLayerGeom *"},{"_p_itLayerGeom"},{0}};
static swig_type_info _swigt__p_dbLayerGeom[] = {{"dbLayerGeom", 0, "dbLayerGeom *"},{"dbLayerGeom"},{0}};
static swig_type_info _swigt__p_CompareNetsByDegree[] = {{"CompareNetsByDegree", 0, "CompareNetsByDegree *"},{"CompareNetsByDegree"},{0}};
static swig_type_info _swigt__p_itLayer[] = {{"_p_itLayer", 0, "itLayer *"},{"_p_itLayer"},{0}};
static swig_type_info _swigt__p_BaseMLPart[] = {{"BaseMLPart", 0, "BaseMLPart *"},{"BaseMLPart"},{"MLPart", _p_MLPartTo_p_BaseMLPart},{0}};
static swig_type_info _swigt__p_MLPart[] = {{"MLPart", 0, "MLPart *"},{"MLPart"},{0}};
static swig_type_info _swigt__p_vector_Orientation_[] = {{"_p_vector_Orientation_", 0, "vector<Orientation> *"},{"_p_vector_Orientation_"},{0}};
static swig_type_info _swigt__p_dbEasyAccess[] = {{"dbEasyAccess", 0, "dbEasyAccess *"},{"dbEasyAccess"},{0}};
static swig_type_info _swigt__p_dbLayer[] = {{"dbLayer", 0, "dbLayer *"},{"dbLayer"},{0}};
static swig_type_info _swigt__p_dbContext[] = {{"dbContext", 0, "dbContext *"},{"_r_q_const__dbLayout"},{"dbContext"},{0}};
static swig_type_info _swigt__p_DB[] = {{"DB", 0, "DB *"},{"DB"},{0}};
static swig_type_info _swigt__r_q_const__ctainerTracksGlobal[] = {{"_r_q_const__ctainerTracksGlobal", 0, "ctainerTracksGlobal const &"},{"_r_q_const__ctainerTracksGlobal"},{0}};
static swig_type_info _swigt__p_itRowGlobal[] = {{"_p_itRowGlobal", 0, "itRowGlobal *"},{"_p_itRowGlobal"},{0}};
static swig_type_info _swigt__r_q_const__ctainerGCellGridsGlobal[] = {{"_r_q_const__ctainerGCellGridsGlobal", 0, "ctainerGCellGridsGlobal const &"},{"_r_q_const__ctainerGCellGridsGlobal"},{0}};
static swig_type_info _swigt__p_itHGFNodeGlobal[] = {{"_p_itHGFNodeGlobal", 0, "itHGFNodeGlobal *"},{"_p_itHGFNodeGlobal"},{0}};
static swig_type_info _swigt__p_itHGFEdgeGlobal[] = {{"_p_itHGFEdgeGlobal", 0, "itHGFEdgeGlobal *"},{"_p_itHGFEdgeGlobal"},{0}};
static swig_type_info _swigt__p_CompareNetsByDirection[] = {{"CompareNetsByDirection", 0, "CompareNetsByDirection *"},{"CompareNetsByDirection"},{0}};
static swig_type_info _swigt__p_CompareObstaclesByXmin[] = {{"CompareObstaclesByXmin", 0, "CompareObstaclesByXmin *"},{"CompareObstaclesByXmin"},{0}};
static swig_type_info _swigt__p_itNetLocal[] = {{"_p_itNetLocal", 0, "itNetLocal *"},{"_p_itNetLocal"},{0}};
static swig_type_info _swigt__p_nodesMasInfo[] = {{"nodesMasInfo", 0, "nodesMasInfo *"},{"nodesMasInfo"},{0}};
static swig_type_info _swigt__p_vector_double_[] = {{"_p_vector_double_", 0, "vector<double> *"},{"_p_vector_double_"},{0}};
static swig_type_info _swigt__r_q_const__ctainerPinsLocal[] = {{"_r_q_const__ctainerPinsLocal", 0, "ctainerPinsLocal const &"},{"_r_q_const__ctainerPinsLocal"},{0}};
static swig_type_info _swigt__p_ctainerPinsLocal[] = {{"_p_ctainerPinsLocal", 0, "ctainerPinsLocal *"},{"_p_ctainerPinsLocal"},{0}};
static swig_type_info _swigt__p_ctainerCellsLocal[] = {{"_p_ctainerCellsLocal", 0, "ctainerCellsLocal *"},{"_p_ctainerCellsLocal"},{0}};
static swig_type_info _swigt__r_ctainerMasterPinsLocal[] = {{"_r_ctainerMasterPinsLocal", 0, "ctainerMasterPinsLocal &"},{"_r_ctainerMasterPinsLocal"},{0}};
static swig_type_info _swigt__r_q_const__ctainerMasterPinsLocal[] = {{"_r_q_const__ctainerMasterPinsLocal", 0, "ctainerMasterPinsLocal const &"},{"_r_q_const__ctainerMasterPinsLocal"},{0}};
static swig_type_info _swigt__r_ctainerPinsLocal[] = {{"_r_ctainerPinsLocal", 0, "ctainerPinsLocal &"},{"_r_ctainerPinsLocal"},{0}};
static swig_type_info _swigt__p_dbTemporal[] = {{"dbTemporal", 0, "dbTemporal *"},{"dbTemporal"},{0}};
static swig_type_info _swigt__p_dbCell[] = {{"dbCell", 0, "dbCell *"},{"dbCell"},{0}};
static swig_type_info _swigt__p_dbRoutingInfo[] = {{"_p_dbRoutingInfo", 0, "dbRoutingInfo *"},{"_p_dbRoutingInfo"},{0}};
static swig_type_info _swigt__p_eqClassMasterCells[] = {{"_p_eqClassMasterCells", 0, "eqClassMasterCells *"},{"_p_eqClassMasterCells"},{0}};
static swig_type_info _swigt__p_dbRow[] = {{"dbRow", 0, "dbRow *"},{"dbRow"},{0}};
static swig_type_info _swigt__p_eqClassMasterPins[] = {{"_p_eqClassMasterPins", 0, "eqClassMasterPins *"},{"_p_eqClassMasterPins"},{0}};
static swig_type_info _swigt__p_CompareNetsByCellIndex[] = {{"CompareNetsByCellIndex", 0, "CompareNetsByCellIndex *"},{"CompareNetsByCellIndex"},{0}};
static swig_type_info _swigt__p_CompareCellsByCellIndex[] = {{"CompareCellsByCellIndex", 0, "CompareCellsByCellIndex *"},{"CompareCellsByCellIndex"},{0}};
static swig_type_info _swigt__p_CompareNetsByName[] = {{"CompareNetsByName", 0, "CompareNetsByName *"},{"CompareNetsByName"},{0}};
static swig_type_info _swigt__p_CompareMCsByName[] = {{"CompareMCsByName", 0, "CompareMCsByName *"},{"CompareMCsByName"},{0}};
static swig_type_info _swigt__p_CompareCellsByName[] = {{"CompareCellsByName", 0, "CompareCellsByName *"},{"CompareCellsByName"},{0}};
static swig_type_info _swigt__p_itMasterPinLocal[] = {{"_p_itMasterPinLocal", 0, "itMasterPinLocal *"},{"_p_itMasterPinLocal"},{0}};
static swig_type_info _swigt__p_itPinLocal[] = {{"_p_itPinLocal", 0, "itPinLocal *"},{"_p_itPinLocal"},{0}};
static swig_type_info _swigt__p_CompareCellsByStatus[] = {{"CompareCellsByStatus", 0, "CompareCellsByStatus *"},{"CompareCellsByStatus"},{0}};
static swig_type_info _swigt__p_itMasterCell[] = {{"_p_itMasterCell", 0, "itMasterCell *"},{"_p_itMasterCell"},{0}};
static swig_type_info _swigt__p_dbMasterCell[] = {{"dbMasterCell", 0, "dbMasterCell *"},{"dbMasterCell"},{0}};
static swig_type_info _swigt__p_dbNet[] = {{"dbNet", 0, "dbNet *"},{"dbNet"},{0}};
static swig_type_info _swigt__p_DB_Parameters[] = {{"DB_Parameters", 0, "DB_Parameters *"},{"DB_Parameters"},{0}};
static swig_type_info _swigt__p_RBPlacement_Parameters[] = {{"RBPlacement_Parameters", 0, "RBPlacement_Parameters *"},{"RBPlacement_Parameters"},{0}};
static swig_type_info _swigt__p_CapoParameters[] = {{"CapoParameters", 0, "CapoParameters *"},{"CapoParameters"},{0}};
static swig_type_info _swigt__p_PartitioningProblem_Parameters[] = {{"PartitioningProblem_Parameters", 0, "PartitioningProblem_Parameters *"},{"PartitioningProblem_Parameters"},{0}};
static swig_type_info _swigt__p_BaseMLPart_Parameters[] = {{"BaseMLPart_Parameters", 0, "BaseMLPart_Parameters *"},{"BaseMLPart_Parameters"},{0}};
static swig_type_info _swigt__p_ClustHGraphParameters[] = {{"_p_ClustHGraphParameters", 0, "ClustHGraphParameters *"},{"_p_ClustHGraphParameters"},{0}};
static swig_type_info _swigt__p_HGraphParameters[] = {{"_p_HGraphParameters", 0, "HGraphParameters *"},{"_p_HGraphParameters"},{0}};
static swig_type_info _swigt__p_vector_unsigned_[] = {{"_p_vector_unsigned_", 0, "vector<unsigned> *"},{"_p_vector_unsigned_"},{0}};
static swig_type_info _swigt__p_dbTrack[] = {{"dbTrack", 0, "dbTrack *"},{"dbTrack"},{0}};
static swig_type_info _swigt__p_vector_char___[] = {{"_p_vector_char___", 0, "vector<char *> *"},{"_p_vector_char___"},{0}};
static swig_type_info _swigt__p_dbMasterPin[] = {{"dbMasterPin", 0, "dbMasterPin *"},{"dbMasterPin"},{0}};
static swig_type_info _swigt__p_itTrackLocal[] = {{"_p_itTrackLocal", 0, "itTrackLocal *"},{"_p_itTrackLocal"},{0}};
static swig_type_info _swigt__p_CapoSplitterParams[] = {{"CapoSplitterParams", 0, "CapoSplitterParams *"},{"CapoSplitterParams"},{0}};
static swig_type_info _swigt__p_MLPartParams[] = {{"_p_MLPartParams", 0, "MLPartParams *"},{"_p_MLPartParams"},{0}};
static swig_type_info _swigt__p_SmallPlParams[] = {{"_p_SmallPlParams", 0, "SmallPlParams *"},{"_p_SmallPlParams"},{0}};
static swig_type_info _swigt__p_MetaPlacerParams[] = {{"MetaPlacerParams", 0, "MetaPlacerParams *"},{"MetaPlacerParams"},{0}};
static swig_type_info _swigt__p_ostream[] = {{"_p_ostream", 0, "ostream *"},{"_p_ostream"},{0}};
static swig_type_info _swigt__p_CompareCellsByDir[] = {{"CompareCellsByDir", 0, "CompareCellsByDir *"},{"CompareCellsByDir"},{0}};
static swig_type_info _swigt__p_PartitioningBuffer[] = {{"PartitioningBuffer", 0, "PartitioningBuffer *"},{"PartitioningBuffer"},{0}};
static swig_type_info _swigt__p_HGraphFixed[] = {{"HGraphFixed", 0, "HGraphFixed *"},{"HGfromDB", _p_HGfromDBTo_p_HGraphFixed},{"HGraphFixed"},{0}};
static swig_type_info _swigt__p_PartitionerType[] = {{"_p_PartitionerType", 0, "PartitionerType *"},{"_p_PartitionerType"},{0}};
static swig_type_info _swigt__p_HGFEdge[] = {{"_p_HGFEdge", 0, "HGFEdge *"},{"_p_HGFEdge"},{0}};
static swig_type_info _swigt__p_vector_Orient_[] = {{"_p_vector_Orient_", 0, "vector<Orient> *"},{"_p_vector_Orient_"},{0}};
static swig_type_info _swigt__p_RBPSubRow[] = {{"_p_RBPSubRow", 0, "RBPSubRow *"},{"_p_RBPSubRow"},{0}};
static swig_type_info _swigt__p_vector_int_[] = {{"_p_vector_int_", 0, "vector<int> *"},{"_p_vector_int_"},{0}};
static swig_type_info _swigt__p_CapoBlock[] = {{"_p_CapoBlock", 0, "CapoBlock *"},{"_p_CapoBlock"},{0}};
static swig_type_info _swigt__p_itMasterPinGlobal[] = {{"_p_itMasterPinGlobal", 0, "itMasterPinGlobal *"},{"_p_itMasterPinGlobal"},{0}};
static swig_type_info _swigt__p_itPinGlobal[] = {{"_p_itPinGlobal", 0, "itPinGlobal *"},{"_p_itPinGlobal"},{0}};
static swig_type_info _swigt__p_itNetGlobal[] = {{"_p_itNetGlobal", 0, "itNetGlobal *"},{"_p_itNetGlobal"},{0}};
static swig_type_info _swigt__p_itCellGlobal[] = {{"_p_itCellGlobal", 0, "itCellGlobal *"},{"_p_itCellGlobal"},{0}};
static swig_type_info _swigt__p_RBRowPtrs[] = {{"_p_RBRowPtrs", 0, "RBRowPtrs *"},{"_p_RBRowPtrs"},{0}};
static swig_type_info _swigt__p_Orient[] = {{"Orient", 0, "Orient *"},{"Orient"},{0}};
static swig_type_info _swigt__p_BBox[] = {{"_p_BBox", 0, "BBox *"},{"_p_BBox"},{0}};
static swig_type_info _swigt__p_dbNetlist[] = {{"dbNetlist", 0, "dbNetlist *"},{"dbNetlist"},{0}};
static swig_type_info _swigt__p_PlacementWOrient[] = {{"_p_PlacementWOrient", 0, "PlacementWOrient *"},{"_p_PlacementWOrient"},{0}};
static swig_type_info _swigt__p_masterNodeInfo[] = {{"masterNodeInfo", 0, "masterNodeInfo *"},{"masterNodeInfo"},{0}};
static swig_type_info _swigt__p_vector_BBox_[] = {{"_p_vector_BBox_", 0, "vector<BBox> *"},{"_p_vector_BBox_"},{0}};
static swig_type_info _swigt__p_vector_vector_double___[] = {{"_p_vector_vector_double___", 0, "vector<vector<double> > *"},{"_p_vector_vector_double___"},{0}};
static swig_type_info _swigt__p_HGNodeNamesMap[] = {{"_p_HGNodeNamesMap", 0, "HGNodeNamesMap *"},{"_p_HGNodeNamesMap"},{0}};
static swig_type_info _swigt__p_HGNetNamesMap[] = {{"_p_HGNetNamesMap", 0, "HGNetNamesMap *"},{"_p_HGNetNamesMap"},{0}};
static swig_type_info _swigt__p_vector_IntervalSeqLayer_[] = {{"_p_vector_IntervalSeqLayer_", 0, "vector<IntervalSeqLayer> *"},{"_p_vector_IntervalSeqLayer_"},{0}};
static swig_type_info _swigt__p_dbMasterPinType[] = {{"dbMasterPinType", 0, "dbMasterPinType *"},{"dbMasterPinType"},{0}};

static swig_type_info *swig_types_initial[] = {
_swigt__p_Constraints, 
_swigt__p_PartitioningProblemForCapo, 
_swigt__p_CapoPlacer, 
_swigt__p_MetaPlacer, 
_swigt__p_Orientation, 
_swigt__p_dbCellType, 
_swigt__p_dbMasterCellType, 
_swigt__p_PartitioningProblem, 
_swigt__p_FillableHierarchy, 
_swigt__p_ComparePinsByCellIndexAndDir, 
_swigt__p_vector_Point_, 
_swigt__p_itCellLocal, 
_swigt__p_dbNetType, 
_swigt__p_CompareCellIdsByX, 
_swigt__p_dbSpatial, 
_swigt__p_vector__vector_unsigned___, 
_swigt__p_HGWeight, 
_swigt__p_dbSite, 
_swigt__p_ISPairLayer, 
_swigt__p_Placement, 
_swigt__p_Subset, 
_swigt__p_RBPlacement, 
_swigt__p_dbPin, 
_swigt__p_HGfromDB, 
_swigt__p_dbGCellGrid, 
_swigt__p_itGCellGridLocal, 
_swigt__p_vector_char__, 
_swigt__p_vector_const_char__, 
_swigt__p_Point, 
_swigt__p_HGFNode, 
_swigt__p_RBPCoreRow, 
_swigt__p_itRBPCoreRow, 
_swigt__p_Partitioning, 
_swigt__p_HGraphWDimensions, 
_swigt__p_ctainerLayerGeoms, 
_swigt__r_q_const__ctainerLayerGeoms, 
_swigt__p_Permutation, 
_swigt__p_vector_const_CapoBlock__, 
_swigt__p_Verbosity, 
_swigt__p_Symmetry, 
_swigt__p_RBCellCoord, 
_swigt__p_ComparePinsByDirAndName, 
_swigt__p_bit_vector, 
_swigt__p_Rectangle, 
_swigt__r_q_const__dbLayout, 
_swigt__p_PartitioningProblem_Attributes, 
_swigt__p_ifstream, 
_swigt__p_itSite, 
_swigt__p_itLayerGeom, 
_swigt__p_dbLayerGeom, 
_swigt__p_CompareNetsByDegree, 
_swigt__p_itLayer, 
_swigt__p_BaseMLPart, 
_swigt__p_MLPart, 
_swigt__p_vector_Orientation_, 
_swigt__p_dbEasyAccess, 
_swigt__p_dbLayer, 
_swigt__p_dbContext, 
_swigt__p_DB, 
_swigt__r_q_const__ctainerTracksGlobal, 
_swigt__p_itRowGlobal, 
_swigt__r_q_const__ctainerGCellGridsGlobal, 
_swigt__p_itHGFNodeGlobal, 
_swigt__p_itHGFEdgeGlobal, 
_swigt__p_CompareNetsByDirection, 
_swigt__p_CompareObstaclesByXmin, 
_swigt__p_itNetLocal, 
_swigt__p_nodesMasInfo, 
_swigt__p_vector_double_, 
_swigt__r_q_const__ctainerPinsLocal, 
_swigt__p_ctainerPinsLocal, 
_swigt__p_ctainerCellsLocal, 
_swigt__r_ctainerMasterPinsLocal, 
_swigt__r_q_const__ctainerMasterPinsLocal, 
_swigt__r_ctainerPinsLocal, 
_swigt__p_dbTemporal, 
_swigt__p_dbCell, 
_swigt__p_dbRoutingInfo, 
_swigt__p_eqClassMasterCells, 
_swigt__p_dbRow, 
_swigt__p_eqClassMasterPins, 
_swigt__p_CompareNetsByCellIndex, 
_swigt__p_CompareCellsByCellIndex, 
_swigt__p_CompareNetsByName, 
_swigt__p_CompareMCsByName, 
_swigt__p_CompareCellsByName, 
_swigt__p_itMasterPinLocal, 
_swigt__p_itPinLocal, 
_swigt__p_CompareCellsByStatus, 
_swigt__p_itMasterCell, 
_swigt__p_dbMasterCell, 
_swigt__p_dbNet, 
_swigt__p_DB_Parameters, 
_swigt__p_RBPlacement_Parameters, 
_swigt__p_CapoParameters, 
_swigt__p_PartitioningProblem_Parameters, 
_swigt__p_BaseMLPart_Parameters, 
_swigt__p_ClustHGraphParameters, 
_swigt__p_HGraphParameters, 
_swigt__p_vector_unsigned_, 
_swigt__p_dbTrack, 
_swigt__p_vector_char___, 
_swigt__p_dbMasterPin, 
_swigt__p_itTrackLocal, 
_swigt__p_CapoSplitterParams, 
_swigt__p_MLPartParams, 
_swigt__p_SmallPlParams, 
_swigt__p_MetaPlacerParams, 
_swigt__p_ostream, 
_swigt__p_CompareCellsByDir, 
_swigt__p_PartitioningBuffer, 
_swigt__p_HGraphFixed, 
_swigt__p_PartitionerType, 
_swigt__p_HGFEdge, 
_swigt__p_vector_Orient_, 
_swigt__p_RBPSubRow, 
_swigt__p_vector_int_, 
_swigt__p_CapoBlock, 
_swigt__p_itMasterPinGlobal, 
_swigt__p_itPinGlobal, 
_swigt__p_itNetGlobal, 
_swigt__p_itCellGlobal, 
_swigt__p_RBRowPtrs, 
_swigt__p_Orient, 
_swigt__p_BBox, 
_swigt__p_dbNetlist, 
_swigt__p_PlacementWOrient, 
_swigt__p_masterNodeInfo, 
_swigt__p_vector_BBox_, 
_swigt__p_vector_vector_double___, 
_swigt__p_HGNodeNamesMap, 
_swigt__p_HGNetNamesMap, 
_swigt__p_vector_IntervalSeqLayer_, 
_swigt__p_dbMasterPinType, 
0
};


/* -------- TYPE CONVERSION AND EQUIVALENCE RULES (END) -------- */

XS(_wrap_perl5_UCLAscript_var_init) {
    dXSARGS;
    SV *sv;
    swig_setiv("UCLAscriptc::DumbPlacerSeed", (long) DumbPlacerSeed);
    swig_setiv("UCLAscriptc::BaryPlacerSeed", (long) BaryPlacerSeed);
    swig_setiv("UCLAscriptc::WeiszPlacerSeed", (long) WeiszPlacerSeed);
    swig_setiv("UCLAscriptc::Never", (long) Never);
    swig_setiv("UCLAscriptc::AtTheEnd", (long) AtTheEnd);
    swig_setiv("UCLAscriptc::AtEveryLayer", (long) AtEveryLayer);
    swig_setiv("UCLAscriptc::dbMasterCellType_COVER", (long) dbMasterCellType::COVER);
    swig_setiv("UCLAscriptc::dbMasterCellType_RING", (long) dbMasterCellType::RING);
    swig_setiv("UCLAscriptc::dbMasterCellType_BLOCK", (long) dbMasterCellType::BLOCK);
    swig_setiv("UCLAscriptc::dbMasterCellType_CORE", (long) dbMasterCellType::CORE);
    swig_setiv("UCLAscriptc::dbMasterCellType_PAD", (long) dbMasterCellType::PAD);
    swig_setiv("UCLAscriptc::dbMasterCellType_ENDCAP", (long) dbMasterCellType::ENDCAP);
    swig_setiv("UCLAscriptc::dbMasterCellType_EXTPIN", (long) dbMasterCellType::EXTPIN);
    swig_setiv("UCLAscriptc::dbMasterCellType_MCUNKNOWN", (long) dbMasterCellType::MCUNKNOWN);
    swig_setiv("UCLAscriptc::dbMasterCellType_FLIPFLOP", (long) dbMasterCellType::FLIPFLOP);
    swig_setiv("UCLAscriptc::dbMasterCellType_LATCH", (long) dbMasterCellType::LATCH);
    swig_setiv("UCLAscriptc::dbMasterCellType_INVERTER", (long) dbMasterCellType::INVERTER);
    swig_setiv("UCLAscriptc::dbMasterCellType_BUFFER", (long) dbMasterCellType::BUFFER);
    swig_setiv("UCLAscriptc::dbMasterCellType_NAND", (long) dbMasterCellType::NAND);
    swig_setiv("UCLAscriptc::dbMasterCellType_NOR", (long) dbMasterCellType::NOR);
    swig_setiv("UCLAscriptc::dbMasterCellType_CoreUNKNOWN", (long) dbMasterCellType::CoreUNKNOWN);
    swig_setiv("UCLAscriptc::dbMasterCellType_INPUT", (long) dbMasterCellType::INPUT);
    swig_setiv("UCLAscriptc::dbMasterCellType_OUTPUT", (long) dbMasterCellType::OUTPUT);
    swig_setiv("UCLAscriptc::dbMasterCellType_INOUT", (long) dbMasterCellType::INOUT);
    swig_setiv("UCLAscriptc::dbMasterCellType_POWER", (long) dbMasterCellType::POWER);
    swig_setiv("UCLAscriptc::dbMasterCellType_SPACER", (long) dbMasterCellType::SPACER);
    swig_setiv("UCLAscriptc::dbMasterCellType_PadUNKNOWN", (long) dbMasterCellType::PadUNKNOWN);
    swig_setiv("UCLAscriptc::dbCellType_MacroUNINITIALIZED", (long) dbCellType::MacroUNINITIALIZED);
    swig_setiv("UCLAscriptc::dbCellType_IO", (long) dbCellType::IO);
    swig_setiv("UCLAscriptc::dbCellType_BLOCK", (long) dbCellType::BLOCK);
    swig_setiv("UCLAscriptc::dbCellType_CORE", (long) dbCellType::CORE);
    swig_setiv("UCLAscriptc::dbCellType_MacroOTHER", (long) dbCellType::MacroOTHER);
    swig_setiv("UCLAscriptc::dbCellType_MacroUNKNOWN", (long) dbCellType::MacroUNKNOWN);
    swig_setiv("UCLAscriptc::dbCellType_PI", (long) dbCellType::PI);
    swig_setiv("UCLAscriptc::dbCellType_PO", (long) dbCellType::PO);
    swig_setiv("UCLAscriptc::dbCellType_PIO", (long) dbCellType::PIO);
    swig_setiv("UCLAscriptc::dbCellType_POTHER", (long) dbCellType::POTHER);
    swig_setiv("UCLAscriptc::dbCellType_PUNKNOWN", (long) dbCellType::PUNKNOWN);
    swig_setiv("UCLAscriptc::dbCellType_SC", (long) dbCellType::SC);
    swig_setiv("UCLAscriptc::dbCellType_CC", (long) dbCellType::CC);
    swig_setiv("UCLAscriptc::dbCellType_CoreOTHER", (long) dbCellType::CoreOTHER);
    swig_setiv("UCLAscriptc::dbNetType_SIGNAL", (long) dbNetType::SIGNAL);
    swig_setiv("UCLAscriptc::dbNetType_POWER", (long) dbNetType::POWER);
    swig_setiv("UCLAscriptc::dbNetType_GROUND", (long) dbNetType::GROUND);
    swig_setiv("UCLAscriptc::dbNetType_CLOCK", (long) dbNetType::CLOCK);
    swig_setiv("UCLAscriptc::dbNetType_TIEOFF", (long) dbNetType::TIEOFF);
    swig_setiv("UCLAscriptc::dbNetType_ANALOG", (long) dbNetType::ANALOG);
    swig_setiv("UCLAscriptc::dbNetType_UNKNOWN", (long) dbNetType::UNKNOWN);
    swig_setiv("UCLAscriptc::dbMasterPinType_ShapeABUTMENT", (long) dbMasterPinType::ShapeABUTMENT);
    swig_setiv("UCLAscriptc::dbMasterPinType_ShapeFEEDTHROUGH", (long) dbMasterPinType::ShapeFEEDTHROUGH);
    swig_setiv("UCLAscriptc::dbMasterPinType_ShapeRING", (long) dbMasterPinType::ShapeRING);
    swig_setiv("UCLAscriptc::dbMasterPinType_ShapeUNKNOWN", (long) dbMasterPinType::ShapeUNKNOWN);
    swig_setiv("UCLAscriptc::dbMasterPinType_SIGNAL", (long) dbMasterPinType::SIGNAL);
    swig_setiv("UCLAscriptc::dbMasterPinType_ANALOG", (long) dbMasterPinType::ANALOG);
    swig_setiv("UCLAscriptc::dbMasterPinType_POWER", (long) dbMasterPinType::POWER);
    swig_setiv("UCLAscriptc::dbMasterPinType_GROUND", (long) dbMasterPinType::GROUND);
    swig_setiv("UCLAscriptc::dbMasterPinType_CLOCK", (long) dbMasterPinType::CLOCK);
    swig_setiv("UCLAscriptc::dbMasterPinType_TIEOFF", (long) dbMasterPinType::TIEOFF);
    swig_setiv("UCLAscriptc::dbMasterPinType_UseUNKNOWN", (long) dbMasterPinType::UseUNKNOWN);
    swig_setiv("UCLAscriptc::dbMasterPinType_OUT", (long) dbMasterPinType::OUT);
    swig_setiv("UCLAscriptc::dbMasterPinType_IN", (long) dbMasterPinType::IN);
    swig_setiv("UCLAscriptc::dbMasterPinType_INOUT", (long) dbMasterPinType::INOUT);
    swig_setiv("UCLAscriptc::dbMasterPinType_OUTTRISTATE", (long) dbMasterPinType::OUTTRISTATE);
    swig_setiv("UCLAscriptc::dbMasterPinType_DirFEEDTHROUGH", (long) dbMasterPinType::DirFEEDTHROUGH);
    swig_setiv("UCLAscriptc::dbMasterPinType_DirUNKNOWN", (long) dbMasterPinType::DirUNKNOWN);
    swig_setiv("UCLAscriptc::dbSite_PAD", (long) dbSite::PAD);
    swig_setiv("UCLAscriptc::dbSite_CORE", (long) dbSite::CORE);
    swig_setiv("UCLAscriptc::dbLayer_MASTERSLICE", (long) dbLayer::MASTERSLICE);
    swig_setiv("UCLAscriptc::dbLayer_CUT", (long) dbLayer::CUT);
    swig_setiv("UCLAscriptc::dbLayer_OVERLAP", (long) dbLayer::OVERLAP);
    swig_setiv("UCLAscriptc::dbLayer_ROUTING", (long) dbLayer::ROUTING);
    swig_setiv("UCLAscriptc::dbLayer_HORIZ", (long) dbLayer::HORIZ);
    swig_setiv("UCLAscriptc::dbLayer_VERT", (long) dbLayer::VERT);
    swig_setiv("UCLAscriptc::dbLayer_NOPREFERRED", (long) dbLayer::NOPREFERRED);
    swig_setiv("UCLAscriptc::dbRow_HORIZ", (long) dbRow::HORIZ);
    swig_setiv("UCLAscriptc::dbRow_VERT", (long) dbRow::VERT);
    swig_setiv("UCLAscriptc::dbEasyAccess_IntRandom", (long) dbEasyAccess::IntRandom);
    swig_setiv("UCLAscriptc::dbEasyAccess_IntLessRandom", (long) dbEasyAccess::IntLessRandom);
    swig_setiv("UCLAscriptc::RBPlacement_Parameters_EQUAL_SPACE", (long) RBPlacement_Parameters::EQUAL_SPACE);
    swig_setiv("UCLAscriptc::RBPlacement_Parameters_WITH_PIN_ALG1", (long) RBPlacement_Parameters::WITH_PIN_ALG1);
    swig_setiv("UCLAscriptc::RBPlacement_Parameters_WITH_PIN_ALG2", (long) RBPlacement_Parameters::WITH_PIN_ALG2);
    swig_setiv("UCLAscriptc::BaseMLPart_Parameters_NeverSave", (long) BaseMLPart_Parameters::NeverSave);
    swig_setiv("UCLAscriptc::BaseMLPart_Parameters_AtAllLastLevels", (long) BaseMLPart_Parameters::AtAllLastLevels);
    swig_setiv("UCLAscriptc::BaseMLPart_Parameters_AtAllLevels", (long) BaseMLPart_Parameters::AtAllLevels);
    swig_setiv("UCLAscriptc::BaseMLPart_Parameters_AtFirstLevelOfFirst", (long) BaseMLPart_Parameters::AtFirstLevelOfFirst);
    swig_setiv("UCLAscriptc::BaseMLPart_Parameters_AtLastLevelOfFirst", (long) BaseMLPart_Parameters::AtLastLevelOfFirst);
    swig_setiv("UCLAscriptc::BaseMLPart_Parameters_AtAllLevelsOfFirst", (long) BaseMLPart_Parameters::AtAllLevelsOfFirst);
    swig_setiv("UCLAscriptc::BaseMLPart_Parameters_NoVcycles", (long) BaseMLPart_Parameters::NoVcycles);
    swig_setiv("UCLAscriptc::BaseMLPart_Parameters_Exclusive", (long) BaseMLPart_Parameters::Exclusive);
    swig_setiv("UCLAscriptc::BaseMLPart_Parameters_Relaxed", (long) BaseMLPart_Parameters::Relaxed);
    swig_setiv("UCLAscriptc::BaseMLPart_Parameters_Relaxed2", (long) BaseMLPart_Parameters::Relaxed2);
    swig_setiv("UCLAscriptc::BaseMLPart_Parameters_Comprehensive", (long) BaseMLPart_Parameters::Comprehensive);
    swig_setiv("UCLAscriptc::BaseMLPart_Parameters_ALL", (long) BaseMLPart_Parameters::ALL);
    swig_setiv("UCLAscriptc::BaseMLPart_Parameters_TOPONLY", (long) BaseMLPart_Parameters::TOPONLY);
    swig_setiv("UCLAscriptc::BaseMLPart_Parameters_ALLBUTLAST", (long) BaseMLPart_Parameters::ALLBUTLAST);
    swig_setiv("UCLAscriptc::BaseMLPart_Parameters_NEVER", (long) BaseMLPart_Parameters::NEVER);
    XSRETURN(1);
}
#ifdef __cplusplus
extern "C"
#endif
XS(SWIG_init) {
    dXSARGS;
    int i;
    char *file = __FILE__;
    for (i = 0; swig_types_initial[i]; i++) {
        swig_types[i] = SWIG_TypeRegister(swig_types_initial[i]);
    }
    newXS("UCLAscriptc::var_UCLAscript_init", _wrap_perl5_UCLAscript_var_init, file);
    newXS("UCLAscriptc::new_dbMasterCellType", _wrap_new_dbMasterCellType, file);
    newXS("UCLAscriptc::dbMasterCellType_setCoreClass", _wrap_dbMasterCellType_setCoreClass, file);
    newXS("UCLAscriptc::dbMasterCellType_isCover", _wrap_dbMasterCellType_isCover, file);
    newXS("UCLAscriptc::dbMasterCellType_isRing", _wrap_dbMasterCellType_isRing, file);
    newXS("UCLAscriptc::dbMasterCellType_isBlock", _wrap_dbMasterCellType_isBlock, file);
    newXS("UCLAscriptc::dbMasterCellType_isCore", _wrap_dbMasterCellType_isCore, file);
    newXS("UCLAscriptc::dbMasterCellType_isPad", _wrap_dbMasterCellType_isPad, file);
    newXS("UCLAscriptc::dbMasterCellType_isEndCap", _wrap_dbMasterCellType_isEndCap, file);
    newXS("UCLAscriptc::dbMasterCellType_isExtPin", _wrap_dbMasterCellType_isExtPin, file);
    newXS("UCLAscriptc::dbMasterCellType_isUnknown", _wrap_dbMasterCellType_isUnknown, file);
    newXS("UCLAscriptc::dbMasterCellType_isFlipFlop", _wrap_dbMasterCellType_isFlipFlop, file);
    newXS("UCLAscriptc::dbMasterCellType_isLatch", _wrap_dbMasterCellType_isLatch, file);
    newXS("UCLAscriptc::dbMasterCellType_isInverter", _wrap_dbMasterCellType_isInverter, file);
    newXS("UCLAscriptc::dbMasterCellType_isBuffer", _wrap_dbMasterCellType_isBuffer, file);
    newXS("UCLAscriptc::dbMasterCellType_isNAND", _wrap_dbMasterCellType_isNAND, file);
    newXS("UCLAscriptc::dbMasterCellType_isNOR", _wrap_dbMasterCellType_isNOR, file);
    newXS("UCLAscriptc::dbMasterCellType_isCoreUnknown", _wrap_dbMasterCellType_isCoreUnknown, file);
    newXS("UCLAscriptc::dbMasterCellType_isPI", _wrap_dbMasterCellType_isPI, file);
    newXS("UCLAscriptc::dbMasterCellType_isPO", _wrap_dbMasterCellType_isPO, file);
    newXS("UCLAscriptc::dbMasterCellType_isPIO", _wrap_dbMasterCellType_isPIO, file);
    newXS("UCLAscriptc::dbMasterCellType_isPPower", _wrap_dbMasterCellType_isPPower, file);
    newXS("UCLAscriptc::dbMasterCellType_isPSpacer", _wrap_dbMasterCellType_isPSpacer, file);
    newXS("UCLAscriptc::dbMasterCellType_isPUnknown", _wrap_dbMasterCellType_isPUnknown, file);
    newXS("UCLAscriptc::new_dbCellType", _wrap_new_dbCellType, file);
    newXS("UCLAscriptc::dbCellType_isInitialized", _wrap_dbCellType_isInitialized, file);
    newXS("UCLAscriptc::dbCellType_isIO", _wrap_dbCellType_isIO, file);
    newXS("UCLAscriptc::dbCellType_isBlock", _wrap_dbCellType_isBlock, file);
    newXS("UCLAscriptc::dbCellType_isCore", _wrap_dbCellType_isCore, file);
    newXS("UCLAscriptc::dbCellType_isOther", _wrap_dbCellType_isOther, file);
    newXS("UCLAscriptc::dbCellType_isUnknown", _wrap_dbCellType_isUnknown, file);
    newXS("UCLAscriptc::dbCellType_isPI", _wrap_dbCellType_isPI, file);
    newXS("UCLAscriptc::dbCellType_isPO", _wrap_dbCellType_isPO, file);
    newXS("UCLAscriptc::dbCellType_isPIO", _wrap_dbCellType_isPIO, file);
    newXS("UCLAscriptc::dbCellType_isPOther", _wrap_dbCellType_isPOther, file);
    newXS("UCLAscriptc::dbCellType_isPUnknown", _wrap_dbCellType_isPUnknown, file);
    newXS("UCLAscriptc::dbCellType_isCC", _wrap_dbCellType_isCC, file);
    newXS("UCLAscriptc::dbCellType_isSC", _wrap_dbCellType_isSC, file);
    newXS("UCLAscriptc::dbCellType_isCoreOther", _wrap_dbCellType_isCoreOther, file);
    newXS("UCLAscriptc::new_dbNetType", _wrap_new_dbNetType, file);
    newXS("UCLAscriptc::dbNetType_isSignal", _wrap_dbNetType_isSignal, file);
    newXS("UCLAscriptc::dbNetType_isPower", _wrap_dbNetType_isPower, file);
    newXS("UCLAscriptc::dbNetType_isGround", _wrap_dbNetType_isGround, file);
    newXS("UCLAscriptc::dbNetType_isClock", _wrap_dbNetType_isClock, file);
    newXS("UCLAscriptc::dbNetType_isTieOff", _wrap_dbNetType_isTieOff, file);
    newXS("UCLAscriptc::dbNetType_isAnalog", _wrap_dbNetType_isAnalog, file);
    newXS("UCLAscriptc::dbNetType_isUnknown", _wrap_dbNetType_isUnknown, file);
    newXS("UCLAscriptc::new_dbMasterPinType", _wrap_new_dbMasterPinType, file);
    newXS("UCLAscriptc::dbMasterPinType_isShapeAbutment", _wrap_dbMasterPinType_isShapeAbutment, file);
    newXS("UCLAscriptc::dbMasterPinType_isShapeFeedthrough", _wrap_dbMasterPinType_isShapeFeedthrough, file);
    newXS("UCLAscriptc::dbMasterPinType_isShapeRing", _wrap_dbMasterPinType_isShapeRing, file);
    newXS("UCLAscriptc::dbMasterPinType_isShapeUnknown", _wrap_dbMasterPinType_isShapeUnknown, file);
    newXS("UCLAscriptc::dbMasterPinType_isUseSignal", _wrap_dbMasterPinType_isUseSignal, file);
    newXS("UCLAscriptc::dbMasterPinType_isUseAnalog", _wrap_dbMasterPinType_isUseAnalog, file);
    newXS("UCLAscriptc::dbMasterPinType_isUsePower", _wrap_dbMasterPinType_isUsePower, file);
    newXS("UCLAscriptc::dbMasterPinType_isUseGround", _wrap_dbMasterPinType_isUseGround, file);
    newXS("UCLAscriptc::dbMasterPinType_isUseClock", _wrap_dbMasterPinType_isUseClock, file);
    newXS("UCLAscriptc::dbMasterPinType_isUseTieoff", _wrap_dbMasterPinType_isUseTieoff, file);
    newXS("UCLAscriptc::dbMasterPinType_isUseUnknown", _wrap_dbMasterPinType_isUseUnknown, file);
    newXS("UCLAscriptc::dbMasterPinType_isDirOutput", _wrap_dbMasterPinType_isDirOutput, file);
    newXS("UCLAscriptc::dbMasterPinType_isDirInput", _wrap_dbMasterPinType_isDirInput, file);
    newXS("UCLAscriptc::dbMasterPinType_isDirInOut", _wrap_dbMasterPinType_isDirInOut, file);
    newXS("UCLAscriptc::dbMasterPinType_isDirOutputTristate", _wrap_dbMasterPinType_isDirOutputTristate, file);
    newXS("UCLAscriptc::dbMasterPinType_isDirFeedthrough", _wrap_dbMasterPinType_isDirFeedthrough, file);
    newXS("UCLAscriptc::dbMasterPinType_isDirUnknown", _wrap_dbMasterPinType_isDirUnknown, file);
    newXS("UCLAscriptc::new_dbContext", _wrap_new_dbContext, file);
    newXS("UCLAscriptc::delete_dbContext", _wrap_delete_dbContext, file);
    newXS("UCLAscriptc::dbContext_getMinFeatureX", _wrap_dbContext_getMinFeatureX, file);
    newXS("UCLAscriptc::dbContext_getMinFeatureY", _wrap_dbContext_getMinFeatureY, file);
    newXS("UCLAscriptc::dbContext_getUnits", _wrap_dbContext_getUnits, file);
    newXS("UCLAscriptc::dbContext_getBBox", _wrap_dbContext_getBBox, file);
    newXS("UCLAscriptc::dbContext_getNumSites", _wrap_dbContext_getNumSites, file);
    newXS("UCLAscriptc::dbContext_getNumLayers", _wrap_dbContext_getNumLayers, file);
    newXS("UCLAscriptc::dbContext_getNumRows", _wrap_dbContext_getNumRows, file);
    newXS("UCLAscriptc::dbContext_getNumTracks", _wrap_dbContext_getNumTracks, file);
    newXS("UCLAscriptc::dbContext_beginSites", _wrap_dbContext_beginSites, file);
    newXS("UCLAscriptc::dbContext_endSites", _wrap_dbContext_endSites, file);
    newXS("UCLAscriptc::dbContext_getSiteByIdx", _wrap_dbContext_getSiteByIdx, file);
    newXS("UCLAscriptc::dbContext_beginLayers", _wrap_dbContext_beginLayers, file);
    newXS("UCLAscriptc::dbContext_endLayers", _wrap_dbContext_endLayers, file);
    newXS("UCLAscriptc::dbContext_getLayerByIdx", _wrap_dbContext_getLayerByIdx, file);
    newXS("UCLAscriptc::dbContext_rowsBegin", _wrap_dbContext_rowsBegin, file);
    newXS("UCLAscriptc::dbContext_rowsEnd", _wrap_dbContext_rowsEnd, file);
    newXS("UCLAscriptc::dbContext_getRowByIdx", _wrap_dbContext_getRowByIdx, file);
    newXS("UCLAscriptc::dbContext_beginTracks", _wrap_dbContext_beginTracks, file);
    newXS("UCLAscriptc::dbContext_endTracks", _wrap_dbContext_endTracks, file);
    newXS("UCLAscriptc::dbContext_getTracks", _wrap_dbContext_getTracks, file);
    newXS("UCLAscriptc::dbContext_getTrackByIdx", _wrap_dbContext_getTrackByIdx, file);
    newXS("UCLAscriptc::dbContext_getNumHorizTracks", _wrap_dbContext_getNumHorizTracks, file);
    newXS("UCLAscriptc::dbContext_getNumVertTracks", _wrap_dbContext_getNumVertTracks, file);
    newXS("UCLAscriptc::dbContext_beginGCellGrids", _wrap_dbContext_beginGCellGrids, file);
    newXS("UCLAscriptc::dbContext_endGCellGrids", _wrap_dbContext_endGCellGrids, file);
    newXS("UCLAscriptc::dbContext_getGCellGrids", _wrap_dbContext_getGCellGrids, file);
    newXS("UCLAscriptc::dbContext_addGCellGrid", _wrap_dbContext_addGCellGrid, file);
    newXS("UCLAscriptc::dbContext_isConsistent", _wrap_dbContext_isConsistent, file);
    newXS("UCLAscriptc::new_dbLayerGeom", _wrap_new_dbLayerGeom, file);
    newXS("UCLAscriptc::dbLayerGeom_getPolygon", _wrap_dbLayerGeom_getPolygon, file);
    newXS("UCLAscriptc::dbLayerGeom_isVia", _wrap_dbLayerGeom_isVia, file);
    newXS("UCLAscriptc::new_dbSite", _wrap_new_dbSite, file);
    newXS("UCLAscriptc::delete_dbSite", _wrap_delete_dbSite, file);
    newXS("UCLAscriptc::dbSite_getName", _wrap_dbSite_getName, file);
    newXS("UCLAscriptc::dbSite_getType", _wrap_dbSite_getType, file);
    newXS("UCLAscriptc::dbSite_getSymmetry", _wrap_dbSite_getSymmetry, file);
    newXS("UCLAscriptc::dbSite_getHeight", _wrap_dbSite_getHeight, file);
    newXS("UCLAscriptc::dbSite_getWidth", _wrap_dbSite_getWidth, file);
    newXS("UCLAscriptc::new_dbLayer", _wrap_new_dbLayer, file);
    newXS("UCLAscriptc::delete_dbLayer", _wrap_delete_dbLayer, file);
    newXS("UCLAscriptc::dbLayer_getName", _wrap_dbLayer_getName, file);
    newXS("UCLAscriptc::dbLayer_getType", _wrap_dbLayer_getType, file);
    newXS("UCLAscriptc::dbLayer_getDirection", _wrap_dbLayer_getDirection, file);
    newXS("UCLAscriptc::dbLayer_getPitch", _wrap_dbLayer_getPitch, file);
    newXS("UCLAscriptc::dbLayer_getHeight", _wrap_dbLayer_getHeight, file);
    newXS("UCLAscriptc::dbLayer_getThickness", _wrap_dbLayer_getThickness, file);
    newXS("UCLAscriptc::dbLayer_getShrinkage", _wrap_dbLayer_getShrinkage, file);
    newXS("UCLAscriptc::dbLayer_getCapMult", _wrap_dbLayer_getCapMult, file);
    newXS("UCLAscriptc::dbLayer_getEdgeCap", _wrap_dbLayer_getEdgeCap, file);
    newXS("UCLAscriptc::dbLayer_getWidth", _wrap_dbLayer_getWidth, file);
    newXS("UCLAscriptc::dbLayer_getSpacing", _wrap_dbLayer_getSpacing, file);
    newXS("UCLAscriptc::dbLayer_getUnitRes", _wrap_dbLayer_getUnitRes, file);
    newXS("UCLAscriptc::dbLayer_getUnitCap", _wrap_dbLayer_getUnitCap, file);
    newXS("UCLAscriptc::dbLayer_getNumTracks", _wrap_dbLayer_getNumTracks, file);
    newXS("UCLAscriptc::dbLayer_getIndex", _wrap_dbLayer_getIndex, file);
    newXS("UCLAscriptc::new_dbRow", _wrap_new_dbRow, file);
    newXS("UCLAscriptc::delete_dbRow", _wrap_delete_dbRow, file);
    newXS("UCLAscriptc::dbRow_getSite", _wrap_dbRow_getSite, file);
    newXS("UCLAscriptc::dbRow_getOrigin", _wrap_dbRow_getOrigin, file);
    newXS("UCLAscriptc::dbRow_getDirection", _wrap_dbRow_getDirection, file);
    newXS("UCLAscriptc::dbRow_getSpacing", _wrap_dbRow_getSpacing, file);
    newXS("UCLAscriptc::dbRow_getOrientation", _wrap_dbRow_getOrientation, file);
    newXS("UCLAscriptc::dbRow_getNumSites", _wrap_dbRow_getNumSites, file);
    newXS("UCLAscriptc::dbRow_getName", _wrap_dbRow_getName, file);
    newXS("UCLAscriptc::dbRow_getLength", _wrap_dbRow_getLength, file);
    newXS("UCLAscriptc::dbTrack_layer_get", _wrap_dbTrack_layer_get, file);
    newXS("UCLAscriptc::dbTrack_horizontal_set", _wrap_dbTrack_horizontal_set, file);
    newXS("UCLAscriptc::dbTrack_horizontal_get", _wrap_dbTrack_horizontal_get, file);
    newXS("UCLAscriptc::dbTrack_start_set", _wrap_dbTrack_start_set, file);
    newXS("UCLAscriptc::dbTrack_start_get", _wrap_dbTrack_start_get, file);
    newXS("UCLAscriptc::dbTrack_numTracks_set", _wrap_dbTrack_numTracks_set, file);
    newXS("UCLAscriptc::dbTrack_numTracks_get", _wrap_dbTrack_numTracks_get, file);
    newXS("UCLAscriptc::dbTrack_spacing_set", _wrap_dbTrack_spacing_set, file);
    newXS("UCLAscriptc::dbTrack_spacing_get", _wrap_dbTrack_spacing_get, file);
    newXS("UCLAscriptc::new_dbTrack", _wrap_new_dbTrack, file);
    newXS("UCLAscriptc::dbGCellGrid_horizontal_set", _wrap_dbGCellGrid_horizontal_set, file);
    newXS("UCLAscriptc::dbGCellGrid_horizontal_get", _wrap_dbGCellGrid_horizontal_get, file);
    newXS("UCLAscriptc::dbGCellGrid_start_set", _wrap_dbGCellGrid_start_set, file);
    newXS("UCLAscriptc::dbGCellGrid_start_get", _wrap_dbGCellGrid_start_get, file);
    newXS("UCLAscriptc::dbGCellGrid_numDivisions_set", _wrap_dbGCellGrid_numDivisions_set, file);
    newXS("UCLAscriptc::dbGCellGrid_numDivisions_get", _wrap_dbGCellGrid_numDivisions_get, file);
    newXS("UCLAscriptc::dbGCellGrid_spacing_set", _wrap_dbGCellGrid_spacing_set, file);
    newXS("UCLAscriptc::dbGCellGrid_spacing_get", _wrap_dbGCellGrid_spacing_get, file);
    newXS("UCLAscriptc::new_dbGCellGrid", _wrap_new_dbGCellGrid, file);
    newXS("UCLAscriptc::new_dbMasterCell", _wrap_new_dbMasterCell, file);
    newXS("UCLAscriptc::delete_dbMasterCell", _wrap_delete_dbMasterCell, file);
    newXS("UCLAscriptc::dbMasterCell_pinsBegin", _wrap_dbMasterCell_pinsBegin, file);
    newXS("UCLAscriptc::dbMasterCell_pinsEnd", _wrap_dbMasterCell_pinsEnd, file);
    newXS("UCLAscriptc::dbMasterCell_getNumPins", _wrap_dbMasterCell_getNumPins, file);
    newXS("UCLAscriptc::dbMasterCell_getName", _wrap_dbMasterCell_getName, file);
    newXS("UCLAscriptc::dbMasterCell_getHeight", _wrap_dbMasterCell_getHeight, file);
    newXS("UCLAscriptc::dbMasterCell_getWidth", _wrap_dbMasterCell_getWidth, file);
    newXS("UCLAscriptc::dbMasterCell_getIndegree", _wrap_dbMasterCell_getIndegree, file);
    newXS("UCLAscriptc::dbMasterCell_getOutdegree", _wrap_dbMasterCell_getOutdegree, file);
    newXS("UCLAscriptc::dbMasterCell_getType", _wrap_dbMasterCell_getType, file);
    newXS("UCLAscriptc::dbMasterCell_getObstacles", _wrap_dbMasterCell_getObstacles, file);
    newXS("UCLAscriptc::dbMasterCell_getSymmetry", _wrap_dbMasterCell_getSymmetry, file);
    newXS("UCLAscriptc::dbMasterCell_getSite", _wrap_dbMasterCell_getSite, file);
    newXS("UCLAscriptc::dbMasterCell_isCover", _wrap_dbMasterCell_isCover, file);
    newXS("UCLAscriptc::dbMasterCell_isRing", _wrap_dbMasterCell_isRing, file);
    newXS("UCLAscriptc::dbMasterCell_isBlock", _wrap_dbMasterCell_isBlock, file);
    newXS("UCLAscriptc::dbMasterCell_isCore", _wrap_dbMasterCell_isCore, file);
    newXS("UCLAscriptc::dbMasterCell_isPad", _wrap_dbMasterCell_isPad, file);
    newXS("UCLAscriptc::dbMasterCell_isEndCap", _wrap_dbMasterCell_isEndCap, file);
    newXS("UCLAscriptc::dbMasterCell_isExtPin", _wrap_dbMasterCell_isExtPin, file);
    newXS("UCLAscriptc::dbMasterCell_isUnknown", _wrap_dbMasterCell_isUnknown, file);
    newXS("UCLAscriptc::dbMasterCell_isFlipFlop", _wrap_dbMasterCell_isFlipFlop, file);
    newXS("UCLAscriptc::dbMasterCell_isLatch", _wrap_dbMasterCell_isLatch, file);
    newXS("UCLAscriptc::dbMasterCell_isInverter", _wrap_dbMasterCell_isInverter, file);
    newXS("UCLAscriptc::dbMasterCell_isBuffer", _wrap_dbMasterCell_isBuffer, file);
    newXS("UCLAscriptc::dbMasterCell_isNAND", _wrap_dbMasterCell_isNAND, file);
    newXS("UCLAscriptc::dbMasterCell_isNOR", _wrap_dbMasterCell_isNOR, file);
    newXS("UCLAscriptc::dbMasterCell_isCoreUnknown", _wrap_dbMasterCell_isCoreUnknown, file);
    newXS("UCLAscriptc::dbMasterCell_isPI", _wrap_dbMasterCell_isPI, file);
    newXS("UCLAscriptc::dbMasterCell_isPO", _wrap_dbMasterCell_isPO, file);
    newXS("UCLAscriptc::dbMasterCell_isPIO", _wrap_dbMasterCell_isPIO, file);
    newXS("UCLAscriptc::dbMasterCell_isPPower", _wrap_dbMasterCell_isPPower, file);
    newXS("UCLAscriptc::dbMasterCell_isPSpacer", _wrap_dbMasterCell_isPSpacer, file);
    newXS("UCLAscriptc::dbMasterCell_isPUnknown", _wrap_dbMasterCell_isPUnknown, file);
    newXS("UCLAscriptc::dbMasterCell_getRiseDelay", _wrap_dbMasterCell_getRiseDelay, file);
    newXS("UCLAscriptc::dbMasterCell_getFallDelay", _wrap_dbMasterCell_getFallDelay, file);
    newXS("UCLAscriptc::dbMasterCell_reOrientRec", _wrap_dbMasterCell_reOrientRec, file);
    newXS("UCLAscriptc::new_dbCell", _wrap_new_dbCell, file);
    newXS("UCLAscriptc::delete_dbCell", _wrap_delete_dbCell, file);
    newXS("UCLAscriptc::dbCell_pinsBegin", _wrap_dbCell_pinsBegin, file);
    newXS("UCLAscriptc::dbCell_pinsEnd", _wrap_dbCell_pinsEnd, file);
    newXS("UCLAscriptc::dbCell_netsBegin", _wrap_dbCell_netsBegin, file);
    newXS("UCLAscriptc::dbCell_netsEnd", _wrap_dbCell_netsEnd, file);
    newXS("UCLAscriptc::dbCell_loopPinsBegin", _wrap_dbCell_loopPinsBegin, file);
    newXS("UCLAscriptc::dbCell_loopPinsEnd", _wrap_dbCell_loopPinsEnd, file);
    newXS("UCLAscriptc::dbCell_loopNetsBegin", _wrap_dbCell_loopNetsBegin, file);
    newXS("UCLAscriptc::dbCell_loopNetsEnd", _wrap_dbCell_loopNetsEnd, file);
    newXS("UCLAscriptc::dbCell_getMaster", _wrap_dbCell_getMaster, file);
    newXS("UCLAscriptc::dbCell_getIndex", _wrap_dbCell_getIndex, file);
    newXS("UCLAscriptc::dbCell_getName", _wrap_dbCell_getName, file);
    newXS("UCLAscriptc::dbCell_getType", _wrap_dbCell_getType, file);
    newXS("UCLAscriptc::dbCell_getHeight", _wrap_dbCell_getHeight, file);
    newXS("UCLAscriptc::dbCell_getWidth", _wrap_dbCell_getWidth, file);
    newXS("UCLAscriptc::dbCell_getIndegree", _wrap_dbCell_getIndegree, file);
    newXS("UCLAscriptc::dbCell_getOutdegree", _wrap_dbCell_getOutdegree, file);
    newXS("UCLAscriptc::dbCell_getNumNets", _wrap_dbCell_getNumNets, file);
    newXS("UCLAscriptc::dbCell_getNumPins", _wrap_dbCell_getNumPins, file);
    newXS("UCLAscriptc::dbCell_isIO", _wrap_dbCell_isIO, file);
    newXS("UCLAscriptc::dbCell_isBlock", _wrap_dbCell_isBlock, file);
    newXS("UCLAscriptc::dbCell_isCore", _wrap_dbCell_isCore, file);
    newXS("UCLAscriptc::dbCell_isOther", _wrap_dbCell_isOther, file);
    newXS("UCLAscriptc::dbCell_isUnknown", _wrap_dbCell_isUnknown, file);
    newXS("UCLAscriptc::dbCell_isPI", _wrap_dbCell_isPI, file);
    newXS("UCLAscriptc::dbCell_isPO", _wrap_dbCell_isPO, file);
    newXS("UCLAscriptc::dbCell_isPIO", _wrap_dbCell_isPIO, file);
    newXS("UCLAscriptc::dbCell_isPOther", _wrap_dbCell_isPOther, file);
    newXS("UCLAscriptc::dbCell_isPUnknown", _wrap_dbCell_isPUnknown, file);
    newXS("UCLAscriptc::dbCell_isCC", _wrap_dbCell_isCC, file);
    newXS("UCLAscriptc::dbCell_isSC", _wrap_dbCell_isSC, file);
    newXS("UCLAscriptc::dbCell_isCoreOther", _wrap_dbCell_isCoreOther, file);
    newXS("UCLAscriptc::dbCell_isTimingNode", _wrap_dbCell_isTimingNode, file);
    newXS("UCLAscriptc::dbCell_isLatchNode", _wrap_dbCell_isLatchNode, file);
    newXS("UCLAscriptc::dbCell_isIgnoredTimingNode", _wrap_dbCell_isIgnoredTimingNode, file);
    newXS("UCLAscriptc::dbCell_getRiseDelay", _wrap_dbCell_getRiseDelay, file);
    newXS("UCLAscriptc::dbCell_getFallDelay", _wrap_dbCell_getFallDelay, file);
    newXS("UCLAscriptc::dbCell_commonPin", _wrap_dbCell_commonPin, file);
    newXS("UCLAscriptc::dbCell_commonPinIsCellInput", _wrap_dbCell_commonPinIsCellInput, file);
    newXS("UCLAscriptc::dbCell_commonPinIsCellOutput", _wrap_dbCell_commonPinIsCellOutput, file);
    newXS("UCLAscriptc::dbCell_isInputPad", _wrap_dbCell_isInputPad, file);
    newXS("UCLAscriptc::dbCell_isOutputPad", _wrap_dbCell_isOutputPad, file);
    newXS("UCLAscriptc::new_CompareCellsByName", _wrap_new_CompareCellsByName, file);
    newXS("UCLAscriptc::new_CompareCellsByStatus", _wrap_new_CompareCellsByStatus, file);
    newXS("UCLAscriptc::new_CompareMCsByName", _wrap_new_CompareMCsByName, file);
    newXS("UCLAscriptc::new_CompareCellsByCellIndex", _wrap_new_CompareCellsByCellIndex, file);
    newXS("UCLAscriptc::new_CompareCellsByDir", _wrap_new_CompareCellsByDir, file);
    newXS("UCLAscriptc::new_CompareObstaclesByXmin", _wrap_new_CompareObstaclesByXmin, file);
    newXS("UCLAscriptc::new_dbMasterPin", _wrap_new_dbMasterPin, file);
    newXS("UCLAscriptc::delete_dbMasterPin", _wrap_delete_dbMasterPin, file);
    newXS("UCLAscriptc::dbMasterPin_setMasterCell", _wrap_dbMasterPin_setMasterCell, file);
    newXS("UCLAscriptc::dbMasterPin_getCell", _wrap_dbMasterPin_getCell, file);
    newXS("UCLAscriptc::dbMasterPin_getName", _wrap_dbMasterPin_getName, file);
    newXS("UCLAscriptc::dbMasterPin_getCenter", _wrap_dbMasterPin_getCenter, file);
    newXS("UCLAscriptc::dbMasterPin_getBBox", _wrap_dbMasterPin_getBBox, file);
    newXS("UCLAscriptc::dbMasterPin_getPorts", _wrap_dbMasterPin_getPorts, file);
    newXS("UCLAscriptc::dbMasterPin_getType", _wrap_dbMasterPin_getType, file);
    newXS("UCLAscriptc::dbMasterPin_getRiseDelay", _wrap_dbMasterPin_getRiseDelay, file);
    newXS("UCLAscriptc::dbMasterPin_getFallDelay", _wrap_dbMasterPin_getFallDelay, file);
    newXS("UCLAscriptc::dbMasterPin_getRiseResist", _wrap_dbMasterPin_getRiseResist, file);
    newXS("UCLAscriptc::dbMasterPin_getFallResist", _wrap_dbMasterPin_getFallResist, file);
    newXS("UCLAscriptc::dbMasterPin_getInputCap", _wrap_dbMasterPin_getInputCap, file);
    newXS("UCLAscriptc::dbMasterPin_isShapeAbutment", _wrap_dbMasterPin_isShapeAbutment, file);
    newXS("UCLAscriptc::dbMasterPin_isShapeFeedthrough", _wrap_dbMasterPin_isShapeFeedthrough, file);
    newXS("UCLAscriptc::dbMasterPin_isShapeRing", _wrap_dbMasterPin_isShapeRing, file);
    newXS("UCLAscriptc::dbMasterPin_isShapeUnknown", _wrap_dbMasterPin_isShapeUnknown, file);
    newXS("UCLAscriptc::dbMasterPin_isUseSignal", _wrap_dbMasterPin_isUseSignal, file);
    newXS("UCLAscriptc::dbMasterPin_isUseAnalog", _wrap_dbMasterPin_isUseAnalog, file);
    newXS("UCLAscriptc::dbMasterPin_isUsePower", _wrap_dbMasterPin_isUsePower, file);
    newXS("UCLAscriptc::dbMasterPin_isUseGround", _wrap_dbMasterPin_isUseGround, file);
    newXS("UCLAscriptc::dbMasterPin_isUseClock", _wrap_dbMasterPin_isUseClock, file);
    newXS("UCLAscriptc::dbMasterPin_isUseUnknown", _wrap_dbMasterPin_isUseUnknown, file);
    newXS("UCLAscriptc::dbMasterPin_isDirOutput", _wrap_dbMasterPin_isDirOutput, file);
    newXS("UCLAscriptc::dbMasterPin_isDirInput", _wrap_dbMasterPin_isDirInput, file);
    newXS("UCLAscriptc::dbMasterPin_isDirInOut", _wrap_dbMasterPin_isDirInOut, file);
    newXS("UCLAscriptc::dbMasterPin_isDirOutputTristate", _wrap_dbMasterPin_isDirOutputTristate, file);
    newXS("UCLAscriptc::dbMasterPin_isDirFeedthrough", _wrap_dbMasterPin_isDirFeedthrough, file);
    newXS("UCLAscriptc::dbMasterPin_isDirUnknown", _wrap_dbMasterPin_isDirUnknown, file);
    newXS("UCLAscriptc::dbMasterPin_isJoint", _wrap_dbMasterPin_isJoint, file);
    newXS("UCLAscriptc::dbMasterPin_getJointPins", _wrap_dbMasterPin_getJointPins, file);
    newXS("UCLAscriptc::new_dbPin", _wrap_new_dbPin, file);
    newXS("UCLAscriptc::delete_dbPin", _wrap_delete_dbPin, file);
    newXS("UCLAscriptc::dbPin_setCell", _wrap_dbPin_setCell, file);
    newXS("UCLAscriptc::dbPin_setNet", _wrap_dbPin_setNet, file);
    newXS("UCLAscriptc::dbPin_getMasterPinName", _wrap_dbPin_getMasterPinName, file);
    newXS("UCLAscriptc::dbPin_getCell", _wrap_dbPin_getCell, file);
    newXS("UCLAscriptc::dbPin_getNet", _wrap_dbPin_getNet, file);
    newXS("UCLAscriptc::dbPin_getIndex", _wrap_dbPin_getIndex, file);
    newXS("UCLAscriptc::dbPin_getMaster", _wrap_dbPin_getMaster, file);
    newXS("UCLAscriptc::dbPin_getType", _wrap_dbPin_getType, file);
    newXS("UCLAscriptc::dbPin_getRiseDelay", _wrap_dbPin_getRiseDelay, file);
    newXS("UCLAscriptc::dbPin_getFallDelay", _wrap_dbPin_getFallDelay, file);
    newXS("UCLAscriptc::dbPin_getRiseResist", _wrap_dbPin_getRiseResist, file);
    newXS("UCLAscriptc::dbPin_getFallResist", _wrap_dbPin_getFallResist, file);
    newXS("UCLAscriptc::dbPin_getInputCap", _wrap_dbPin_getInputCap, file);
    newXS("UCLAscriptc::dbPin_isShapeAbutment", _wrap_dbPin_isShapeAbutment, file);
    newXS("UCLAscriptc::dbPin_isShapeFeedthrough", _wrap_dbPin_isShapeFeedthrough, file);
    newXS("UCLAscriptc::dbPin_isShapeRing", _wrap_dbPin_isShapeRing, file);
    newXS("UCLAscriptc::dbPin_isShapeUnknown", _wrap_dbPin_isShapeUnknown, file);
    newXS("UCLAscriptc::dbPin_isUseSignal", _wrap_dbPin_isUseSignal, file);
    newXS("UCLAscriptc::dbPin_isUseAnalog", _wrap_dbPin_isUseAnalog, file);
    newXS("UCLAscriptc::dbPin_isUsePower", _wrap_dbPin_isUsePower, file);
    newXS("UCLAscriptc::dbPin_isUseGround", _wrap_dbPin_isUseGround, file);
    newXS("UCLAscriptc::dbPin_isUseClock", _wrap_dbPin_isUseClock, file);
    newXS("UCLAscriptc::dbPin_isUseUnknown", _wrap_dbPin_isUseUnknown, file);
    newXS("UCLAscriptc::dbPin_isDirOutput", _wrap_dbPin_isDirOutput, file);
    newXS("UCLAscriptc::dbPin_isDirInput", _wrap_dbPin_isDirInput, file);
    newXS("UCLAscriptc::dbPin_isDirInOut", _wrap_dbPin_isDirInOut, file);
    newXS("UCLAscriptc::dbPin_isDirOutputTristate", _wrap_dbPin_isDirOutputTristate, file);
    newXS("UCLAscriptc::dbPin_isDirFeedthrough", _wrap_dbPin_isDirFeedthrough, file);
    newXS("UCLAscriptc::dbPin_isDirUnknown", _wrap_dbPin_isDirUnknown, file);
    newXS("UCLAscriptc::dbPin_isConnected", _wrap_dbPin_isConnected, file);
    newXS("UCLAscriptc::new_ComparePinsByDirAndName", _wrap_new_ComparePinsByDirAndName, file);
    newXS("UCLAscriptc::new_ComparePinsByCellIndexAndDir", _wrap_new_ComparePinsByCellIndexAndDir, file);
    newXS("UCLAscriptc::dbNet__cells_set", _wrap_dbNet__cells_set, file);
    newXS("UCLAscriptc::dbNet__cells_get", _wrap_dbNet__cells_get, file);
    newXS("UCLAscriptc::dbNet__pins_set", _wrap_dbNet__pins_set, file);
    newXS("UCLAscriptc::dbNet__pins_get", _wrap_dbNet__pins_get, file);
    newXS("UCLAscriptc::dbNet__wiring_set", _wrap_dbNet__wiring_set, file);
    newXS("UCLAscriptc::dbNet__wiring_get", _wrap_dbNet__wiring_get, file);
    newXS("UCLAscriptc::dbNet__numOut_set", _wrap_dbNet__numOut_set, file);
    newXS("UCLAscriptc::dbNet__numOut_get", _wrap_dbNet__numOut_get, file);
    newXS("UCLAscriptc::dbNet__numInOut_set", _wrap_dbNet__numInOut_set, file);
    newXS("UCLAscriptc::dbNet__numInOut_get", _wrap_dbNet__numInOut_get, file);
    newXS("UCLAscriptc::dbNet__hasLogicalPin_set", _wrap_dbNet__hasLogicalPin_set, file);
    newXS("UCLAscriptc::dbNet__hasLogicalPin_get", _wrap_dbNet__hasLogicalPin_get, file);
    newXS("UCLAscriptc::new_dbNet", _wrap_new_dbNet, file);
    newXS("UCLAscriptc::delete_dbNet", _wrap_delete_dbNet, file);
    newXS("UCLAscriptc::dbNet_getNumCells", _wrap_dbNet_getNumCells, file);
    newXS("UCLAscriptc::dbNet_getNumPins", _wrap_dbNet_getNumPins, file);
    newXS("UCLAscriptc::dbNet_getDegree", _wrap_dbNet_getDegree, file);
    newXS("UCLAscriptc::dbNet_getIndex", _wrap_dbNet_getIndex, file);
    newXS("UCLAscriptc::dbNet_getType", _wrap_dbNet_getType, file);
    newXS("UCLAscriptc::dbNet_getName", _wrap_dbNet_getName, file);
    newXS("UCLAscriptc::dbNet_getNumOut", _wrap_dbNet_getNumOut, file);
    newXS("UCLAscriptc::dbNet_getNumInOut", _wrap_dbNet_getNumInOut, file);
    newXS("UCLAscriptc::dbNet_getNumIn", _wrap_dbNet_getNumIn, file);
    newXS("UCLAscriptc::dbNet_hasLogicalPin", _wrap_dbNet_hasLogicalPin, file);
    newXS("UCLAscriptc::dbNet_cellsBegin", _wrap_dbNet_cellsBegin, file);
    newXS("UCLAscriptc::dbNet_cellsEnd", _wrap_dbNet_cellsEnd, file);
    newXS("UCLAscriptc::dbNet_sourcesBegin", _wrap_dbNet_sourcesBegin, file);
    newXS("UCLAscriptc::dbNet_sourcesEnd", _wrap_dbNet_sourcesEnd, file);
    newXS("UCLAscriptc::dbNet_sourceSinksBegin", _wrap_dbNet_sourceSinksBegin, file);
    newXS("UCLAscriptc::dbNet_sourceSinksEnd", _wrap_dbNet_sourceSinksEnd, file);
    newXS("UCLAscriptc::dbNet_sinksBegin", _wrap_dbNet_sinksBegin, file);
    newXS("UCLAscriptc::dbNet_sinksEnd", _wrap_dbNet_sinksEnd, file);
    newXS("UCLAscriptc::dbNet_getCellByIdx", _wrap_dbNet_getCellByIdx, file);
    newXS("UCLAscriptc::dbNet_pinsBegin", _wrap_dbNet_pinsBegin, file);
    newXS("UCLAscriptc::dbNet_pinsEnd", _wrap_dbNet_pinsEnd, file);
    newXS("UCLAscriptc::dbNet_getPinByIdx", _wrap_dbNet_getPinByIdx, file);
    newXS("UCLAscriptc::dbNet_wiringBegin", _wrap_dbNet_wiringBegin, file);
    newXS("UCLAscriptc::dbNet_wiringEnd", _wrap_dbNet_wiringEnd, file);
    newXS("UCLAscriptc::dbNet_getWiringLayerGeom", _wrap_dbNet_getWiringLayerGeom, file);
    newXS("UCLAscriptc::dbNet_getNumWiringLayerGeoms", _wrap_dbNet_getNumWiringLayerGeoms, file);
    newXS("UCLAscriptc::dbNet_loopCellsBegin", _wrap_dbNet_loopCellsBegin, file);
    newXS("UCLAscriptc::dbNet_loopCellsEnd", _wrap_dbNet_loopCellsEnd, file);
    newXS("UCLAscriptc::dbNet_loopPinsBegin", _wrap_dbNet_loopPinsBegin, file);
    newXS("UCLAscriptc::dbNet_loopPinsEnd", _wrap_dbNet_loopPinsEnd, file);
    newXS("UCLAscriptc::dbNet_commonPin", _wrap_dbNet_commonPin, file);
    newXS("UCLAscriptc::dbNet_commonPinIsCellInput", _wrap_dbNet_commonPinIsCellInput, file);
    newXS("UCLAscriptc::dbNet_commonPinIsCellOutput", _wrap_dbNet_commonPinIsCellOutput, file);
    newXS("UCLAscriptc::dbNet_getInputCap", _wrap_dbNet_getInputCap, file);
    newXS("UCLAscriptc::dbNet_getDriverResist", _wrap_dbNet_getDriverResist, file);
    newXS("UCLAscriptc::dbNet_isSpecial", _wrap_dbNet_isSpecial, file);
    newXS("UCLAscriptc::new_CompareNetsByCellIndex", _wrap_new_CompareNetsByCellIndex, file);
    newXS("UCLAscriptc::new_CompareNetsByDegree", _wrap_new_CompareNetsByDegree, file);
    newXS("UCLAscriptc::new_CompareNetsByName", _wrap_new_CompareNetsByName, file);
    newXS("UCLAscriptc::new_CompareNetsByDirection", _wrap_new_CompareNetsByDirection, file);
    newXS("UCLAscriptc::new_dbNetlist", _wrap_new_dbNetlist, file);
    newXS("UCLAscriptc::delete_dbNetlist", _wrap_delete_dbNetlist, file);
    newXS("UCLAscriptc::dbNetlist_getCellLEQClass", _wrap_dbNetlist_getCellLEQClass, file);
    newXS("UCLAscriptc::dbNetlist_getCellEEQClass", _wrap_dbNetlist_getCellEEQClass, file);
    newXS("UCLAscriptc::dbNetlist_getPinLEQClass", _wrap_dbNetlist_getPinLEQClass, file);
    newXS("UCLAscriptc::dbNetlist_isConsistent", _wrap_dbNetlist_isConsistent, file);
    newXS("UCLAscriptc::dbNetlist_getNumCells", _wrap_dbNetlist_getNumCells, file);
    newXS("UCLAscriptc::dbNetlist_getNumPins", _wrap_dbNetlist_getNumPins, file);
    newXS("UCLAscriptc::dbNetlist_getNumNets", _wrap_dbNetlist_getNumNets, file);
    newXS("UCLAscriptc::dbNetlist_getNumSNets", _wrap_dbNetlist_getNumSNets, file);
    newXS("UCLAscriptc::dbNetlist_getNumMasterCells", _wrap_dbNetlist_getNumMasterCells, file);
    newXS("UCLAscriptc::dbNetlist_getNumMasterPins", _wrap_dbNetlist_getNumMasterPins, file);
    newXS("UCLAscriptc::dbNetlist_getNumCCs", _wrap_dbNetlist_getNumCCs, file);
    newXS("UCLAscriptc::dbNetlist_getNumSCs", _wrap_dbNetlist_getNumSCs, file);
    newXS("UCLAscriptc::dbNetlist_getNumIOPads", _wrap_dbNetlist_getNumIOPads, file);
    newXS("UCLAscriptc::dbNetlist_getNumAllPads", _wrap_dbNetlist_getNumAllPads, file);
    newXS("UCLAscriptc::dbNetlist_getNumIOPins", _wrap_dbNetlist_getNumIOPins, file);
    newXS("UCLAscriptc::dbNetlist_getNumCoreCells", _wrap_dbNetlist_getNumCoreCells, file);
    newXS("UCLAscriptc::dbNetlist_cellsBegin", _wrap_dbNetlist_cellsBegin, file);
    newXS("UCLAscriptc::dbNetlist_cellsEnd", _wrap_dbNetlist_cellsEnd, file);
    newXS("UCLAscriptc::dbNetlist_netsBegin", _wrap_dbNetlist_netsBegin, file);
    newXS("UCLAscriptc::dbNetlist_netsEnd", _wrap_dbNetlist_netsEnd, file);
    newXS("UCLAscriptc::dbNetlist_sNetsBegin", _wrap_dbNetlist_sNetsBegin, file);
    newXS("UCLAscriptc::dbNetlist_sNetsEnd", _wrap_dbNetlist_sNetsEnd, file);
    newXS("UCLAscriptc::dbNetlist_pinsBegin", _wrap_dbNetlist_pinsBegin, file);
    newXS("UCLAscriptc::dbNetlist_pinsEnd", _wrap_dbNetlist_pinsEnd, file);
    newXS("UCLAscriptc::dbNetlist_pinLibBegin", _wrap_dbNetlist_pinLibBegin, file);
    newXS("UCLAscriptc::dbNetlist_pinLibEnd", _wrap_dbNetlist_pinLibEnd, file);
    newXS("UCLAscriptc::dbNetlist_cellLibBegin", _wrap_dbNetlist_cellLibBegin, file);
    newXS("UCLAscriptc::dbNetlist_cellLibEnd", _wrap_dbNetlist_cellLibEnd, file);
    newXS("UCLAscriptc::dbNetlist_getCellByIdx", _wrap_dbNetlist_getCellByIdx, file);
    newXS("UCLAscriptc::dbNetlist_getNetByIdx", _wrap_dbNetlist_getNetByIdx, file);
    newXS("UCLAscriptc::dbNetlist_getSNetByIdx", _wrap_dbNetlist_getSNetByIdx, file);
    newXS("UCLAscriptc::dbNetlist_getPinByIdx", _wrap_dbNetlist_getPinByIdx, file);
    newXS("UCLAscriptc::dbNetlist_loopCellsBegin", _wrap_dbNetlist_loopCellsBegin, file);
    newXS("UCLAscriptc::dbNetlist_loopCellsEnd", _wrap_dbNetlist_loopCellsEnd, file);
    newXS("UCLAscriptc::dbNetlist_loopNetsBegin", _wrap_dbNetlist_loopNetsBegin, file);
    newXS("UCLAscriptc::dbNetlist_loopNetsEnd", _wrap_dbNetlist_loopNetsEnd, file);
    newXS("UCLAscriptc::dbNetlist_loopSNetsBegin", _wrap_dbNetlist_loopSNetsBegin, file);
    newXS("UCLAscriptc::dbNetlist_loopSNetsEnd", _wrap_dbNetlist_loopSNetsEnd, file);
    newXS("UCLAscriptc::dbNetlist_postProcess", _wrap_dbNetlist_postProcess, file);
    newXS("UCLAscriptc::dbNetlist_processLGC", _wrap_dbNetlist_processLGC, file);
    newXS("UCLAscriptc::dbNetlist_evalHalfPerimCost", _wrap_dbNetlist_evalHalfPerimCost, file);
    newXS("UCLAscriptc::dbNetlist_evalWHalfPerimCost", _wrap_dbNetlist_evalWHalfPerimCost, file);
    newXS("UCLAscriptc::dbNetlist_evalMSTCost", _wrap_dbNetlist_evalMSTCost, file);
    newXS("UCLAscriptc::dbNetlist_evalHalfPerimCostNoPins", _wrap_dbNetlist_evalHalfPerimCostNoPins, file);
    newXS("UCLAscriptc::dbNetlist_printNetStats", _wrap_dbNetlist_printNetStats, file);
    newXS("UCLAscriptc::dbEasyAccess_populate", _wrap_dbEasyAccess_populate, file);
    newXS("UCLAscriptc::dbEasyAccess_isConsistent", _wrap_dbEasyAccess_isConsistent, file);
    newXS("UCLAscriptc::dbEasyAccess_getCellWidths", _wrap_dbEasyAccess_getCellWidths, file);
    newXS("UCLAscriptc::dbEasyAccess_getCellAreas", _wrap_dbEasyAccess_getCellAreas, file);
    newXS("UCLAscriptc::dbEasyAccess_getWhitespace", _wrap_dbEasyAccess_getWhitespace, file);
    newXS("UCLAscriptc::dbEasyAccess_getNumPortLocations", _wrap_dbEasyAccess_getNumPortLocations, file);
    newXS("UCLAscriptc::dbEasyAccess_getPortLocationByIdx", _wrap_dbEasyAccess_getPortLocationByIdx, file);
    newXS("UCLAscriptc::dbEasyAccess_getNetIds", _wrap_dbEasyAccess_getNetIds, file);
    newXS("UCLAscriptc::dbEasyAccess_getCoreCells", _wrap_dbEasyAccess_getCoreCells, file);
    newXS("UCLAscriptc::dbEasyAccess_getCoreBBox", _wrap_dbEasyAccess_getCoreBBox, file);
    newXS("UCLAscriptc::dbEasyAccess_getPin2CellIdx", _wrap_dbEasyAccess_getPin2CellIdx, file);
    newXS("UCLAscriptc::dbEasyAccess_getCellIdxByPinIdx", _wrap_dbEasyAccess_getCellIdxByPinIdx, file);
    newXS("UCLAscriptc::dbEasyAccess_getCoreCellArea", _wrap_dbEasyAccess_getCoreCellArea, file);
    newXS("UCLAscriptc::dbEasyAccess_getTotalCellWidth", _wrap_dbEasyAccess_getTotalCellWidth, file);
    newXS("UCLAscriptc::dbEasyAccess_getCellByName", _wrap_dbEasyAccess_getCellByName, file);
    newXS("UCLAscriptc::dbEasyAccess_getNetByName", _wrap_dbEasyAccess_getNetByName, file);
    newXS("UCLAscriptc::new_dbSpatial", _wrap_new_dbSpatial, file);
    newXS("UCLAscriptc::dbSpatial_locations_set", _wrap_dbSpatial_locations_set, file);
    newXS("UCLAscriptc::dbSpatial_locations_get", _wrap_dbSpatial_locations_get, file);
    newXS("UCLAscriptc::dbSpatial_locationValid_set", _wrap_dbSpatial_locationValid_set, file);
    newXS("UCLAscriptc::dbSpatial_locationValid_get", _wrap_dbSpatial_locationValid_get, file);
    newXS("UCLAscriptc::dbSpatial_orientations_set", _wrap_dbSpatial_orientations_set, file);
    newXS("UCLAscriptc::dbSpatial_orientations_get", _wrap_dbSpatial_orientations_get, file);
    newXS("UCLAscriptc::dbSpatial_constraints_set", _wrap_dbSpatial_constraints_set, file);
    newXS("UCLAscriptc::dbSpatial_constraints_get", _wrap_dbSpatial_constraints_get, file);
    newXS("UCLAscriptc::dbSpatial_getSize", _wrap_dbSpatial_getSize, file);
    newXS("UCLAscriptc::dbSpatial_isConsistent", _wrap_dbSpatial_isConsistent, file);
    newXS("UCLAscriptc::dbSpatial_reorderCells", _wrap_dbSpatial_reorderCells, file);
    newXS("UCLAscriptc::dbSpatial_allCellsPlaced", _wrap_dbSpatial_allCellsPlaced, file);
    newXS("UCLAscriptc::DB_spatial_set", _wrap_DB_spatial_set, file);
    newXS("UCLAscriptc::DB_spatial_get", _wrap_DB_spatial_get, file);
    newXS("UCLAscriptc::DB_easyAccess_set", _wrap_DB_easyAccess_set, file);
    newXS("UCLAscriptc::DB_easyAccess_get", _wrap_DB_easyAccess_get, file);
    newXS("UCLAscriptc::DB_routedNets_set", _wrap_DB_routedNets_set, file);
    newXS("UCLAscriptc::DB_routedNets_get", _wrap_DB_routedNets_get, file);
    newXS("UCLAscriptc::DB_timing_set", _wrap_DB_timing_set, file);
    newXS("UCLAscriptc::DB_timing_get", _wrap_DB_timing_get, file);
    newXS("UCLAscriptc::new_DB", _wrap_new_DB, file);
    newXS("UCLAscriptc::delete_DB", _wrap_delete_DB, file);
    newXS("UCLAscriptc::DB_isConsistent", _wrap_DB_isConsistent, file);
    newXS("UCLAscriptc::DB_getOrigFileName", _wrap_DB_getOrigFileName, file);
    newXS("UCLAscriptc::DB_getAuxName", _wrap_DB_getAuxName, file);
    newXS("UCLAscriptc::DB_getDirName", _wrap_DB_getDirName, file);
    newXS("UCLAscriptc::DB_getFileNames", _wrap_DB_getFileNames, file);
    newXS("UCLAscriptc::DB_getOrigFileFormat", _wrap_DB_getOrigFileFormat, file);
    newXS("UCLAscriptc::DB_getDelimiter", _wrap_DB_getDelimiter, file);
    newXS("UCLAscriptc::DB_getLayout", _wrap_DB_getLayout, file);
    newXS("UCLAscriptc::DB_getNetlist", _wrap_DB_getNetlist, file);
    newXS("UCLAscriptc::DB_getNetlistForSurgery", _wrap_DB_getNetlistForSurgery, file);
    newXS("UCLAscriptc::DB_getTiming", _wrap_DB_getTiming, file);
    newXS("UCLAscriptc::DB_saveDEF", _wrap_DB_saveDEF, file);
    newXS("UCLAscriptc::DB_saveXYLineDrawing", _wrap_DB_saveXYLineDrawing, file);
    newXS("UCLAscriptc::DB_hasDesignName", _wrap_DB_hasDesignName, file);
    newXS("UCLAscriptc::DB_hasTechnoName", _wrap_DB_hasTechnoName, file);
    newXS("UCLAscriptc::DB_getDesignName", _wrap_DB_getDesignName, file);
    newXS("UCLAscriptc::DB_getTechnoName", _wrap_DB_getTechnoName, file);
    newXS("UCLAscriptc::DB_evalHPWLcost", _wrap_DB_evalHPWLcost, file);
    newXS("UCLAscriptc::DB_evalWHPWLcost", _wrap_DB_evalWHPWLcost, file);
    newXS("UCLAscriptc::DB_printNetStats", _wrap_DB_printNetStats, file);
    newXS("UCLAscriptc::DB_locatePin", _wrap_DB_locatePin, file);
    newXS("UCLAscriptc::DB_setPlaceAndOrient", _wrap_DB_setPlaceAndOrient, file);
    newXS("UCLAscriptc::DB_Parameters_ignoreLogicalPins_set", _wrap_DB_Parameters_ignoreLogicalPins_set, file);
    newXS("UCLAscriptc::DB_Parameters_ignoreLogicalPins_get", _wrap_DB_Parameters_ignoreLogicalPins_get, file);
    newXS("UCLAscriptc::DB_Parameters_ignoreGlobalRoutingInfo_set", _wrap_DB_Parameters_ignoreGlobalRoutingInfo_set, file);
    newXS("UCLAscriptc::DB_Parameters_ignoreGlobalRoutingInfo_get", _wrap_DB_Parameters_ignoreGlobalRoutingInfo_get, file);
    newXS("UCLAscriptc::DB_Parameters_ignoreDetailedRoutingInfo_set", _wrap_DB_Parameters_ignoreDetailedRoutingInfo_set, file);
    newXS("UCLAscriptc::DB_Parameters_ignoreDetailedRoutingInfo_get", _wrap_DB_Parameters_ignoreDetailedRoutingInfo_get, file);
    newXS("UCLAscriptc::DB_Parameters_ignoreTimingLibs_set", _wrap_DB_Parameters_ignoreTimingLibs_set, file);
    newXS("UCLAscriptc::DB_Parameters_ignoreTimingLibs_get", _wrap_DB_Parameters_ignoreTimingLibs_get, file);
    newXS("UCLAscriptc::DB_Parameters_fixPlacedPads_set", _wrap_DB_Parameters_fixPlacedPads_set, file);
    newXS("UCLAscriptc::DB_Parameters_fixPlacedPads_get", _wrap_DB_Parameters_fixPlacedPads_get, file);
    newXS("UCLAscriptc::DB_Parameters_verbose_set", _wrap_DB_Parameters_verbose_set, file);
    newXS("UCLAscriptc::DB_Parameters_verbose_get", _wrap_DB_Parameters_verbose_get, file);
    newXS("UCLAscriptc::DB_Parameters_routedDesign_set", _wrap_DB_Parameters_routedDesign_set, file);
    newXS("UCLAscriptc::DB_Parameters_routedDesign_get", _wrap_DB_Parameters_routedDesign_get, file);
    newXS("UCLAscriptc::DB_Parameters_alwaysCheckConsistency_set", _wrap_DB_Parameters_alwaysCheckConsistency_set, file);
    newXS("UCLAscriptc::DB_Parameters_alwaysCheckConsistency_get", _wrap_DB_Parameters_alwaysCheckConsistency_get, file);
    newXS("UCLAscriptc::DB_Parameters_placeHolder2_set", _wrap_DB_Parameters_placeHolder2_set, file);
    newXS("UCLAscriptc::DB_Parameters_placeHolder2_get", _wrap_DB_Parameters_placeHolder2_get, file);
    newXS("UCLAscriptc::DB_Parameters_placeHolder3_set", _wrap_DB_Parameters_placeHolder3_set, file);
    newXS("UCLAscriptc::DB_Parameters_placeHolder3_get", _wrap_DB_Parameters_placeHolder3_get, file);
    newXS("UCLAscriptc::DB_Parameters_placeHolder4_set", _wrap_DB_Parameters_placeHolder4_set, file);
    newXS("UCLAscriptc::DB_Parameters_placeHolder4_get", _wrap_DB_Parameters_placeHolder4_get, file);
    newXS("UCLAscriptc::DB_Parameters_placeHolder5_set", _wrap_DB_Parameters_placeHolder5_set, file);
    newXS("UCLAscriptc::DB_Parameters_placeHolder5_get", _wrap_DB_Parameters_placeHolder5_get, file);
    newXS("UCLAscriptc::new_DB_Parameters", _wrap_new_DB_Parameters, file);
    newXS("UCLAscriptc::new_RBPlacement", _wrap_new_RBPlacement, file);
    newXS("UCLAscriptc::delete_RBPlacement", _wrap_delete_RBPlacement, file);
    newXS("UCLAscriptc::RBPlacement_getOrigFileName", _wrap_RBPlacement_getOrigFileName, file);
    newXS("UCLAscriptc::RBPlacement_getAuxName", _wrap_RBPlacement_getAuxName, file);
    newXS("UCLAscriptc::RBPlacement_getDirName", _wrap_RBPlacement_getDirName, file);
    newXS("UCLAscriptc::RBPlacement_getFileNames", _wrap_RBPlacement_getFileNames, file);
    newXS("UCLAscriptc::RBPlacement_resetPlacementWOri", _wrap_RBPlacement_resetPlacementWOri, file);
    newXS("UCLAscriptc::RBPlacement_resetPlacement", _wrap_RBPlacement_resetPlacement, file);
    newXS("UCLAscriptc::RBPlacement_getNumCells", _wrap_RBPlacement_getNumCells, file);
    newXS("UCLAscriptc::RBPlacement_isPopulated", _wrap_RBPlacement_isPopulated, file);
    newXS("UCLAscriptc::RBPlacement_allCellsPlaced", _wrap_RBPlacement_allCellsPlaced, file);
    newXS("UCLAscriptc::RBPlacement_numCellsNotPlaced", _wrap_RBPlacement_numCellsNotPlaced, file);
    newXS("UCLAscriptc::RBPlacement_isCoreCell", _wrap_RBPlacement_isCoreCell, file);
    newXS("UCLAscriptc::RBPlacement_isFixed", _wrap_RBPlacement_isFixed, file);
    newXS("UCLAscriptc::RBPlacement_isStorElt", _wrap_RBPlacement_isStorElt, file);
    newXS("UCLAscriptc::RBPlacement_isInSubRow", _wrap_RBPlacement_isInSubRow, file);
    newXS("UCLAscriptc::RBPlacement_getFixed", _wrap_RBPlacement_getFixed, file);
    newXS("UCLAscriptc::RBPlacement_getStorElts", _wrap_RBPlacement_getStorElts, file);
    newXS("UCLAscriptc::RBPlacement_setLocation", _wrap_RBPlacement_setLocation, file);
    newXS("UCLAscriptc::RBPlacement_getOrient", _wrap_RBPlacement_getOrient, file);
    newXS("UCLAscriptc::RBPlacement_setOrient", _wrap_RBPlacement_setOrient, file);
    newXS("UCLAscriptc::RBPlacement_findCoreRow", _wrap_RBPlacement_findCoreRow, file);
    newXS("UCLAscriptc::RBPlacement_findSubRow", _wrap_RBPlacement_findSubRow, file);
    newXS("UCLAscriptc::RBPlacement_findBothRows", _wrap_RBPlacement_findBothRows, file);
    newXS("UCLAscriptc::RBPlacement_coreRowsBegin", _wrap_RBPlacement_coreRowsBegin, file);
    newXS("UCLAscriptc::RBPlacement_coreRowsEnd", _wrap_RBPlacement_coreRowsEnd, file);
    newXS("UCLAscriptc::RBPlacement_getNumCoreRows", _wrap_RBPlacement_getNumCoreRows, file);
    newXS("UCLAscriptc::RBPlacement_isCellInRow", _wrap_RBPlacement_isCellInRow, file);
    newXS("UCLAscriptc::RBPlacement_getCellCoord", _wrap_RBPlacement_getCellCoord, file);
    newXS("UCLAscriptc::RBPlacement_extractCellsFromSR", _wrap_RBPlacement_extractCellsFromSR, file);
    newXS("UCLAscriptc::RBPlacement_embedCellsInSR", _wrap_RBPlacement_embedCellsInSR, file);
    newXS("UCLAscriptc::RBPlacement_permuteCellsInSR", _wrap_RBPlacement_permuteCellsInSR, file);
    newXS("UCLAscriptc::RBPlacement_placeTerms", _wrap_RBPlacement_placeTerms, file);
    newXS("UCLAscriptc::RBPlacement_evalHPWL", _wrap_RBPlacement_evalHPWL, file);
    newXS("UCLAscriptc::RBPlacement_evalMSTWL", _wrap_RBPlacement_evalMSTWL, file);
    newXS("UCLAscriptc::RBPlacement_evalWeightedWL", _wrap_RBPlacement_evalWeightedWL, file);
    newXS("UCLAscriptc::RBPlacement_evalNetsHPWL", _wrap_RBPlacement_evalNetsHPWL, file);
    newXS("UCLAscriptc::RBPlacement_getHGraph", _wrap_RBPlacement_getHGraph, file);
    newXS("UCLAscriptc::RBPlacement_isConsistent", _wrap_RBPlacement_isConsistent, file);
    newXS("UCLAscriptc::RBPlacement_printRows", _wrap_RBPlacement_printRows, file);
    newXS("UCLAscriptc::RBPlacement_saveAsSCL", _wrap_RBPlacement_saveAsSCL, file);
    newXS("UCLAscriptc::RBPlacement_saveAsNodesNetsWts", _wrap_RBPlacement_saveAsNodesNetsWts, file);
    newXS("UCLAscriptc::RBPlacement_saveAsNetDAre", _wrap_RBPlacement_saveAsNetDAre, file);
    newXS("UCLAscriptc::RBPlacement_savePlacement", _wrap_RBPlacement_savePlacement, file);
    newXS("UCLAscriptc::RBPlacement_saveAsSpatialConstraints", _wrap_RBPlacement_saveAsSpatialConstraints, file);
    newXS("UCLAscriptc::RBPlacement_saveAsPlot", _wrap_RBPlacement_saveAsPlot, file);
    newXS("UCLAscriptc::RBPlacement_remOverlaps", _wrap_RBPlacement_remOverlaps, file);
    newXS("UCLAscriptc::RBPlacement_remOverlapsVert", _wrap_RBPlacement_remOverlapsVert, file);
    newXS("UCLAscriptc::RBPlacement_permuteCellsAndWSInSR", _wrap_RBPlacement_permuteCellsAndWSInSR, file);
    newXS("UCLAscriptc::RBPlacement_updateIronedCells", _wrap_RBPlacement_updateIronedCells, file);
    newXS("UCLAscriptc::RBPlacement_updateIronedCellsLR", _wrap_RBPlacement_updateIronedCellsLR, file);
    newXS("UCLAscriptc::RBPlacement_updateIronedCellsRL", _wrap_RBPlacement_updateIronedCellsRL, file);
    newXS("UCLAscriptc::RBPlacement_calcInstHPWL", _wrap_RBPlacement_calcInstHPWL, file);
    newXS("UCLAscriptc::RBPlacement_saveLEFDEF", _wrap_RBPlacement_saveLEFDEF, file);
    newXS("UCLAscriptc::RBPlacement_getBBox", _wrap_RBPlacement_getBBox, file);
    newXS("UCLAscriptc::RBPlacement_Parameters_verb_set", _wrap_RBPlacement_Parameters_verb_set, file);
    newXS("UCLAscriptc::RBPlacement_Parameters_verb_get", _wrap_RBPlacement_Parameters_verb_get, file);
    newXS("UCLAscriptc::RBPlacement_Parameters_numRowsToRemove_set", _wrap_RBPlacement_Parameters_numRowsToRemove_set, file);
    newXS("UCLAscriptc::RBPlacement_Parameters_numRowsToRemove_get", _wrap_RBPlacement_Parameters_numRowsToRemove_get, file);
    newXS("UCLAscriptc::RBPlacement_Parameters_spaceCellsAlg_set", _wrap_RBPlacement_Parameters_spaceCellsAlg_set, file);
    newXS("UCLAscriptc::RBPlacement_Parameters_spaceCellsAlg_get", _wrap_RBPlacement_Parameters_spaceCellsAlg_get, file);
    newXS("UCLAscriptc::RBPlacement_Parameters_remCongestion_set", _wrap_RBPlacement_Parameters_remCongestion_set, file);
    newXS("UCLAscriptc::RBPlacement_Parameters_remCongestion_get", _wrap_RBPlacement_Parameters_remCongestion_get, file);
    newXS("UCLAscriptc::new_RBPlacement_Parameters", _wrap_new_RBPlacement_Parameters, file);
    newXS("UCLAscriptc::new_CompareCellIdsByX", _wrap_new_CompareCellIdsByX, file);
    newXS("UCLAscriptc::masterNodeInfo_nodeInfo_set", _wrap_masterNodeInfo_nodeInfo_set, file);
    newXS("UCLAscriptc::masterNodeInfo_nodeInfo_get", _wrap_masterNodeInfo_nodeInfo_get, file);
    newXS("UCLAscriptc::masterNodeInfo_name_get", _wrap_masterNodeInfo_name_get, file);
    newXS("UCLAscriptc::masterNodeInfo_index_set", _wrap_masterNodeInfo_index_set, file);
    newXS("UCLAscriptc::masterNodeInfo_index_get", _wrap_masterNodeInfo_index_get, file);
    newXS("UCLAscriptc::masterNodeInfo_pinNames_set", _wrap_masterNodeInfo_pinNames_set, file);
    newXS("UCLAscriptc::masterNodeInfo_pinNames_get", _wrap_masterNodeInfo_pinNames_get, file);
    newXS("UCLAscriptc::masterNodeInfo_pinOffsets_set", _wrap_masterNodeInfo_pinOffsets_set, file);
    newXS("UCLAscriptc::masterNodeInfo_pinOffsets_get", _wrap_masterNodeInfo_pinOffsets_get, file);
    newXS("UCLAscriptc::nodesMasInfo_masterNodeIndex_set", _wrap_nodesMasInfo_masterNodeIndex_set, file);
    newXS("UCLAscriptc::nodesMasInfo_masterNodeIndex_get", _wrap_nodesMasInfo_masterNodeIndex_get, file);
    newXS("UCLAscriptc::new_nodesMasInfo", _wrap_new_nodesMasInfo, file);
    newXS("UCLAscriptc::nodesMasInfo_putIndex", _wrap_nodesMasInfo_putIndex, file);
    newXS("UCLAscriptc::nodesMasInfo_getMasterIndex", _wrap_nodesMasInfo_getMasterIndex, file);
    newXS("UCLAscriptc::new_CapoPlacer", _wrap_new_CapoPlacer, file);
    newXS("UCLAscriptc::delete_CapoPlacer", _wrap_delete_CapoPlacer, file);
    newXS("UCLAscriptc::CapoPlacer_estimateWL", _wrap_CapoPlacer_estimateWL, file);
    newXS("UCLAscriptc::CapoPlacer_getBBoxPerLayer", _wrap_CapoPlacer_getBBoxPerLayer, file);
    newXS("UCLAscriptc::CapoPlacer_getCutPerLayer", _wrap_CapoPlacer_getCutPerLayer, file);
    newXS("UCLAscriptc::CapoPlacer_getNodesInEachBlock", _wrap_CapoPlacer_getNodesInEachBlock, file);
    newXS("UCLAscriptc::CapoPlacer_getTerminalsToEachBlock", _wrap_CapoPlacer_getTerminalsToEachBlock, file);
    newXS("UCLAscriptc::CapoPlacer_getCellToBlockMap", _wrap_CapoPlacer_getCellToBlockMap, file);
    newXS("UCLAscriptc::CapoPlacer_getPinLocation", _wrap_CapoPlacer_getPinLocation, file);
    newXS("UCLAscriptc::CapoPlacer_getNetlistHGraph", _wrap_CapoPlacer_getNetlistHGraph, file);
    newXS("UCLAscriptc::CapoPlacer_getParams", _wrap_CapoPlacer_getParams, file);
    newXS("UCLAscriptc::CapoPlacer_getPlacement", _wrap_CapoPlacer_getPlacement, file);
    newXS("UCLAscriptc::CapoPlacer_printCutDensityStats", _wrap_CapoPlacer_printCutDensityStats, file);
    newXS("UCLAscriptc::CapoPlacer_printSmallProblemStats", _wrap_CapoPlacer_printSmallProblemStats, file);
    newXS("UCLAscriptc::CapoPlacer_printNetlistStats", _wrap_CapoPlacer_printNetlistStats, file);
    newXS("UCLAscriptc::CapoPlacer_getNetCutInfo", _wrap_CapoPlacer_getNetCutInfo, file);
    newXS("UCLAscriptc::CapoPlacer_getTotalNetCut", _wrap_CapoPlacer_getTotalNetCut, file);
    newXS("UCLAscriptc::CapoPlacer_getBlockMembership", _wrap_CapoPlacer_getBlockMembership, file);
    newXS("UCLAscriptc::CapoPlacer_printBlockMembership", _wrap_CapoPlacer_printBlockMembership, file);
    newXS("UCLAscriptc::CapoPlacer_getHierCellNames", _wrap_CapoPlacer_getHierCellNames, file);
    newXS("UCLAscriptc::CapoPlacer_printHierCellNames", _wrap_CapoPlacer_printHierCellNames, file);
    newXS("UCLAscriptc::CapoPlacer_saveSmallProblem", _wrap_CapoPlacer_saveSmallProblem, file);
    newXS("UCLAscriptc::CapoSplitterParams_doRepartitioning_set", _wrap_CapoSplitterParams_doRepartitioning_set, file);
    newXS("UCLAscriptc::CapoSplitterParams_doRepartitioning_get", _wrap_CapoSplitterParams_doRepartitioning_get, file);
    newXS("UCLAscriptc::CapoSplitterParams_useWSTolMethod_set", _wrap_CapoSplitterParams_useWSTolMethod_set, file);
    newXS("UCLAscriptc::CapoSplitterParams_useWSTolMethod_get", _wrap_CapoSplitterParams_useWSTolMethod_get, file);
    newXS("UCLAscriptc::CapoSplitterParams_constantTolerance_set", _wrap_CapoSplitterParams_constantTolerance_set, file);
    newXS("UCLAscriptc::CapoSplitterParams_constantTolerance_get", _wrap_CapoSplitterParams_constantTolerance_get, file);
    newXS("UCLAscriptc::CapoSplitterParams_numMLSets_set", _wrap_CapoSplitterParams_numMLSets_set, file);
    newXS("UCLAscriptc::CapoSplitterParams_numMLSets_get", _wrap_CapoSplitterParams_numMLSets_get, file);
    newXS("UCLAscriptc::CapoSplitterParams_useNameHierarchy_set", _wrap_CapoSplitterParams_useNameHierarchy_set, file);
    newXS("UCLAscriptc::CapoSplitterParams_useNameHierarchy_get", _wrap_CapoSplitterParams_useNameHierarchy_get, file);
    newXS("UCLAscriptc::CapoSplitterParams_delimiters_set", _wrap_CapoSplitterParams_delimiters_set, file);
    newXS("UCLAscriptc::CapoSplitterParams_delimiters_get", _wrap_CapoSplitterParams_delimiters_get, file);
    newXS("UCLAscriptc::CapoSplitterParams_verb_set", _wrap_CapoSplitterParams_verb_set, file);
    newXS("UCLAscriptc::CapoSplitterParams_verb_get", _wrap_CapoSplitterParams_verb_get, file);
    newXS("UCLAscriptc::new_CapoSplitterParams", _wrap_new_CapoSplitterParams, file);
    newXS("UCLAscriptc::CapoParameters_verb_set", _wrap_CapoParameters_verb_set, file);
    newXS("UCLAscriptc::CapoParameters_verb_get", _wrap_CapoParameters_verb_get, file);
    newXS("UCLAscriptc::CapoParameters_stopAtBlocks_set", _wrap_CapoParameters_stopAtBlocks_set, file);
    newXS("UCLAscriptc::CapoParameters_stopAtBlocks_get", _wrap_CapoParameters_stopAtBlocks_get, file);
    newXS("UCLAscriptc::CapoParameters_replaceSmallBlocks_set", _wrap_CapoParameters_replaceSmallBlocks_set, file);
    newXS("UCLAscriptc::CapoParameters_replaceSmallBlocks_get", _wrap_CapoParameters_replaceSmallBlocks_get, file);
    newXS("UCLAscriptc::CapoParameters_useActualPinLocs_set", _wrap_CapoParameters_useActualPinLocs_set, file);
    newXS("UCLAscriptc::CapoParameters_useActualPinLocs_get", _wrap_CapoParameters_useActualPinLocs_get, file);
    newXS("UCLAscriptc::CapoParameters_smallPartThreshold_set", _wrap_CapoParameters_smallPartThreshold_set, file);
    newXS("UCLAscriptc::CapoParameters_smallPartThreshold_get", _wrap_CapoParameters_smallPartThreshold_get, file);
    newXS("UCLAscriptc::CapoParameters_smallPlaceThreshold_set", _wrap_CapoParameters_smallPlaceThreshold_set, file);
    newXS("UCLAscriptc::CapoParameters_smallPlaceThreshold_get", _wrap_CapoParameters_smallPlaceThreshold_get, file);
    newXS("UCLAscriptc::CapoParameters_doOverlapping_set", _wrap_CapoParameters_doOverlapping_set, file);
    newXS("UCLAscriptc::CapoParameters_doOverlapping_get", _wrap_CapoParameters_doOverlapping_get, file);
    newXS("UCLAscriptc::CapoParameters_startOverlappingLayer_set", _wrap_CapoParameters_startOverlappingLayer_set, file);
    newXS("UCLAscriptc::CapoParameters_startOverlappingLayer_get", _wrap_CapoParameters_startOverlappingLayer_get, file);
    newXS("UCLAscriptc::CapoParameters_endOverlappingLayer_set", _wrap_CapoParameters_endOverlappingLayer_set, file);
    newXS("UCLAscriptc::CapoParameters_endOverlappingLayer_get", _wrap_CapoParameters_endOverlappingLayer_get, file);
    newXS("UCLAscriptc::CapoParameters_propFromPl_set", _wrap_CapoParameters_propFromPl_set, file);
    newXS("UCLAscriptc::CapoParameters_propFromPl_get", _wrap_CapoParameters_propFromPl_get, file);
    newXS("UCLAscriptc::CapoParameters_useKPl_set", _wrap_CapoParameters_useKPl_set, file);
    newXS("UCLAscriptc::CapoParameters_useKPl_get", _wrap_CapoParameters_useKPl_get, file);
    newXS("UCLAscriptc::CapoParameters_mlParams_set", _wrap_CapoParameters_mlParams_set, file);
    newXS("UCLAscriptc::CapoParameters_mlParams_get", _wrap_CapoParameters_mlParams_get, file);
    newXS("UCLAscriptc::CapoParameters_smplParams_set", _wrap_CapoParameters_smplParams_set, file);
    newXS("UCLAscriptc::CapoParameters_smplParams_get", _wrap_CapoParameters_smplParams_get, file);
    newXS("UCLAscriptc::CapoParameters_lookAhead_set", _wrap_CapoParameters_lookAhead_set, file);
    newXS("UCLAscriptc::CapoParameters_lookAhead_get", _wrap_CapoParameters_lookAhead_get, file);
    newXS("UCLAscriptc::CapoParameters_allowRowSplits_set", _wrap_CapoParameters_allowRowSplits_set, file);
    newXS("UCLAscriptc::CapoParameters_allowRowSplits_get", _wrap_CapoParameters_allowRowSplits_get, file);
    newXS("UCLAscriptc::CapoParameters_splitterParams_set", _wrap_CapoParameters_splitterParams_set, file);
    newXS("UCLAscriptc::CapoParameters_splitterParams_get", _wrap_CapoParameters_splitterParams_get, file);
    newXS("UCLAscriptc::CapoParameters_plotBlocks_set", _wrap_CapoParameters_plotBlocks_set, file);
    newXS("UCLAscriptc::CapoParameters_plotBlocks_get", _wrap_CapoParameters_plotBlocks_get, file);
    newXS("UCLAscriptc::CapoParameters_saveLayerBBoxes_set", _wrap_CapoParameters_saveLayerBBoxes_set, file);
    newXS("UCLAscriptc::CapoParameters_saveLayerBBoxes_get", _wrap_CapoParameters_saveLayerBBoxes_get, file);
    newXS("UCLAscriptc::CapoParameters_saveBlocks_set", _wrap_CapoParameters_saveBlocks_set, file);
    newXS("UCLAscriptc::CapoParameters_saveBlocks_get", _wrap_CapoParameters_saveBlocks_get, file);
    newXS("UCLAscriptc::CapoParameters_saveSmallPlProb_set", _wrap_CapoParameters_saveSmallPlProb_set, file);
    newXS("UCLAscriptc::CapoParameters_saveSmallPlProb_get", _wrap_CapoParameters_saveSmallPlProb_get, file);
    newXS("UCLAscriptc::new_CapoParameters", _wrap_new_CapoParameters, file);
    newXS("UCLAscriptc::CapoParameters_printHelp", _wrap_CapoParameters_printHelp, file);
    newXS("UCLAscriptc::MetaPlacerParams_verb_set", _wrap_MetaPlacerParams_verb_set, file);
    newXS("UCLAscriptc::MetaPlacerParams_verb_get", _wrap_MetaPlacerParams_verb_get, file);
    newXS("UCLAscriptc::MetaPlacerParams_save_set", _wrap_MetaPlacerParams_save_set, file);
    newXS("UCLAscriptc::MetaPlacerParams_save_get", _wrap_MetaPlacerParams_save_get, file);
    newXS("UCLAscriptc::MetaPlacerParams_flip_set", _wrap_MetaPlacerParams_flip_set, file);
    newXS("UCLAscriptc::MetaPlacerParams_flip_get", _wrap_MetaPlacerParams_flip_get, file);
    newXS("UCLAscriptc::MetaPlacerParams_skipRowIroning_set", _wrap_MetaPlacerParams_skipRowIroning_set, file);
    newXS("UCLAscriptc::MetaPlacerParams_skipRowIroning_get", _wrap_MetaPlacerParams_skipRowIroning_get, file);
    newXS("UCLAscriptc::new_MetaPlacerParams", _wrap_new_MetaPlacerParams, file);
    newXS("UCLAscriptc::new_MetaPlacer", _wrap_new_MetaPlacer, file);
    newXS("UCLAscriptc::delete_MetaPlacer", _wrap_delete_MetaPlacer, file);
    newXS("UCLAscriptc::new_PartitioningProblem", _wrap_new_PartitioningProblem, file);
    newXS("UCLAscriptc::delete_PartitioningProblem", _wrap_delete_PartitioningProblem, file);
    newXS("UCLAscriptc::PartitioningProblem_propagateTerminals", _wrap_PartitioningProblem_propagateTerminals, file);
    newXS("UCLAscriptc::PartitioningProblem_saveAsNetDAre", _wrap_PartitioningProblem_saveAsNetDAre, file);
    newXS("UCLAscriptc::PartitioningProblem_saveAsNodesNets", _wrap_PartitioningProblem_saveAsNodesNets, file);
    newXS("UCLAscriptc::PartitioningProblem_saveBestSol", _wrap_PartitioningProblem_saveBestSol, file);
    newXS("UCLAscriptc::PartitioningProblem_reserveBuffers", _wrap_PartitioningProblem_reserveBuffers, file);
    newXS("UCLAscriptc::PartitioningProblem_isDataOwned", _wrap_PartitioningProblem_isDataOwned, file);
    newXS("UCLAscriptc::PartitioningProblem_partsComeFromGrid", _wrap_PartitioningProblem_partsComeFromGrid, file);
    newXS("UCLAscriptc::PartitioningProblem_getNumXParts", _wrap_PartitioningProblem_getNumXParts, file);
    newXS("UCLAscriptc::PartitioningProblem_getNumYParts", _wrap_PartitioningProblem_getNumYParts, file);
    newXS("UCLAscriptc::PartitioningProblem_getXTics", _wrap_PartitioningProblem_getXTics, file);
    newXS("UCLAscriptc::PartitioningProblem_getYTics", _wrap_PartitioningProblem_getYTics, file);
    newXS("UCLAscriptc::PartitioningProblem_getHGraph", _wrap_PartitioningProblem_getHGraph, file);
    newXS("UCLAscriptc::PartitioningProblem_getHGraphPointer", _wrap_PartitioningProblem_getHGraphPointer, file);
    newXS("UCLAscriptc::PartitioningProblem_getParameters", _wrap_PartitioningProblem_getParameters, file);
    newXS("UCLAscriptc::PartitioningProblem_getSolnBuffers", _wrap_PartitioningProblem_getSolnBuffers, file);
    newXS("UCLAscriptc::PartitioningProblem_getBestSoln", _wrap_PartitioningProblem_getBestSoln, file);
    newXS("UCLAscriptc::PartitioningProblem_setSolnBuffers", _wrap_PartitioningProblem_setSolnBuffers, file);
    newXS("UCLAscriptc::PartitioningProblem_swapOutSolnBuffers", _wrap_PartitioningProblem_swapOutSolnBuffers, file);
    newXS("UCLAscriptc::PartitioningProblem_swapOutFixedConst", _wrap_PartitioningProblem_swapOutFixedConst, file);
    newXS("UCLAscriptc::PartitioningProblem_swapOutHGraph", _wrap_PartitioningProblem_swapOutHGraph, file);
    newXS("UCLAscriptc::PartitioningProblem_getCosts", _wrap_PartitioningProblem_getCosts, file);
    newXS("UCLAscriptc::PartitioningProblem_getViolations", _wrap_PartitioningProblem_getViolations, file);
    newXS("UCLAscriptc::PartitioningProblem_getImbalances", _wrap_PartitioningProblem_getImbalances, file);
    newXS("UCLAscriptc::PartitioningProblem_getFixedConstr", _wrap_PartitioningProblem_getFixedConstr, file);
    newXS("UCLAscriptc::PartitioningProblem_getCapacities", _wrap_PartitioningProblem_getCapacities, file);
    newXS("UCLAscriptc::PartitioningProblem_getMaxCapacities", _wrap_PartitioningProblem_getMaxCapacities, file);
    newXS("UCLAscriptc::PartitioningProblem_getMinCapacities", _wrap_PartitioningProblem_getMinCapacities, file);
    newXS("UCLAscriptc::PartitioningProblem_getTotalWeight", _wrap_PartitioningProblem_getTotalWeight, file);
    newXS("UCLAscriptc::PartitioningProblem_getPartitions", _wrap_PartitioningProblem_getPartitions, file);
    newXS("UCLAscriptc::PartitioningProblem_getPartitionCenters", _wrap_PartitioningProblem_getPartitionCenters, file);
    newXS("UCLAscriptc::PartitioningProblem_getScalingFactorForBBoxQuantization", _wrap_PartitioningProblem_getScalingFactorForBBoxQuantization, file);
    newXS("UCLAscriptc::PartitioningProblem_getPadBlocks", _wrap_PartitioningProblem_getPadBlocks, file);
    newXS("UCLAscriptc::PartitioningProblem_getPadBlockCenters", _wrap_PartitioningProblem_getPadBlockCenters, file);
    newXS("UCLAscriptc::PartitioningProblem_getTerminalToBlock", _wrap_PartitioningProblem_getTerminalToBlock, file);
    newXS("UCLAscriptc::PartitioningProblem_getNumPartitions", _wrap_PartitioningProblem_getNumPartitions, file);
    newXS("UCLAscriptc::PartitioningProblem_getBestSolnNum", _wrap_PartitioningProblem_getBestSolnNum, file);
    newXS("UCLAscriptc::PartitioningProblem_setBestSolnNum", _wrap_PartitioningProblem_setBestSolnNum, file);
    newXS("UCLAscriptc::PartitioningProblem_printLargestCellStats", _wrap_PartitioningProblem_printLargestCellStats, file);
    newXS("UCLAscriptc::PartitioningProblem_getPinBalances", _wrap_PartitioningProblem_getPinBalances, file);
    newXS("UCLAscriptc::PartitioningProblem_printPinBalances", _wrap_PartitioningProblem_printPinBalances, file);
    newXS("UCLAscriptc::PartitioningProblem_getAttributes", _wrap_PartitioningProblem_getAttributes, file);
    newXS("UCLAscriptc::PartitioningProblem_Parameters_verbosity_set", _wrap_PartitioningProblem_Parameters_verbosity_set, file);
    newXS("UCLAscriptc::PartitioningProblem_Parameters_verbosity_get", _wrap_PartitioningProblem_Parameters_verbosity_get, file);
    newXS("UCLAscriptc::new_PartitioningProblem_Parameters", _wrap_new_PartitioningProblem_Parameters, file);
    newXS("UCLAscriptc::PartitioningProblem_Attributes_hasMaxCap_set", _wrap_PartitioningProblem_Attributes_hasMaxCap_set, file);
    newXS("UCLAscriptc::PartitioningProblem_Attributes_hasMaxCap_get", _wrap_PartitioningProblem_Attributes_hasMaxCap_get, file);
    newXS("UCLAscriptc::PartitioningProblem_Attributes_hasMinCap_set", _wrap_PartitioningProblem_Attributes_hasMinCap_set, file);
    newXS("UCLAscriptc::PartitioningProblem_Attributes_hasMinCap_get", _wrap_PartitioningProblem_Attributes_hasMinCap_get, file);
    newXS("UCLAscriptc::PartitioningProblem_Attributes_hasCap_set", _wrap_PartitioningProblem_Attributes_hasCap_set, file);
    newXS("UCLAscriptc::PartitioningProblem_Attributes_hasCap_get", _wrap_PartitioningProblem_Attributes_hasCap_get, file);
    newXS("UCLAscriptc::PartitioningProblem_Attributes_hasPartBBoxes_set", _wrap_PartitioningProblem_Attributes_hasPartBBoxes_set, file);
    newXS("UCLAscriptc::PartitioningProblem_Attributes_hasPartBBoxes_get", _wrap_PartitioningProblem_Attributes_hasPartBBoxes_get, file);
    newXS("UCLAscriptc::PartitioningProblem_Attributes_hasPadBBoxes_set", _wrap_PartitioningProblem_Attributes_hasPadBBoxes_set, file);
    newXS("UCLAscriptc::PartitioningProblem_Attributes_hasPadBBoxes_get", _wrap_PartitioningProblem_Attributes_hasPadBBoxes_get, file);
    newXS("UCLAscriptc::PartitioningProblem_Attributes_hasPartCenters_set", _wrap_PartitioningProblem_Attributes_hasPartCenters_set, file);
    newXS("UCLAscriptc::PartitioningProblem_Attributes_hasPartCenters_get", _wrap_PartitioningProblem_Attributes_hasPartCenters_get, file);
    newXS("UCLAscriptc::PartitioningProblem_Attributes_hasPadCenters_set", _wrap_PartitioningProblem_Attributes_hasPadCenters_set, file);
    newXS("UCLAscriptc::PartitioningProblem_Attributes_hasPadCenters_get", _wrap_PartitioningProblem_Attributes_hasPadCenters_get, file);
    newXS("UCLAscriptc::PartitioningProblem_Attributes_hasTotalWeight_set", _wrap_PartitioningProblem_Attributes_hasTotalWeight_set, file);
    newXS("UCLAscriptc::PartitioningProblem_Attributes_hasTotalWeight_get", _wrap_PartitioningProblem_Attributes_hasTotalWeight_get, file);
    newXS("UCLAscriptc::PartitioningProblem_Attributes_hasClusterDegrees_set", _wrap_PartitioningProblem_Attributes_hasClusterDegrees_set, file);
    newXS("UCLAscriptc::PartitioningProblem_Attributes_hasClusterDegrees_get", _wrap_PartitioningProblem_Attributes_hasClusterDegrees_get, file);
    newXS("UCLAscriptc::new_PartitioningProblem_Attributes", _wrap_new_PartitioningProblem_Attributes, file);
    newXS("UCLAscriptc::PartitioningProblem_Attributes_clearAll", _wrap_PartitioningProblem_Attributes_clearAll, file);
    newXS("UCLAscriptc::PartitioningProblem_Attributes_setAll", _wrap_PartitioningProblem_Attributes_setAll, file);
    newXS("UCLAscriptc::new_BaseMLPart", _wrap_new_BaseMLPart, file);
    newXS("UCLAscriptc::delete_BaseMLPart", _wrap_delete_BaseMLPart, file);
    newXS("UCLAscriptc::BaseMLPart_getPartitionArea", _wrap_BaseMLPart_getPartitionArea, file);
    newXS("UCLAscriptc::BaseMLPart_getPartitionRatio", _wrap_BaseMLPart_getPartitionRatio, file);
    newXS("UCLAscriptc::BaseMLPart_getBestSolnCost", _wrap_BaseMLPart_getBestSolnCost, file);
    newXS("UCLAscriptc::BaseMLPart_getAveSolnCost", _wrap_BaseMLPart_getAveSolnCost, file);
    newXS("UCLAscriptc::BaseMLPart_getNumLegalSolns", _wrap_BaseMLPart_getNumLegalSolns, file);
    newXS("UCLAscriptc::BaseMLPart_getUserTime", _wrap_BaseMLPart_getUserTime, file);
    newXS("UCLAscriptc::BaseMLPart_Parameters_savePartProb_set", _wrap_BaseMLPart_Parameters_savePartProb_set, file);
    newXS("UCLAscriptc::BaseMLPart_Parameters_savePartProb_get", _wrap_BaseMLPart_Parameters_savePartProb_get, file);
    newXS("UCLAscriptc::BaseMLPart_Parameters_flatPartitioner_set", _wrap_BaseMLPart_Parameters_flatPartitioner_set, file);
    newXS("UCLAscriptc::BaseMLPart_Parameters_flatPartitioner_get", _wrap_BaseMLPart_Parameters_flatPartitioner_get, file);
    newXS("UCLAscriptc::BaseMLPart_Parameters_useBBonTop_set", _wrap_BaseMLPart_Parameters_useBBonTop_set, file);
    newXS("UCLAscriptc::BaseMLPart_Parameters_useBBonTop_get", _wrap_BaseMLPart_Parameters_useBBonTop_get, file);
    newXS("UCLAscriptc::BaseMLPart_Parameters_partFuzziness_set", _wrap_BaseMLPart_Parameters_partFuzziness_set, file);
    newXS("UCLAscriptc::BaseMLPart_Parameters_partFuzziness_get", _wrap_BaseMLPart_Parameters_partFuzziness_get, file);
    newXS("UCLAscriptc::BaseMLPart_Parameters_runsPerClTree_set", _wrap_BaseMLPart_Parameters_runsPerClTree_set, file);
    newXS("UCLAscriptc::BaseMLPart_Parameters_runsPerClTree_get", _wrap_BaseMLPart_Parameters_runsPerClTree_get, file);
    newXS("UCLAscriptc::BaseMLPart_Parameters_solnPoolOnTopLevel_set", _wrap_BaseMLPart_Parameters_solnPoolOnTopLevel_set, file);
    newXS("UCLAscriptc::BaseMLPart_Parameters_solnPoolOnTopLevel_get", _wrap_BaseMLPart_Parameters_solnPoolOnTopLevel_get, file);
    newXS("UCLAscriptc::BaseMLPart_Parameters_toleranceMultiple_set", _wrap_BaseMLPart_Parameters_toleranceMultiple_set, file);
    newXS("UCLAscriptc::BaseMLPart_Parameters_toleranceMultiple_get", _wrap_BaseMLPart_Parameters_toleranceMultiple_get, file);
    newXS("UCLAscriptc::BaseMLPart_Parameters_toleranceAlpha_set", _wrap_BaseMLPart_Parameters_toleranceAlpha_set, file);
    newXS("UCLAscriptc::BaseMLPart_Parameters_toleranceAlpha_get", _wrap_BaseMLPart_Parameters_toleranceAlpha_get, file);
    newXS("UCLAscriptc::BaseMLPart_Parameters_useTwoPartCalls_set", _wrap_BaseMLPart_Parameters_useTwoPartCalls_set, file);
    newXS("UCLAscriptc::BaseMLPart_Parameters_useTwoPartCalls_get", _wrap_BaseMLPart_Parameters_useTwoPartCalls_get, file);
    newXS("UCLAscriptc::BaseMLPart_Parameters_netThreshold_set", _wrap_BaseMLPart_Parameters_netThreshold_set, file);
    newXS("UCLAscriptc::BaseMLPart_Parameters_netThreshold_get", _wrap_BaseMLPart_Parameters_netThreshold_get, file);
    newXS("UCLAscriptc::BaseMLPart_Parameters_Vcycling_set", _wrap_BaseMLPart_Parameters_Vcycling_set, file);
    newXS("UCLAscriptc::BaseMLPart_Parameters_Vcycling_get", _wrap_BaseMLPart_Parameters_Vcycling_get, file);
    newXS("UCLAscriptc::BaseMLPart_Parameters_timeLimit_set", _wrap_BaseMLPart_Parameters_timeLimit_set, file);
    newXS("UCLAscriptc::BaseMLPart_Parameters_timeLimit_get", _wrap_BaseMLPart_Parameters_timeLimit_get, file);
    newXS("UCLAscriptc::BaseMLPart_Parameters_expPrint2Costs_set", _wrap_BaseMLPart_Parameters_expPrint2Costs_set, file);
    newXS("UCLAscriptc::BaseMLPart_Parameters_expPrint2Costs_get", _wrap_BaseMLPart_Parameters_expPrint2Costs_get, file);
    newXS("UCLAscriptc::BaseMLPart_Parameters_clusterToTerminals_set", _wrap_BaseMLPart_Parameters_clusterToTerminals_set, file);
    newXS("UCLAscriptc::BaseMLPart_Parameters_clusterToTerminals_get", _wrap_BaseMLPart_Parameters_clusterToTerminals_get, file);
    newXS("UCLAscriptc::BaseMLPart_Parameters_seedTopLvlSoln_set", _wrap_BaseMLPart_Parameters_seedTopLvlSoln_set, file);
    newXS("UCLAscriptc::BaseMLPart_Parameters_seedTopLvlSoln_get", _wrap_BaseMLPart_Parameters_seedTopLvlSoln_get, file);
    newXS("UCLAscriptc::BaseMLPart_Parameters_pruningPercent_set", _wrap_BaseMLPart_Parameters_pruningPercent_set, file);
    newXS("UCLAscriptc::BaseMLPart_Parameters_pruningPercent_get", _wrap_BaseMLPart_Parameters_pruningPercent_get, file);
    newXS("UCLAscriptc::BaseMLPart_Parameters_pruningPoint_set", _wrap_BaseMLPart_Parameters_pruningPoint_set, file);
    newXS("UCLAscriptc::BaseMLPart_Parameters_pruningPoint_get", _wrap_BaseMLPart_Parameters_pruningPoint_get, file);
    newXS("UCLAscriptc::BaseMLPart_Parameters_maxNumPassesAtBottom_set", _wrap_BaseMLPart_Parameters_maxNumPassesAtBottom_set, file);
    newXS("UCLAscriptc::BaseMLPart_Parameters_maxNumPassesAtBottom_get", _wrap_BaseMLPart_Parameters_maxNumPassesAtBottom_get, file);
    newXS("UCLAscriptc::BaseMLPart_Parameters_vcNumFailures_set", _wrap_BaseMLPart_Parameters_vcNumFailures_set, file);
    newXS("UCLAscriptc::BaseMLPart_Parameters_vcNumFailures_get", _wrap_BaseMLPart_Parameters_vcNumFailures_get, file);
    newXS("UCLAscriptc::BaseMLPart_Parameters_vcImproveRatio_set", _wrap_BaseMLPart_Parameters_vcImproveRatio_set, file);
    newXS("UCLAscriptc::BaseMLPart_Parameters_vcImproveRatio_get", _wrap_BaseMLPart_Parameters_vcImproveRatio_get, file);
    newXS("UCLAscriptc::BaseMLPart_Parameters_vc1ClusterRatio_set", _wrap_BaseMLPart_Parameters_vc1ClusterRatio_set, file);
    newXS("UCLAscriptc::BaseMLPart_Parameters_vc1ClusterRatio_get", _wrap_BaseMLPart_Parameters_vc1ClusterRatio_get, file);
    newXS("UCLAscriptc::BaseMLPart_Parameters_vc1FirstLevel_set", _wrap_BaseMLPart_Parameters_vc1FirstLevel_set, file);
    newXS("UCLAscriptc::BaseMLPart_Parameters_vc1FirstLevel_get", _wrap_BaseMLPart_Parameters_vc1FirstLevel_get, file);
    newXS("UCLAscriptc::BaseMLPart_Parameters_vc1LevelGrowth_set", _wrap_BaseMLPart_Parameters_vc1LevelGrowth_set, file);
    newXS("UCLAscriptc::BaseMLPart_Parameters_vc1LevelGrowth_get", _wrap_BaseMLPart_Parameters_vc1LevelGrowth_get, file);
    newXS("UCLAscriptc::BaseMLPart_Parameters_vc2ClusterRatio_set", _wrap_BaseMLPart_Parameters_vc2ClusterRatio_set, file);
    newXS("UCLAscriptc::BaseMLPart_Parameters_vc2ClusterRatio_get", _wrap_BaseMLPart_Parameters_vc2ClusterRatio_get, file);
    newXS("UCLAscriptc::BaseMLPart_Parameters_vc2FirstLevel_set", _wrap_BaseMLPart_Parameters_vc2FirstLevel_set, file);
    newXS("UCLAscriptc::BaseMLPart_Parameters_vc2FirstLevel_get", _wrap_BaseMLPart_Parameters_vc2FirstLevel_get, file);
    newXS("UCLAscriptc::BaseMLPart_Parameters_vc2LevelGrowth_set", _wrap_BaseMLPart_Parameters_vc2LevelGrowth_set, file);
    newXS("UCLAscriptc::BaseMLPart_Parameters_vc2LevelGrowth_get", _wrap_BaseMLPart_Parameters_vc2LevelGrowth_get, file);
    newXS("UCLAscriptc::BaseMLPart_Parameters_clParams_set", _wrap_BaseMLPart_Parameters_clParams_set, file);
    newXS("UCLAscriptc::BaseMLPart_Parameters_clParams_get", _wrap_BaseMLPart_Parameters_clParams_get, file);
    newXS("UCLAscriptc::new_BaseMLPart_Parameters", _wrap_new_BaseMLPart_Parameters, file);
    newXS("UCLAscriptc::new_MLPart", _wrap_new_MLPart, file);
    newXS("UCLAscriptc::delete_MLPart", _wrap_delete_MLPart, file);
    newXS("UCLAscriptc::HGraphFixed__nodeNames_set", _wrap_HGraphFixed__nodeNames_set, file);
    newXS("UCLAscriptc::HGraphFixed__nodeNames_get", _wrap_HGraphFixed__nodeNames_get, file);
    newXS("UCLAscriptc::HGraphFixed__netNames_set", _wrap_HGraphFixed__netNames_set, file);
    newXS("UCLAscriptc::HGraphFixed__netNames_get", _wrap_HGraphFixed__netNames_get, file);
    newXS("UCLAscriptc::HGraphFixed__nodeNamesMap_set", _wrap_HGraphFixed__nodeNamesMap_set, file);
    newXS("UCLAscriptc::HGraphFixed__nodeNamesMap_get", _wrap_HGraphFixed__nodeNamesMap_get, file);
    newXS("UCLAscriptc::HGraphFixed__netNamesMap_set", _wrap_HGraphFixed__netNamesMap_set, file);
    newXS("UCLAscriptc::HGraphFixed__netNamesMap_get", _wrap_HGraphFixed__netNamesMap_get, file);
    newXS("UCLAscriptc::new_HGraphFixed", _wrap_new_HGraphFixed, file);
    newXS("UCLAscriptc::HGraphFixed_getNumNodes", _wrap_HGraphFixed_getNumNodes, file);
    newXS("UCLAscriptc::HGraphFixed_getNumEdges", _wrap_HGraphFixed_getNumEdges, file);
    newXS("UCLAscriptc::HGraphFixed_getAvgNodeDegree", _wrap_HGraphFixed_getAvgNodeDegree, file);
    newXS("UCLAscriptc::HGraphFixed_getAvgEdgeDegree", _wrap_HGraphFixed_getAvgEdgeDegree, file);
    newXS("UCLAscriptc::HGraphFixed_nodesBegin", _wrap_HGraphFixed_nodesBegin, file);
    newXS("UCLAscriptc::HGraphFixed_nodesEnd", _wrap_HGraphFixed_nodesEnd, file);
    newXS("UCLAscriptc::HGraphFixed_terminalsBegin", _wrap_HGraphFixed_terminalsBegin, file);
    newXS("UCLAscriptc::HGraphFixed_terminalsEnd", _wrap_HGraphFixed_terminalsEnd, file);
    newXS("UCLAscriptc::HGraphFixed_edgesBegin", _wrap_HGraphFixed_edgesBegin, file);
    newXS("UCLAscriptc::HGraphFixed_edgesEnd", _wrap_HGraphFixed_edgesEnd, file);
    newXS("UCLAscriptc::HGraphFixed_getNodeByIdx", _wrap_HGraphFixed_getNodeByIdx, file);
    newXS("UCLAscriptc::HGraphFixed_haveSuchNode", _wrap_HGraphFixed_haveSuchNode, file);
    newXS("UCLAscriptc::HGraphFixed_haveSuchNet", _wrap_HGraphFixed_haveSuchNet, file);
    newXS("UCLAscriptc::HGraphFixed_getNodeByName", _wrap_HGraphFixed_getNodeByName, file);
    newXS("UCLAscriptc::HGraphFixed_getNetByName", _wrap_HGraphFixed_getNetByName, file);
    newXS("UCLAscriptc::HGraphFixed_getEdgeByIdx", _wrap_HGraphFixed_getEdgeByIdx, file);
    newXS("UCLAscriptc::HGraphFixed_getNodesSortedByWeights", _wrap_HGraphFixed_getNodesSortedByWeights, file);
    newXS("UCLAscriptc::HGraphFixed_getNodesSortedByDegrees", _wrap_HGraphFixed_getNodesSortedByDegrees, file);
    newXS("UCLAscriptc::HGraphFixed_maxNodeIndex", _wrap_HGraphFixed_maxNodeIndex, file);
    newXS("UCLAscriptc::HGraphFixed_maxEdgeIndex", _wrap_HGraphFixed_maxEdgeIndex, file);
    newXS("UCLAscriptc::HGraphFixed_addEdge", _wrap_HGraphFixed_addEdge, file);
    newXS("UCLAscriptc::HGraphFixed_fastAddEdge", _wrap_HGraphFixed_fastAddEdge, file);
    newXS("UCLAscriptc::HGraphFixed_adviseNodeDegrees", _wrap_HGraphFixed_adviseNodeDegrees, file);
    newXS("UCLAscriptc::HGraphFixed_finalize", _wrap_HGraphFixed_finalize, file);
    newXS("UCLAscriptc::HGraphFixed_saveAsNetDAre", _wrap_HGraphFixed_saveAsNetDAre, file);
    newXS("UCLAscriptc::HGraphFixed_saveAsNodesNetsWts", _wrap_HGraphFixed_saveAsNodesNetsWts, file);
    newXS("UCLAscriptc::HGraphFixed_isConsistent", _wrap_HGraphFixed_isConsistent, file);
    newXS("UCLAscriptc::HGraphFixed_sortAsDB", _wrap_HGraphFixed_sortAsDB, file);
    newXS("UCLAscriptc::HGraphFixed_printEdgeSizeStats", _wrap_HGraphFixed_printEdgeSizeStats, file);
    newXS("UCLAscriptc::HGraphFixed_printEdgeWtStats", _wrap_HGraphFixed_printEdgeWtStats, file);
    newXS("UCLAscriptc::HGraphFixed_printNodeWtStats", _wrap_HGraphFixed_printNodeWtStats, file);
    newXS("UCLAscriptc::HGraphFixed_printNodeDegreeStats", _wrap_HGraphFixed_printNodeDegreeStats, file);
    newXS("UCLAscriptc::new_HGfromDB", _wrap_new_HGfromDB, file);
    newXS("UCLAscriptc::HGfromDB__nodeNames_set", _wrap_HGraphFixed__nodeNames_set, file);
    newXS("UCLAscriptc::HGfromDB__nodeNames_get", _wrap_HGraphFixed__nodeNames_get, file);
    newXS("UCLAscriptc::HGfromDB__netNames_set", _wrap_HGraphFixed__netNames_set, file);
    newXS("UCLAscriptc::HGfromDB__netNames_get", _wrap_HGraphFixed__netNames_get, file);
    newXS("UCLAscriptc::HGfromDB__nodeNamesMap_set", _wrap_HGraphFixed__nodeNamesMap_set, file);
    newXS("UCLAscriptc::HGfromDB__nodeNamesMap_get", _wrap_HGraphFixed__nodeNamesMap_get, file);
    newXS("UCLAscriptc::HGfromDB__netNamesMap_set", _wrap_HGraphFixed__netNamesMap_set, file);
    newXS("UCLAscriptc::HGfromDB__netNamesMap_get", _wrap_HGraphFixed__netNamesMap_get, file);
    ST(0) = &PL_sv_yes;
    XSRETURN(1);
}


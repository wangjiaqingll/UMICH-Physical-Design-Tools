# This file was automatically generated by SWIG
package UCLAscript;
require Exporter;
require DynaLoader;
@ISA = qw(Exporter DynaLoader);
package UCLAscriptc;
bootstrap UCLAscript;
var_UCLAscript_init();
package UCLAscript;
@EXPORT = qw( );

# ---------- BASE METHODS -------------

package UCLAscript;

sub TIEHASH {
    my ($classname,$obj) = @_;
    return bless $obj, $classname;
}

sub CLEAR { }

sub FIRSTKEY { }

sub NEXTKEY { }

sub this {
    my $ptr = shift;
    return tied(%$ptr);
}


# ------- FUNCTION WRAPPERS --------

package UCLAscript;


############# Class : dbMasterCellType ##############

package dbMasterCellType;
@ISA = qw( UCLAscript );
%OWNER = ();
*COVER = *UCLAscriptc::dbMasterCellType_COVER;
*RING = *UCLAscriptc::dbMasterCellType_RING;
*BLOCK = *UCLAscriptc::dbMasterCellType_BLOCK;
*CORE = *UCLAscriptc::dbMasterCellType_CORE;
*PAD = *UCLAscriptc::dbMasterCellType_PAD;
*ENDCAP = *UCLAscriptc::dbMasterCellType_ENDCAP;
*EXTPIN = *UCLAscriptc::dbMasterCellType_EXTPIN;
*MCUNKNOWN = *UCLAscriptc::dbMasterCellType_MCUNKNOWN;
*FLIPFLOP = *UCLAscriptc::dbMasterCellType_FLIPFLOP;
*LATCH = *UCLAscriptc::dbMasterCellType_LATCH;
*INVERTER = *UCLAscriptc::dbMasterCellType_INVERTER;
*BUFFER = *UCLAscriptc::dbMasterCellType_BUFFER;
*NAND = *UCLAscriptc::dbMasterCellType_NAND;
*NOR = *UCLAscriptc::dbMasterCellType_NOR;
*CoreUNKNOWN = *UCLAscriptc::dbMasterCellType_CoreUNKNOWN;
*INPUT = *UCLAscriptc::dbMasterCellType_INPUT;
*OUTPUT = *UCLAscriptc::dbMasterCellType_OUTPUT;
*INOUT = *UCLAscriptc::dbMasterCellType_INOUT;
*POWER = *UCLAscriptc::dbMasterCellType_POWER;
*SPACER = *UCLAscriptc::dbMasterCellType_SPACER;
*PadUNKNOWN = *UCLAscriptc::dbMasterCellType_PadUNKNOWN;
sub new {
    my $self = shift;
    my @args = @_;
    $self = UCLAscriptc::new_dbMasterCellType(@args);
    return undef if (!defined($self));
    bless $self, "dbMasterCellType";
    $OWNER{$self} = 1;
    my %retval;
    tie %retval, "dbMasterCellType", $self;
    return bless \%retval,"dbMasterCellType";
}

*setCoreClass = *UCLAscriptc::dbMasterCellType_setCoreClass;
*isCover = *UCLAscriptc::dbMasterCellType_isCover;
*isRing = *UCLAscriptc::dbMasterCellType_isRing;
*isBlock = *UCLAscriptc::dbMasterCellType_isBlock;
*isCore = *UCLAscriptc::dbMasterCellType_isCore;
*isPad = *UCLAscriptc::dbMasterCellType_isPad;
*isEndCap = *UCLAscriptc::dbMasterCellType_isEndCap;
*isExtPin = *UCLAscriptc::dbMasterCellType_isExtPin;
*isUnknown = *UCLAscriptc::dbMasterCellType_isUnknown;
*isFlipFlop = *UCLAscriptc::dbMasterCellType_isFlipFlop;
*isLatch = *UCLAscriptc::dbMasterCellType_isLatch;
*isInverter = *UCLAscriptc::dbMasterCellType_isInverter;
*isBuffer = *UCLAscriptc::dbMasterCellType_isBuffer;
*isNAND = *UCLAscriptc::dbMasterCellType_isNAND;
*isNOR = *UCLAscriptc::dbMasterCellType_isNOR;
*isCoreUnknown = *UCLAscriptc::dbMasterCellType_isCoreUnknown;
*isPI = *UCLAscriptc::dbMasterCellType_isPI;
*isPO = *UCLAscriptc::dbMasterCellType_isPO;
*isPIO = *UCLAscriptc::dbMasterCellType_isPIO;
*isPPower = *UCLAscriptc::dbMasterCellType_isPPower;
*isPSpacer = *UCLAscriptc::dbMasterCellType_isPSpacer;
*isPUnknown = *UCLAscriptc::dbMasterCellType_isPUnknown;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
    };

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
    };


############# Class : dbCellType ##############

package dbCellType;
@ISA = qw( UCLAscript );
%OWNER = ();
*MacroUNINITIALIZED = *UCLAscriptc::dbCellType_MacroUNINITIALIZED;
*IO = *UCLAscriptc::dbCellType_IO;
*BLOCK = *UCLAscriptc::dbCellType_BLOCK;
*CORE = *UCLAscriptc::dbCellType_CORE;
*MacroOTHER = *UCLAscriptc::dbCellType_MacroOTHER;
*MacroUNKNOWN = *UCLAscriptc::dbCellType_MacroUNKNOWN;
*PI = *UCLAscriptc::dbCellType_PI;
*PO = *UCLAscriptc::dbCellType_PO;
*PIO = *UCLAscriptc::dbCellType_PIO;
*POTHER = *UCLAscriptc::dbCellType_POTHER;
*PUNKNOWN = *UCLAscriptc::dbCellType_PUNKNOWN;
*SC = *UCLAscriptc::dbCellType_SC;
*CC = *UCLAscriptc::dbCellType_CC;
*CoreOTHER = *UCLAscriptc::dbCellType_CoreOTHER;
sub new {
    my $self = shift;
    my @args = @_;
    $self = UCLAscriptc::new_dbCellType(@args);
    return undef if (!defined($self));
    bless $self, "dbCellType";
    $OWNER{$self} = 1;
    my %retval;
    tie %retval, "dbCellType", $self;
    return bless \%retval,"dbCellType";
}

*isInitialized = *UCLAscriptc::dbCellType_isInitialized;
*isIO = *UCLAscriptc::dbCellType_isIO;
*isBlock = *UCLAscriptc::dbCellType_isBlock;
*isCore = *UCLAscriptc::dbCellType_isCore;
*isOther = *UCLAscriptc::dbCellType_isOther;
*isUnknown = *UCLAscriptc::dbCellType_isUnknown;
*isPI = *UCLAscriptc::dbCellType_isPI;
*isPO = *UCLAscriptc::dbCellType_isPO;
*isPIO = *UCLAscriptc::dbCellType_isPIO;
*isPOther = *UCLAscriptc::dbCellType_isPOther;
*isPUnknown = *UCLAscriptc::dbCellType_isPUnknown;
*isCC = *UCLAscriptc::dbCellType_isCC;
*isSC = *UCLAscriptc::dbCellType_isSC;
*isCoreOther = *UCLAscriptc::dbCellType_isCoreOther;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
    };

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
    };


############# Class : dbNetType ##############

package dbNetType;
@ISA = qw( UCLAscript );
%OWNER = ();
*SIGNAL = *UCLAscriptc::dbNetType_SIGNAL;
*POWER = *UCLAscriptc::dbNetType_POWER;
*GROUND = *UCLAscriptc::dbNetType_GROUND;
*CLOCK = *UCLAscriptc::dbNetType_CLOCK;
*TIEOFF = *UCLAscriptc::dbNetType_TIEOFF;
*ANALOG = *UCLAscriptc::dbNetType_ANALOG;
*UNKNOWN = *UCLAscriptc::dbNetType_UNKNOWN;
sub new {
    my $self = shift;
    my @args = @_;
    $self = UCLAscriptc::new_dbNetType(@args);
    return undef if (!defined($self));
    bless $self, "dbNetType";
    $OWNER{$self} = 1;
    my %retval;
    tie %retval, "dbNetType", $self;
    return bless \%retval,"dbNetType";
}

*isSignal = *UCLAscriptc::dbNetType_isSignal;
*isPower = *UCLAscriptc::dbNetType_isPower;
*isGround = *UCLAscriptc::dbNetType_isGround;
*isClock = *UCLAscriptc::dbNetType_isClock;
*isTieOff = *UCLAscriptc::dbNetType_isTieOff;
*isAnalog = *UCLAscriptc::dbNetType_isAnalog;
*isUnknown = *UCLAscriptc::dbNetType_isUnknown;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
    };

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
    };


############# Class : dbMasterPinType ##############

package dbMasterPinType;
@ISA = qw( UCLAscript );
%OWNER = ();
*ShapeABUTMENT = *UCLAscriptc::dbMasterPinType_ShapeABUTMENT;
*ShapeFEEDTHROUGH = *UCLAscriptc::dbMasterPinType_ShapeFEEDTHROUGH;
*ShapeRING = *UCLAscriptc::dbMasterPinType_ShapeRING;
*ShapeUNKNOWN = *UCLAscriptc::dbMasterPinType_ShapeUNKNOWN;
*SIGNAL = *UCLAscriptc::dbMasterPinType_SIGNAL;
*ANALOG = *UCLAscriptc::dbMasterPinType_ANALOG;
*POWER = *UCLAscriptc::dbMasterPinType_POWER;
*GROUND = *UCLAscriptc::dbMasterPinType_GROUND;
*CLOCK = *UCLAscriptc::dbMasterPinType_CLOCK;
*TIEOFF = *UCLAscriptc::dbMasterPinType_TIEOFF;
*UseUNKNOWN = *UCLAscriptc::dbMasterPinType_UseUNKNOWN;
*OUT = *UCLAscriptc::dbMasterPinType_OUT;
*IN = *UCLAscriptc::dbMasterPinType_IN;
*INOUT = *UCLAscriptc::dbMasterPinType_INOUT;
*OUTTRISTATE = *UCLAscriptc::dbMasterPinType_OUTTRISTATE;
*DirFEEDTHROUGH = *UCLAscriptc::dbMasterPinType_DirFEEDTHROUGH;
*DirUNKNOWN = *UCLAscriptc::dbMasterPinType_DirUNKNOWN;
sub new {
    my $self = shift;
    my @args = @_;
    $self = UCLAscriptc::new_dbMasterPinType(@args);
    return undef if (!defined($self));
    bless $self, "dbMasterPinType";
    $OWNER{$self} = 1;
    my %retval;
    tie %retval, "dbMasterPinType", $self;
    return bless \%retval,"dbMasterPinType";
}

*isShapeAbutment = *UCLAscriptc::dbMasterPinType_isShapeAbutment;
*isShapeFeedthrough = *UCLAscriptc::dbMasterPinType_isShapeFeedthrough;
*isShapeRing = *UCLAscriptc::dbMasterPinType_isShapeRing;
*isShapeUnknown = *UCLAscriptc::dbMasterPinType_isShapeUnknown;
*isUseSignal = *UCLAscriptc::dbMasterPinType_isUseSignal;
*isUseAnalog = *UCLAscriptc::dbMasterPinType_isUseAnalog;
*isUsePower = *UCLAscriptc::dbMasterPinType_isUsePower;
*isUseGround = *UCLAscriptc::dbMasterPinType_isUseGround;
*isUseClock = *UCLAscriptc::dbMasterPinType_isUseClock;
*isUseTieoff = *UCLAscriptc::dbMasterPinType_isUseTieoff;
*isUseUnknown = *UCLAscriptc::dbMasterPinType_isUseUnknown;
*isDirOutput = *UCLAscriptc::dbMasterPinType_isDirOutput;
*isDirInput = *UCLAscriptc::dbMasterPinType_isDirInput;
*isDirInOut = *UCLAscriptc::dbMasterPinType_isDirInOut;
*isDirOutputTristate = *UCLAscriptc::dbMasterPinType_isDirOutputTristate;
*isDirFeedthrough = *UCLAscriptc::dbMasterPinType_isDirFeedthrough;
*isDirUnknown = *UCLAscriptc::dbMasterPinType_isDirUnknown;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
    };

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
    };


############# Class : dbContext ##############

package dbContext;
@ISA = qw( UCLAscript );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $self = shift;
    my @args = @_;
    $self = UCLAscriptc::new_dbContext(@args);
    return undef if (!defined($self));
    bless $self, "dbContext";
    $OWNER{$self} = 1;
    my %retval;
    tie %retval, "dbContext", $self;
    return bless \%retval,"dbContext";
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        UCLAscriptc::delete_dbContext($self);
        delete $OWNER{$self};
    }
}

*getMinFeatureX = *UCLAscriptc::dbContext_getMinFeatureX;
*getMinFeatureY = *UCLAscriptc::dbContext_getMinFeatureY;
*getUnits = *UCLAscriptc::dbContext_getUnits;
*getBBox = *UCLAscriptc::dbContext_getBBox;
*getNumSites = *UCLAscriptc::dbContext_getNumSites;
*getNumLayers = *UCLAscriptc::dbContext_getNumLayers;
*getNumRows = *UCLAscriptc::dbContext_getNumRows;
*getNumTracks = *UCLAscriptc::dbContext_getNumTracks;
*beginSites = *UCLAscriptc::dbContext_beginSites;
*endSites = *UCLAscriptc::dbContext_endSites;
sub getSiteByIdx {
    my @args = @_;
    my $result = UCLAscriptc::dbContext_getSiteByIdx(@args);
    return undef if (!defined($result));
    $dbSite::OWNER{$result} = 1; 
    my %resulthash;
    tie %resulthash, ref($result), $result;
    return bless \%resulthash, ref($result);
}
*beginLayers = *UCLAscriptc::dbContext_beginLayers;
*endLayers = *UCLAscriptc::dbContext_endLayers;
sub getLayerByIdx {
    my @args = @_;
    my $result = UCLAscriptc::dbContext_getLayerByIdx(@args);
    return undef if (!defined($result));
    $dbLayer::OWNER{$result} = 1; 
    my %resulthash;
    tie %resulthash, ref($result), $result;
    return bless \%resulthash, ref($result);
}
*rowsBegin = *UCLAscriptc::dbContext_rowsBegin;
*rowsEnd = *UCLAscriptc::dbContext_rowsEnd;
sub getRowByIdx {
    my @args = @_;
    my $result = UCLAscriptc::dbContext_getRowByIdx(@args);
    return undef if (!defined($result));
    $dbRow::OWNER{$result} = 1; 
    my %resulthash;
    tie %resulthash, ref($result), $result;
    return bless \%resulthash, ref($result);
}
*beginTracks = *UCLAscriptc::dbContext_beginTracks;
*endTracks = *UCLAscriptc::dbContext_endTracks;
*getTracks = *UCLAscriptc::dbContext_getTracks;
sub getTrackByIdx {
    my @args = @_;
    my $result = UCLAscriptc::dbContext_getTrackByIdx(@args);
    return undef if (!defined($result));
    $dbTrack::OWNER{$result} = 1; 
    my %resulthash;
    tie %resulthash, ref($result), $result;
    return bless \%resulthash, ref($result);
}
*getNumHorizTracks = *UCLAscriptc::dbContext_getNumHorizTracks;
*getNumVertTracks = *UCLAscriptc::dbContext_getNumVertTracks;
*beginGCellGrids = *UCLAscriptc::dbContext_beginGCellGrids;
*endGCellGrids = *UCLAscriptc::dbContext_endGCellGrids;
*getGCellGrids = *UCLAscriptc::dbContext_getGCellGrids;
*addGCellGrid = *UCLAscriptc::dbContext_addGCellGrid;
*isConsistent = *UCLAscriptc::dbContext_isConsistent;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
    };

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
    };


############# Class : dbLayerGeom ##############

package dbLayerGeom;
@ISA = qw( UCLAscript );
%OWNER = ();
sub new {
    my $self = shift;
    my @args = @_;
    $args[1] = tied(%{$args[1]});
    $self = UCLAscriptc::new_dbLayerGeom(@args);
    return undef if (!defined($self));
    bless $self, "dbLayerGeom";
    $OWNER{$self} = 1;
    my %retval;
    tie %retval, "dbLayerGeom", $self;
    return bless \%retval,"dbLayerGeom";
}

*getPolygon = *UCLAscriptc::dbLayerGeom_getPolygon;
*isVia = *UCLAscriptc::dbLayerGeom_isVia;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
    };

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
    };


############# Class : dbSite ##############

package dbSite;
@ISA = qw( UCLAscript );
%OWNER = ();
%ITERATORS = ();
*PAD = *UCLAscriptc::dbSite_PAD;
*CORE = *UCLAscriptc::dbSite_CORE;
sub new {
    my $self = shift;
    my @args = @_;
    $args[2] = tied(%{$args[2]});
    $self = UCLAscriptc::new_dbSite(@args);
    return undef if (!defined($self));
    bless $self, "dbSite";
    $OWNER{$self} = 1;
    my %retval;
    tie %retval, "dbSite", $self;
    return bless \%retval,"dbSite";
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        UCLAscriptc::delete_dbSite($self);
        delete $OWNER{$self};
    }
}

*getName = *UCLAscriptc::dbSite_getName;
*getType = *UCLAscriptc::dbSite_getType;
sub getSymmetry {
    my @args = @_;
    my $result = UCLAscriptc::dbSite_getSymmetry(@args);
    return undef if (!defined($result));
    $Symmetry::OWNER{$result} = 1; 
    my %resulthash;
    tie %resulthash, ref($result), $result;
    return bless \%resulthash, ref($result);
}
*getHeight = *UCLAscriptc::dbSite_getHeight;
*getWidth = *UCLAscriptc::dbSite_getWidth;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
    };

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
    };


############# Class : dbLayer ##############

package dbLayer;
@ISA = qw( UCLAscript );
%OWNER = ();
%ITERATORS = ();
*MASTERSLICE = *UCLAscriptc::dbLayer_MASTERSLICE;
*CUT = *UCLAscriptc::dbLayer_CUT;
*OVERLAP = *UCLAscriptc::dbLayer_OVERLAP;
*ROUTING = *UCLAscriptc::dbLayer_ROUTING;
*HORIZ = *UCLAscriptc::dbLayer_HORIZ;
*VERT = *UCLAscriptc::dbLayer_VERT;
*NOPREFERRED = *UCLAscriptc::dbLayer_NOPREFERRED;
sub new {
    my $self = shift;
    my @args = @_;
    $self = UCLAscriptc::new_dbLayer(@args);
    return undef if (!defined($self));
    bless $self, "dbLayer";
    $OWNER{$self} = 1;
    my %retval;
    tie %retval, "dbLayer", $self;
    return bless \%retval,"dbLayer";
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        UCLAscriptc::delete_dbLayer($self);
        delete $OWNER{$self};
    }
}

*getName = *UCLAscriptc::dbLayer_getName;
*getType = *UCLAscriptc::dbLayer_getType;
*getDirection = *UCLAscriptc::dbLayer_getDirection;
*getPitch = *UCLAscriptc::dbLayer_getPitch;
*getHeight = *UCLAscriptc::dbLayer_getHeight;
*getThickness = *UCLAscriptc::dbLayer_getThickness;
*getShrinkage = *UCLAscriptc::dbLayer_getShrinkage;
*getCapMult = *UCLAscriptc::dbLayer_getCapMult;
*getEdgeCap = *UCLAscriptc::dbLayer_getEdgeCap;
*getWidth = *UCLAscriptc::dbLayer_getWidth;
*getSpacing = *UCLAscriptc::dbLayer_getSpacing;
*getUnitRes = *UCLAscriptc::dbLayer_getUnitRes;
*getUnitCap = *UCLAscriptc::dbLayer_getUnitCap;
*getNumTracks = *UCLAscriptc::dbLayer_getNumTracks;
*getIndex = *UCLAscriptc::dbLayer_getIndex;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
    };

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
    };


############# Class : dbRow ##############

package dbRow;
@ISA = qw( UCLAscript );
%OWNER = ();
%ITERATORS = ();
*HORIZ = *UCLAscriptc::dbRow_HORIZ;
*VERT = *UCLAscriptc::dbRow_VERT;
sub new {
    my $self = shift;
    my @args = @_;
    $args[0] = tied(%{$args[0]});
    $args[6] = tied(%{$args[6]});
    $self = UCLAscriptc::new_dbRow(@args);
    return undef if (!defined($self));
    bless $self, "dbRow";
    $OWNER{$self} = 1;
    my %retval;
    tie %retval, "dbRow", $self;
    return bless \%retval,"dbRow";
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        UCLAscriptc::delete_dbRow($self);
        delete $OWNER{$self};
    }
}

sub getSite {
    my @args = @_;
    my $result = UCLAscriptc::dbRow_getSite(@args);
    return undef if (!defined($result));
    $dbSite::OWNER{$result} = 1; 
    my %resulthash;
    tie %resulthash, ref($result), $result;
    return bless \%resulthash, ref($result);
}
*getOrigin = *UCLAscriptc::dbRow_getOrigin;
*getDirection = *UCLAscriptc::dbRow_getDirection;
*getSpacing = *UCLAscriptc::dbRow_getSpacing;
sub getOrientation {
    my @args = @_;
    my $result = UCLAscriptc::dbRow_getOrientation(@args);
    return undef if (!defined($result));
    $Orient::OWNER{$result} = 1; 
    my %resulthash;
    tie %resulthash, ref($result), $result;
    return bless \%resulthash, ref($result);
}
*getNumSites = *UCLAscriptc::dbRow_getNumSites;
*getName = *UCLAscriptc::dbRow_getName;
*getLength = *UCLAscriptc::dbRow_getLength;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
    };

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
    };


############# Class : dbTrack ##############

package dbTrack;
@ISA = qw( UCLAscript );
%OWNER = ();
%BLESSEDMEMBERS = (
    layer => 'dbLayer',
);

%ITERATORS = ();
sub new {
    my $self = shift;
    my @args = @_;
    $args[0] = tied(%{$args[0]});
    $self = UCLAscriptc::new_dbTrack(@args);
    return undef if (!defined($self));
    bless $self, "dbTrack";
    $OWNER{$self} = 1;
    my %retval;
    tie %retval, "dbTrack", $self;
    return bless \%retval,"dbTrack";
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
    };

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
    };

sub FETCH {
    my ($self,$field) = @_;
    my $member_func = "UCLAscriptc::dbTrack_${field}_get";
    my $val = &$member_func($self);
    if (exists $BLESSEDMEMBERS{$field}) {
        return undef if (!defined($val));
        my %retval;
        tie %retval,$BLESSEDMEMBERS{$field},$val;
        return bless \%retval, $BLESSEDMEMBERS{$field};
    }
    return $val;
}

sub STORE {
    my ($self,$field,$newval) = @_;
    my $member_func = "UCLAscriptc::dbTrack_${field}_set";
    if (exists $BLESSEDMEMBERS{$field}) {
        &$member_func($self,tied(%{$newval}));
    } else {
        &$member_func($self,$newval);
    }
}

sub FIRSTKEY {
    my $self = shift;
    $ITERATORS{$self} = ['layer', 'horizontal', 'start', 'numTracks', 'spacing', ];
    my $first = shift @{$ITERATORS{$self}};
    return $first;
}

sub NEXTKEY {
    my $self = shift;
    $nelem = scalar @{$ITERATORS{$self}};
    if ($nelem > 0) {
        my $member = shift @{$ITERATORS{$self}};
        return $member;
    } else {
        $ITERATORS{$self} = ['layer', 'horizontal', 'start', 'numTracks', 'spacing', ];
        return ();
    }
}


############# Class : dbGCellGrid ##############

package dbGCellGrid;
@ISA = qw( UCLAscript );
%OWNER = ();
%BLESSEDMEMBERS = (
);

%ITERATORS = ();
sub new {
    my $self = shift;
    my @args = @_;
    $self = UCLAscriptc::new_dbGCellGrid(@args);
    return undef if (!defined($self));
    bless $self, "dbGCellGrid";
    $OWNER{$self} = 1;
    my %retval;
    tie %retval, "dbGCellGrid", $self;
    return bless \%retval,"dbGCellGrid";
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
    };

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
    };

sub FETCH {
    my ($self,$field) = @_;
    my $member_func = "UCLAscriptc::dbGCellGrid_${field}_get";
    my $val = &$member_func($self);
    if (exists $BLESSEDMEMBERS{$field}) {
        return undef if (!defined($val));
        my %retval;
        tie %retval,$BLESSEDMEMBERS{$field},$val;
        return bless \%retval, $BLESSEDMEMBERS{$field};
    }
    return $val;
}

sub STORE {
    my ($self,$field,$newval) = @_;
    my $member_func = "UCLAscriptc::dbGCellGrid_${field}_set";
    if (exists $BLESSEDMEMBERS{$field}) {
        &$member_func($self,tied(%{$newval}));
    } else {
        &$member_func($self,$newval);
    }
}

sub FIRSTKEY {
    my $self = shift;
    $ITERATORS{$self} = ['horizontal', 'start', 'numDivisions', 'spacing', ];
    my $first = shift @{$ITERATORS{$self}};
    return $first;
}

sub NEXTKEY {
    my $self = shift;
    $nelem = scalar @{$ITERATORS{$self}};
    if ($nelem > 0) {
        my $member = shift @{$ITERATORS{$self}};
        return $member;
    } else {
        $ITERATORS{$self} = ['horizontal', 'start', 'numDivisions', 'spacing', ];
        return ();
    }
}


############# Class : dbMasterCell ##############

package dbMasterCell;
@ISA = qw( UCLAscript );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $self = shift;
    my @args = @_;
    $args[7] = tied(%{$args[7]});
    $args[8] = tied(%{$args[8]});
    $self = UCLAscriptc::new_dbMasterCell(@args);
    return undef if (!defined($self));
    bless $self, "dbMasterCell";
    $OWNER{$self} = 1;
    my %retval;
    tie %retval, "dbMasterCell", $self;
    return bless \%retval,"dbMasterCell";
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        UCLAscriptc::delete_dbMasterCell($self);
        delete $OWNER{$self};
    }
}

*pinsBegin = *UCLAscriptc::dbMasterCell_pinsBegin;
*pinsEnd = *UCLAscriptc::dbMasterCell_pinsEnd;
*getNumPins = *UCLAscriptc::dbMasterCell_getNumPins;
*getName = *UCLAscriptc::dbMasterCell_getName;
*getHeight = *UCLAscriptc::dbMasterCell_getHeight;
*getWidth = *UCLAscriptc::dbMasterCell_getWidth;
*getIndegree = *UCLAscriptc::dbMasterCell_getIndegree;
*getOutdegree = *UCLAscriptc::dbMasterCell_getOutdegree;
sub getType {
    my @args = @_;
    my $result = UCLAscriptc::dbMasterCell_getType(@args);
    return undef if (!defined($result));
    $dbMasterCellType::OWNER{$result} = 1; 
    my %resulthash;
    tie %resulthash, ref($result), $result;
    return bless \%resulthash, ref($result);
}
*getObstacles = *UCLAscriptc::dbMasterCell_getObstacles;
sub getSymmetry {
    my @args = @_;
    my $result = UCLAscriptc::dbMasterCell_getSymmetry(@args);
    return undef if (!defined($result));
    $Symmetry::OWNER{$result} = 1; 
    my %resulthash;
    tie %resulthash, ref($result), $result;
    return bless \%resulthash, ref($result);
}
sub getSite {
    my @args = @_;
    my $result = UCLAscriptc::dbMasterCell_getSite(@args);
    return undef if (!defined($result));
    $dbSite::OWNER{$result} = 1; 
    my %resulthash;
    tie %resulthash, ref($result), $result;
    return bless \%resulthash, ref($result);
}
*isCover = *UCLAscriptc::dbMasterCell_isCover;
*isRing = *UCLAscriptc::dbMasterCell_isRing;
*isBlock = *UCLAscriptc::dbMasterCell_isBlock;
*isCore = *UCLAscriptc::dbMasterCell_isCore;
*isPad = *UCLAscriptc::dbMasterCell_isPad;
*isEndCap = *UCLAscriptc::dbMasterCell_isEndCap;
*isExtPin = *UCLAscriptc::dbMasterCell_isExtPin;
*isUnknown = *UCLAscriptc::dbMasterCell_isUnknown;
*isFlipFlop = *UCLAscriptc::dbMasterCell_isFlipFlop;
*isLatch = *UCLAscriptc::dbMasterCell_isLatch;
*isInverter = *UCLAscriptc::dbMasterCell_isInverter;
*isBuffer = *UCLAscriptc::dbMasterCell_isBuffer;
*isNAND = *UCLAscriptc::dbMasterCell_isNAND;
*isNOR = *UCLAscriptc::dbMasterCell_isNOR;
*isCoreUnknown = *UCLAscriptc::dbMasterCell_isCoreUnknown;
*isPI = *UCLAscriptc::dbMasterCell_isPI;
*isPO = *UCLAscriptc::dbMasterCell_isPO;
*isPIO = *UCLAscriptc::dbMasterCell_isPIO;
*isPPower = *UCLAscriptc::dbMasterCell_isPPower;
*isPSpacer = *UCLAscriptc::dbMasterCell_isPSpacer;
*isPUnknown = *UCLAscriptc::dbMasterCell_isPUnknown;
*getRiseDelay = *UCLAscriptc::dbMasterCell_getRiseDelay;
*getFallDelay = *UCLAscriptc::dbMasterCell_getFallDelay;
*reOrientRec = *UCLAscriptc::dbMasterCell_reOrientRec;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
    };

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
    };


############# Class : dbCell ##############

package dbCell;
@ISA = qw( UCLAscript );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $self = shift;
    my @args = @_;
    $args[2] = tied(%{$args[2]});
    $self = UCLAscriptc::new_dbCell(@args);
    return undef if (!defined($self));
    bless $self, "dbCell";
    $OWNER{$self} = 1;
    my %retval;
    tie %retval, "dbCell", $self;
    return bless \%retval,"dbCell";
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        UCLAscriptc::delete_dbCell($self);
        delete $OWNER{$self};
    }
}

*pinsBegin = *UCLAscriptc::dbCell_pinsBegin;
*pinsEnd = *UCLAscriptc::dbCell_pinsEnd;
*netsBegin = *UCLAscriptc::dbCell_netsBegin;
*netsEnd = *UCLAscriptc::dbCell_netsEnd;
*loopPinsBegin = *UCLAscriptc::dbCell_loopPinsBegin;
*loopPinsEnd = *UCLAscriptc::dbCell_loopPinsEnd;
*loopNetsBegin = *UCLAscriptc::dbCell_loopNetsBegin;
*loopNetsEnd = *UCLAscriptc::dbCell_loopNetsEnd;
sub getMaster {
    my @args = @_;
    my $result = UCLAscriptc::dbCell_getMaster(@args);
    return undef if (!defined($result));
    $dbMasterCell::OWNER{$result} = 1; 
    my %resulthash;
    tie %resulthash, ref($result), $result;
    return bless \%resulthash, ref($result);
}
*getIndex = *UCLAscriptc::dbCell_getIndex;
*getName = *UCLAscriptc::dbCell_getName;
sub getType {
    my @args = @_;
    my $result = UCLAscriptc::dbCell_getType(@args);
    return undef if (!defined($result));
    $dbCellType::OWNER{$result} = 1; 
    my %resulthash;
    tie %resulthash, ref($result), $result;
    return bless \%resulthash, ref($result);
}
*getHeight = *UCLAscriptc::dbCell_getHeight;
*getWidth = *UCLAscriptc::dbCell_getWidth;
*getIndegree = *UCLAscriptc::dbCell_getIndegree;
*getOutdegree = *UCLAscriptc::dbCell_getOutdegree;
*getNumNets = *UCLAscriptc::dbCell_getNumNets;
*getNumPins = *UCLAscriptc::dbCell_getNumPins;
*isIO = *UCLAscriptc::dbCell_isIO;
*isBlock = *UCLAscriptc::dbCell_isBlock;
*isCore = *UCLAscriptc::dbCell_isCore;
*isOther = *UCLAscriptc::dbCell_isOther;
*isUnknown = *UCLAscriptc::dbCell_isUnknown;
*isPI = *UCLAscriptc::dbCell_isPI;
*isPO = *UCLAscriptc::dbCell_isPO;
*isPIO = *UCLAscriptc::dbCell_isPIO;
*isPOther = *UCLAscriptc::dbCell_isPOther;
*isPUnknown = *UCLAscriptc::dbCell_isPUnknown;
*isCC = *UCLAscriptc::dbCell_isCC;
*isSC = *UCLAscriptc::dbCell_isSC;
*isCoreOther = *UCLAscriptc::dbCell_isCoreOther;
*isTimingNode = *UCLAscriptc::dbCell_isTimingNode;
*isLatchNode = *UCLAscriptc::dbCell_isLatchNode;
*isIgnoredTimingNode = *UCLAscriptc::dbCell_isIgnoredTimingNode;
*getRiseDelay = *UCLAscriptc::dbCell_getRiseDelay;
*getFallDelay = *UCLAscriptc::dbCell_getFallDelay;
sub commonPin {
    my @args = @_;
    my $result = UCLAscriptc::dbCell_commonPin(@args);
    return undef if (!defined($result));
    my %resulthash;
    tie %resulthash, ref($result), $result;
    return bless \%resulthash, ref($result);
}
*commonPinIsCellInput = *UCLAscriptc::dbCell_commonPinIsCellInput;
*commonPinIsCellOutput = *UCLAscriptc::dbCell_commonPinIsCellOutput;
*isInputPad = *UCLAscriptc::dbCell_isInputPad;
*isOutputPad = *UCLAscriptc::dbCell_isOutputPad;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
    };

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
    };


############# Class : CompareCellsByName ##############

package CompareCellsByName;
@ISA = qw( UCLAscript );
%OWNER = ();
sub new {
    my $self = shift;
    my @args = @_;
    $self = UCLAscriptc::new_CompareCellsByName(@args);
    return undef if (!defined($self));
    bless $self, "CompareCellsByName";
    $OWNER{$self} = 1;
    my %retval;
    tie %retval, "CompareCellsByName", $self;
    return bless \%retval,"CompareCellsByName";
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
    };

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
    };


############# Class : CompareCellsByStatus ##############

package CompareCellsByStatus;
@ISA = qw( UCLAscript );
%OWNER = ();
sub new {
    my $self = shift;
    my @args = @_;
    $self = UCLAscriptc::new_CompareCellsByStatus(@args);
    return undef if (!defined($self));
    bless $self, "CompareCellsByStatus";
    $OWNER{$self} = 1;
    my %retval;
    tie %retval, "CompareCellsByStatus", $self;
    return bless \%retval,"CompareCellsByStatus";
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
    };

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
    };


############# Class : CompareMCsByName ##############

package CompareMCsByName;
@ISA = qw( UCLAscript );
%OWNER = ();
sub new {
    my $self = shift;
    my @args = @_;
    $self = UCLAscriptc::new_CompareMCsByName(@args);
    return undef if (!defined($self));
    bless $self, "CompareMCsByName";
    $OWNER{$self} = 1;
    my %retval;
    tie %retval, "CompareMCsByName", $self;
    return bless \%retval,"CompareMCsByName";
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
    };

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
    };


############# Class : CompareCellsByCellIndex ##############

package CompareCellsByCellIndex;
@ISA = qw( UCLAscript );
%OWNER = ();
sub new {
    my $self = shift;
    my @args = @_;
    $self = UCLAscriptc::new_CompareCellsByCellIndex(@args);
    return undef if (!defined($self));
    bless $self, "CompareCellsByCellIndex";
    $OWNER{$self} = 1;
    my %retval;
    tie %retval, "CompareCellsByCellIndex", $self;
    return bless \%retval,"CompareCellsByCellIndex";
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
    };

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
    };


############# Class : CompareCellsByDir ##############

package CompareCellsByDir;
@ISA = qw( UCLAscript );
%OWNER = ();
sub new {
    my $self = shift;
    my @args = @_;
    $args[0] = tied(%{$args[0]});
    $self = UCLAscriptc::new_CompareCellsByDir(@args);
    return undef if (!defined($self));
    bless $self, "CompareCellsByDir";
    $OWNER{$self} = 1;
    my %retval;
    tie %retval, "CompareCellsByDir", $self;
    return bless \%retval,"CompareCellsByDir";
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
    };

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
    };


############# Class : CompareObstaclesByXmin ##############

package CompareObstaclesByXmin;
@ISA = qw( UCLAscript );
%OWNER = ();
sub new {
    my $self = shift;
    my @args = @_;
    $self = UCLAscriptc::new_CompareObstaclesByXmin(@args);
    return undef if (!defined($self));
    bless $self, "CompareObstaclesByXmin";
    $OWNER{$self} = 1;
    my %retval;
    tie %retval, "CompareObstaclesByXmin", $self;
    return bless \%retval,"CompareObstaclesByXmin";
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
    };

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
    };


############# Class : dbMasterPin ##############

package dbMasterPin;
@ISA = qw( UCLAscript );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $self = shift;
    my @args = @_;
    $self = UCLAscriptc::new_dbMasterPin(@args);
    return undef if (!defined($self));
    bless $self, "dbMasterPin";
    $OWNER{$self} = 1;
    my %retval;
    tie %retval, "dbMasterPin", $self;
    return bless \%retval,"dbMasterPin";
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        UCLAscriptc::delete_dbMasterPin($self);
        delete $OWNER{$self};
    }
}

*setMasterCell = *UCLAscriptc::dbMasterPin_setMasterCell;
sub getCell {
    my @args = @_;
    my $result = UCLAscriptc::dbMasterPin_getCell(@args);
    return undef if (!defined($result));
    $dbMasterCell::OWNER{$result} = 1; 
    my %resulthash;
    tie %resulthash, ref($result), $result;
    return bless \%resulthash, ref($result);
}
*getName = *UCLAscriptc::dbMasterPin_getName;
*getCenter = *UCLAscriptc::dbMasterPin_getCenter;
*getBBox = *UCLAscriptc::dbMasterPin_getBBox;
*getPorts = *UCLAscriptc::dbMasterPin_getPorts;
*getType = *UCLAscriptc::dbMasterPin_getType;
*getRiseDelay = *UCLAscriptc::dbMasterPin_getRiseDelay;
*getFallDelay = *UCLAscriptc::dbMasterPin_getFallDelay;
*getRiseResist = *UCLAscriptc::dbMasterPin_getRiseResist;
*getFallResist = *UCLAscriptc::dbMasterPin_getFallResist;
*getInputCap = *UCLAscriptc::dbMasterPin_getInputCap;
*isShapeAbutment = *UCLAscriptc::dbMasterPin_isShapeAbutment;
*isShapeFeedthrough = *UCLAscriptc::dbMasterPin_isShapeFeedthrough;
*isShapeRing = *UCLAscriptc::dbMasterPin_isShapeRing;
*isShapeUnknown = *UCLAscriptc::dbMasterPin_isShapeUnknown;
*isUseSignal = *UCLAscriptc::dbMasterPin_isUseSignal;
*isUseAnalog = *UCLAscriptc::dbMasterPin_isUseAnalog;
*isUsePower = *UCLAscriptc::dbMasterPin_isUsePower;
*isUseGround = *UCLAscriptc::dbMasterPin_isUseGround;
*isUseClock = *UCLAscriptc::dbMasterPin_isUseClock;
*isUseUnknown = *UCLAscriptc::dbMasterPin_isUseUnknown;
*isDirOutput = *UCLAscriptc::dbMasterPin_isDirOutput;
*isDirInput = *UCLAscriptc::dbMasterPin_isDirInput;
*isDirInOut = *UCLAscriptc::dbMasterPin_isDirInOut;
*isDirOutputTristate = *UCLAscriptc::dbMasterPin_isDirOutputTristate;
*isDirFeedthrough = *UCLAscriptc::dbMasterPin_isDirFeedthrough;
*isDirUnknown = *UCLAscriptc::dbMasterPin_isDirUnknown;
*isJoint = *UCLAscriptc::dbMasterPin_isJoint;
*getJointPins = *UCLAscriptc::dbMasterPin_getJointPins;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
    };

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
    };


############# Class : dbPin ##############

package dbPin;
@ISA = qw( UCLAscript );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $self = shift;
    my @args = @_;
    $args[0] = tied(%{$args[0]});
    $self = UCLAscriptc::new_dbPin(@args);
    return undef if (!defined($self));
    bless $self, "dbPin";
    $OWNER{$self} = 1;
    my %retval;
    tie %retval, "dbPin", $self;
    return bless \%retval,"dbPin";
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        UCLAscriptc::delete_dbPin($self);
        delete $OWNER{$self};
    }
}

*setCell = *UCLAscriptc::dbPin_setCell;
*setNet = *UCLAscriptc::dbPin_setNet;
*getMasterPinName = *UCLAscriptc::dbPin_getMasterPinName;
sub getCell {
    my @args = @_;
    my $result = UCLAscriptc::dbPin_getCell(@args);
    return undef if (!defined($result));
    $dbCell::OWNER{$result} = 1; 
    my %resulthash;
    tie %resulthash, ref($result), $result;
    return bless \%resulthash, ref($result);
}
sub getNet {
    my @args = @_;
    my $result = UCLAscriptc::dbPin_getNet(@args);
    return undef if (!defined($result));
    $dbNet::OWNER{$result} = 1; 
    my %resulthash;
    tie %resulthash, ref($result), $result;
    return bless \%resulthash, ref($result);
}
*getIndex = *UCLAscriptc::dbPin_getIndex;
sub getMaster {
    my @args = @_;
    my $result = UCLAscriptc::dbPin_getMaster(@args);
    return undef if (!defined($result));
    $dbMasterPin::OWNER{$result} = 1; 
    my %resulthash;
    tie %resulthash, ref($result), $result;
    return bless \%resulthash, ref($result);
}
*getType = *UCLAscriptc::dbPin_getType;
*getRiseDelay = *UCLAscriptc::dbPin_getRiseDelay;
*getFallDelay = *UCLAscriptc::dbPin_getFallDelay;
*getRiseResist = *UCLAscriptc::dbPin_getRiseResist;
*getFallResist = *UCLAscriptc::dbPin_getFallResist;
*getInputCap = *UCLAscriptc::dbPin_getInputCap;
*isShapeAbutment = *UCLAscriptc::dbPin_isShapeAbutment;
*isShapeFeedthrough = *UCLAscriptc::dbPin_isShapeFeedthrough;
*isShapeRing = *UCLAscriptc::dbPin_isShapeRing;
*isShapeUnknown = *UCLAscriptc::dbPin_isShapeUnknown;
*isUseSignal = *UCLAscriptc::dbPin_isUseSignal;
*isUseAnalog = *UCLAscriptc::dbPin_isUseAnalog;
*isUsePower = *UCLAscriptc::dbPin_isUsePower;
*isUseGround = *UCLAscriptc::dbPin_isUseGround;
*isUseClock = *UCLAscriptc::dbPin_isUseClock;
*isUseUnknown = *UCLAscriptc::dbPin_isUseUnknown;
*isDirOutput = *UCLAscriptc::dbPin_isDirOutput;
*isDirInput = *UCLAscriptc::dbPin_isDirInput;
*isDirInOut = *UCLAscriptc::dbPin_isDirInOut;
*isDirOutputTristate = *UCLAscriptc::dbPin_isDirOutputTristate;
*isDirFeedthrough = *UCLAscriptc::dbPin_isDirFeedthrough;
*isDirUnknown = *UCLAscriptc::dbPin_isDirUnknown;
*isConnected = *UCLAscriptc::dbPin_isConnected;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
    };

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
    };


############# Class : ComparePinsByDirAndName ##############

package ComparePinsByDirAndName;
@ISA = qw( UCLAscript );
%OWNER = ();
sub new {
    my $self = shift;
    my @args = @_;
    $self = UCLAscriptc::new_ComparePinsByDirAndName(@args);
    return undef if (!defined($self));
    bless $self, "ComparePinsByDirAndName";
    $OWNER{$self} = 1;
    my %retval;
    tie %retval, "ComparePinsByDirAndName", $self;
    return bless \%retval,"ComparePinsByDirAndName";
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
    };

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
    };


############# Class : ComparePinsByCellIndexAndDir ##############

package ComparePinsByCellIndexAndDir;
@ISA = qw( UCLAscript );
%OWNER = ();
sub new {
    my $self = shift;
    my @args = @_;
    $self = UCLAscriptc::new_ComparePinsByCellIndexAndDir(@args);
    return undef if (!defined($self));
    bless $self, "ComparePinsByCellIndexAndDir";
    $OWNER{$self} = 1;
    my %retval;
    tie %retval, "ComparePinsByCellIndexAndDir", $self;
    return bless \%retval,"ComparePinsByCellIndexAndDir";
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
    };

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
    };


############# Class : dbNet ##############

package dbNet;
@ISA = qw( UCLAscript );
%OWNER = ();
%BLESSEDMEMBERS = (
);

%ITERATORS = ();
sub new {
    my $self = shift;
    my @args = @_;
    $args[2] = tied(%{$args[2]});
    $self = UCLAscriptc::new_dbNet(@args);
    return undef if (!defined($self));
    bless $self, "dbNet";
    $OWNER{$self} = 1;
    my %retval;
    tie %retval, "dbNet", $self;
    return bless \%retval,"dbNet";
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        UCLAscriptc::delete_dbNet($self);
        delete $OWNER{$self};
    }
}

*getNumCells = *UCLAscriptc::dbNet_getNumCells;
*getNumPins = *UCLAscriptc::dbNet_getNumPins;
*getDegree = *UCLAscriptc::dbNet_getDegree;
*getIndex = *UCLAscriptc::dbNet_getIndex;
sub getType {
    my @args = @_;
    my $result = UCLAscriptc::dbNet_getType(@args);
    return undef if (!defined($result));
    $dbNetType::OWNER{$result} = 1; 
    my %resulthash;
    tie %resulthash, ref($result), $result;
    return bless \%resulthash, ref($result);
}
*getName = *UCLAscriptc::dbNet_getName;
*getNumOut = *UCLAscriptc::dbNet_getNumOut;
*getNumInOut = *UCLAscriptc::dbNet_getNumInOut;
*getNumIn = *UCLAscriptc::dbNet_getNumIn;
*hasLogicalPin = *UCLAscriptc::dbNet_hasLogicalPin;
*cellsBegin = *UCLAscriptc::dbNet_cellsBegin;
*cellsEnd = *UCLAscriptc::dbNet_cellsEnd;
*sourcesBegin = *UCLAscriptc::dbNet_sourcesBegin;
*sourcesEnd = *UCLAscriptc::dbNet_sourcesEnd;
*sourceSinksBegin = *UCLAscriptc::dbNet_sourceSinksBegin;
*sourceSinksEnd = *UCLAscriptc::dbNet_sourceSinksEnd;
*sinksBegin = *UCLAscriptc::dbNet_sinksBegin;
*sinksEnd = *UCLAscriptc::dbNet_sinksEnd;
sub getCellByIdx {
    my @args = @_;
    my $result = UCLAscriptc::dbNet_getCellByIdx(@args);
    return undef if (!defined($result));
    $dbCell::OWNER{$result} = 1; 
    my %resulthash;
    tie %resulthash, ref($result), $result;
    return bless \%resulthash, ref($result);
}
*pinsBegin = *UCLAscriptc::dbNet_pinsBegin;
*pinsEnd = *UCLAscriptc::dbNet_pinsEnd;
sub getPinByIdx {
    my @args = @_;
    my $result = UCLAscriptc::dbNet_getPinByIdx(@args);
    return undef if (!defined($result));
    $dbPin::OWNER{$result} = 1; 
    my %resulthash;
    tie %resulthash, ref($result), $result;
    return bless \%resulthash, ref($result);
}
*wiringBegin = *UCLAscriptc::dbNet_wiringBegin;
*wiringEnd = *UCLAscriptc::dbNet_wiringEnd;
sub getWiringLayerGeom {
    my @args = @_;
    my $result = UCLAscriptc::dbNet_getWiringLayerGeom(@args);
    return undef if (!defined($result));
    $dbLayerGeom::OWNER{$result} = 1; 
    my %resulthash;
    tie %resulthash, ref($result), $result;
    return bless \%resulthash, ref($result);
}
*getNumWiringLayerGeoms = *UCLAscriptc::dbNet_getNumWiringLayerGeoms;
*loopCellsBegin = *UCLAscriptc::dbNet_loopCellsBegin;
*loopCellsEnd = *UCLAscriptc::dbNet_loopCellsEnd;
*loopPinsBegin = *UCLAscriptc::dbNet_loopPinsBegin;
*loopPinsEnd = *UCLAscriptc::dbNet_loopPinsEnd;
sub commonPin {
    my @args = @_;
    my $result = UCLAscriptc::dbNet_commonPin(@args);
    return undef if (!defined($result));
    my %resulthash;
    tie %resulthash, ref($result), $result;
    return bless \%resulthash, ref($result);
}
*commonPinIsCellInput = *UCLAscriptc::dbNet_commonPinIsCellInput;
*commonPinIsCellOutput = *UCLAscriptc::dbNet_commonPinIsCellOutput;
*getInputCap = *UCLAscriptc::dbNet_getInputCap;
*getDriverResist = *UCLAscriptc::dbNet_getDriverResist;
*isSpecial = *UCLAscriptc::dbNet_isSpecial;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
    };

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
    };

sub FETCH {
    my ($self,$field) = @_;
    my $member_func = "UCLAscriptc::dbNet_${field}_get";
    my $val = &$member_func($self);
    if (exists $BLESSEDMEMBERS{$field}) {
        return undef if (!defined($val));
        my %retval;
        tie %retval,$BLESSEDMEMBERS{$field},$val;
        return bless \%retval, $BLESSEDMEMBERS{$field};
    }
    return $val;
}

sub STORE {
    my ($self,$field,$newval) = @_;
    my $member_func = "UCLAscriptc::dbNet_${field}_set";
    if (exists $BLESSEDMEMBERS{$field}) {
        &$member_func($self,tied(%{$newval}));
    } else {
        &$member_func($self,$newval);
    }
}

sub FIRSTKEY {
    my $self = shift;
    $ITERATORS{$self} = ['_cells', '_pins', '_wiring', '_numOut', '_numInOut', '_hasLogicalPin', ];
    my $first = shift @{$ITERATORS{$self}};
    return $first;
}

sub NEXTKEY {
    my $self = shift;
    $nelem = scalar @{$ITERATORS{$self}};
    if ($nelem > 0) {
        my $member = shift @{$ITERATORS{$self}};
        return $member;
    } else {
        $ITERATORS{$self} = ['_cells', '_pins', '_wiring', '_numOut', '_numInOut', '_hasLogicalPin', ];
        return ();
    }
}


############# Class : CompareNetsByCellIndex ##############

package CompareNetsByCellIndex;
@ISA = qw( UCLAscript );
%OWNER = ();
sub new {
    my $self = shift;
    my @args = @_;
    $self = UCLAscriptc::new_CompareNetsByCellIndex(@args);
    return undef if (!defined($self));
    bless $self, "CompareNetsByCellIndex";
    $OWNER{$self} = 1;
    my %retval;
    tie %retval, "CompareNetsByCellIndex", $self;
    return bless \%retval,"CompareNetsByCellIndex";
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
    };

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
    };


############# Class : CompareNetsByDegree ##############

package CompareNetsByDegree;
@ISA = qw( UCLAscript );
%OWNER = ();
sub new {
    my $self = shift;
    my @args = @_;
    $self = UCLAscriptc::new_CompareNetsByDegree(@args);
    return undef if (!defined($self));
    bless $self, "CompareNetsByDegree";
    $OWNER{$self} = 1;
    my %retval;
    tie %retval, "CompareNetsByDegree", $self;
    return bless \%retval,"CompareNetsByDegree";
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
    };

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
    };


############# Class : CompareNetsByName ##############

package CompareNetsByName;
@ISA = qw( UCLAscript );
%OWNER = ();
sub new {
    my $self = shift;
    my @args = @_;
    $self = UCLAscriptc::new_CompareNetsByName(@args);
    return undef if (!defined($self));
    bless $self, "CompareNetsByName";
    $OWNER{$self} = 1;
    my %retval;
    tie %retval, "CompareNetsByName", $self;
    return bless \%retval,"CompareNetsByName";
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
    };

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
    };


############# Class : CompareNetsByDirection ##############

package CompareNetsByDirection;
@ISA = qw( UCLAscript );
%OWNER = ();
sub new {
    my $self = shift;
    my @args = @_;
    $args[0] = tied(%{$args[0]});
    $self = UCLAscriptc::new_CompareNetsByDirection(@args);
    return undef if (!defined($self));
    bless $self, "CompareNetsByDirection";
    $OWNER{$self} = 1;
    my %retval;
    tie %retval, "CompareNetsByDirection", $self;
    return bless \%retval,"CompareNetsByDirection";
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
    };

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
    };


############# Class : dbNetlist ##############

package dbNetlist;
@ISA = qw( UCLAscript );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $self = shift;
    my @args = @_;
    $self = UCLAscriptc::new_dbNetlist(@args);
    return undef if (!defined($self));
    bless $self, "dbNetlist";
    $OWNER{$self} = 1;
    my %retval;
    tie %retval, "dbNetlist", $self;
    return bless \%retval,"dbNetlist";
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        UCLAscriptc::delete_dbNetlist($self);
        delete $OWNER{$self};
    }
}

*getCellLEQClass = *UCLAscriptc::dbNetlist_getCellLEQClass;
*getCellEEQClass = *UCLAscriptc::dbNetlist_getCellEEQClass;
*getPinLEQClass = *UCLAscriptc::dbNetlist_getPinLEQClass;
*isConsistent = *UCLAscriptc::dbNetlist_isConsistent;
*getNumCells = *UCLAscriptc::dbNetlist_getNumCells;
*getNumPins = *UCLAscriptc::dbNetlist_getNumPins;
*getNumNets = *UCLAscriptc::dbNetlist_getNumNets;
*getNumSNets = *UCLAscriptc::dbNetlist_getNumSNets;
*getNumMasterCells = *UCLAscriptc::dbNetlist_getNumMasterCells;
*getNumMasterPins = *UCLAscriptc::dbNetlist_getNumMasterPins;
*getNumCCs = *UCLAscriptc::dbNetlist_getNumCCs;
*getNumSCs = *UCLAscriptc::dbNetlist_getNumSCs;
*getNumIOPads = *UCLAscriptc::dbNetlist_getNumIOPads;
*getNumAllPads = *UCLAscriptc::dbNetlist_getNumAllPads;
*getNumIOPins = *UCLAscriptc::dbNetlist_getNumIOPins;
*getNumCoreCells = *UCLAscriptc::dbNetlist_getNumCoreCells;
*cellsBegin = *UCLAscriptc::dbNetlist_cellsBegin;
*cellsEnd = *UCLAscriptc::dbNetlist_cellsEnd;
*netsBegin = *UCLAscriptc::dbNetlist_netsBegin;
*netsEnd = *UCLAscriptc::dbNetlist_netsEnd;
*sNetsBegin = *UCLAscriptc::dbNetlist_sNetsBegin;
*sNetsEnd = *UCLAscriptc::dbNetlist_sNetsEnd;
*pinsBegin = *UCLAscriptc::dbNetlist_pinsBegin;
*pinsEnd = *UCLAscriptc::dbNetlist_pinsEnd;
*pinLibBegin = *UCLAscriptc::dbNetlist_pinLibBegin;
*pinLibEnd = *UCLAscriptc::dbNetlist_pinLibEnd;
*cellLibBegin = *UCLAscriptc::dbNetlist_cellLibBegin;
*cellLibEnd = *UCLAscriptc::dbNetlist_cellLibEnd;
sub getCellByIdx {
    my @args = @_;
    my $result = UCLAscriptc::dbNetlist_getCellByIdx(@args);
    return undef if (!defined($result));
    $dbCell::OWNER{$result} = 1; 
    my %resulthash;
    tie %resulthash, ref($result), $result;
    return bless \%resulthash, ref($result);
}
sub getNetByIdx {
    my @args = @_;
    my $result = UCLAscriptc::dbNetlist_getNetByIdx(@args);
    return undef if (!defined($result));
    $dbNet::OWNER{$result} = 1; 
    my %resulthash;
    tie %resulthash, ref($result), $result;
    return bless \%resulthash, ref($result);
}
sub getSNetByIdx {
    my @args = @_;
    my $result = UCLAscriptc::dbNetlist_getSNetByIdx(@args);
    return undef if (!defined($result));
    $dbNet::OWNER{$result} = 1; 
    my %resulthash;
    tie %resulthash, ref($result), $result;
    return bless \%resulthash, ref($result);
}
sub getPinByIdx {
    my @args = @_;
    my $result = UCLAscriptc::dbNetlist_getPinByIdx(@args);
    return undef if (!defined($result));
    $dbPin::OWNER{$result} = 1; 
    my %resulthash;
    tie %resulthash, ref($result), $result;
    return bless \%resulthash, ref($result);
}
*loopCellsBegin = *UCLAscriptc::dbNetlist_loopCellsBegin;
*loopCellsEnd = *UCLAscriptc::dbNetlist_loopCellsEnd;
*loopNetsBegin = *UCLAscriptc::dbNetlist_loopNetsBegin;
*loopNetsEnd = *UCLAscriptc::dbNetlist_loopNetsEnd;
*loopSNetsBegin = *UCLAscriptc::dbNetlist_loopSNetsBegin;
*loopSNetsEnd = *UCLAscriptc::dbNetlist_loopSNetsEnd;
*postProcess = *UCLAscriptc::dbNetlist_postProcess;
*processLGC = *UCLAscriptc::dbNetlist_processLGC;
*evalHalfPerimCost = *UCLAscriptc::dbNetlist_evalHalfPerimCost;
*evalWHalfPerimCost = *UCLAscriptc::dbNetlist_evalWHalfPerimCost;
*evalMSTCost = *UCLAscriptc::dbNetlist_evalMSTCost;
*evalHalfPerimCostNoPins = *UCLAscriptc::dbNetlist_evalHalfPerimCostNoPins;
*printNetStats = *UCLAscriptc::dbNetlist_printNetStats;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
    };

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
    };


############# Class : dbEasyAccess ##############

package dbEasyAccess;
@ISA = qw( UCLAscript );
%OWNER = ();
*IntRandom = *UCLAscriptc::dbEasyAccess_IntRandom;
*IntLessRandom = *UCLAscriptc::dbEasyAccess_IntLessRandom;
*populate = *UCLAscriptc::dbEasyAccess_populate;
*isConsistent = *UCLAscriptc::dbEasyAccess_isConsistent;
*getCellWidths = *UCLAscriptc::dbEasyAccess_getCellWidths;
*getCellAreas = *UCLAscriptc::dbEasyAccess_getCellAreas;
*getWhitespace = *UCLAscriptc::dbEasyAccess_getWhitespace;
*getNumPortLocations = *UCLAscriptc::dbEasyAccess_getNumPortLocations;
*getPortLocationByIdx = *UCLAscriptc::dbEasyAccess_getPortLocationByIdx;
*getNetIds = *UCLAscriptc::dbEasyAccess_getNetIds;
*getCoreCells = *UCLAscriptc::dbEasyAccess_getCoreCells;
*getCoreBBox = *UCLAscriptc::dbEasyAccess_getCoreBBox;
*getPin2CellIdx = *UCLAscriptc::dbEasyAccess_getPin2CellIdx;
*getCellIdxByPinIdx = *UCLAscriptc::dbEasyAccess_getCellIdxByPinIdx;
*getCoreCellArea = *UCLAscriptc::dbEasyAccess_getCoreCellArea;
*getTotalCellWidth = *UCLAscriptc::dbEasyAccess_getTotalCellWidth;
sub getCellByName {
    my @args = @_;
    my $result = UCLAscriptc::dbEasyAccess_getCellByName(@args);
    return undef if (!defined($result));
    $dbCell::OWNER{$result} = 1; 
    my %resulthash;
    tie %resulthash, ref($result), $result;
    return bless \%resulthash, ref($result);
}
sub getNetByName {
    my @args = @_;
    my $result = UCLAscriptc::dbEasyAccess_getNetByName(@args);
    return undef if (!defined($result));
    $dbNet::OWNER{$result} = 1; 
    my %resulthash;
    tie %resulthash, ref($result), $result;
    return bless \%resulthash, ref($result);
}
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
    };

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
    };


############# Class : dbSpatial ##############

package dbSpatial;
@ISA = qw( UCLAscript );
%OWNER = ();
%BLESSEDMEMBERS = (
);

%ITERATORS = ();
sub new {
    my $self = shift;
    my @args = @_;
    $self = UCLAscriptc::new_dbSpatial(@args);
    return undef if (!defined($self));
    bless $self, "dbSpatial";
    $OWNER{$self} = 1;
    my %retval;
    tie %retval, "dbSpatial", $self;
    return bless \%retval,"dbSpatial";
}

*getSize = *UCLAscriptc::dbSpatial_getSize;
*isConsistent = *UCLAscriptc::dbSpatial_isConsistent;
*reorderCells = *UCLAscriptc::dbSpatial_reorderCells;
*allCellsPlaced = *UCLAscriptc::dbSpatial_allCellsPlaced;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
    };

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
    };

sub FETCH {
    my ($self,$field) = @_;
    my $member_func = "UCLAscriptc::dbSpatial_${field}_get";
    my $val = &$member_func($self);
    if (exists $BLESSEDMEMBERS{$field}) {
        return undef if (!defined($val));
        my %retval;
        tie %retval,$BLESSEDMEMBERS{$field},$val;
        return bless \%retval, $BLESSEDMEMBERS{$field};
    }
    return $val;
}

sub STORE {
    my ($self,$field,$newval) = @_;
    my $member_func = "UCLAscriptc::dbSpatial_${field}_set";
    if (exists $BLESSEDMEMBERS{$field}) {
        &$member_func($self,tied(%{$newval}));
    } else {
        &$member_func($self,$newval);
    }
}

sub FIRSTKEY {
    my $self = shift;
    $ITERATORS{$self} = ['locations', 'locationValid', 'orientations', 'constraints', ];
    my $first = shift @{$ITERATORS{$self}};
    return $first;
}

sub NEXTKEY {
    my $self = shift;
    $nelem = scalar @{$ITERATORS{$self}};
    if ($nelem > 0) {
        my $member = shift @{$ITERATORS{$self}};
        return $member;
    } else {
        $ITERATORS{$self} = ['locations', 'locationValid', 'orientations', 'constraints', ];
        return ();
    }
}


############# Class : DB ##############

package DB;
@ISA = qw( UCLAscript );
%OWNER = ();
%BLESSEDMEMBERS = (
    spatial => 'dbSpatial',
    easyAccess => 'dbEasyAccess',
    timing => 'dbTemporal',
);

%ITERATORS = ();
sub new {
    my $self = shift;
    my @args = @_;
    $args[1] = tied(%{$args[1]});
    $self = UCLAscriptc::new_DB(@args);
    return undef if (!defined($self));
    bless $self, "DB";
    $OWNER{$self} = 1;
    my %retval;
    tie %retval, "DB", $self;
    return bless \%retval,"DB";
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        UCLAscriptc::delete_DB($self);
        delete $OWNER{$self};
    }
}

*isConsistent = *UCLAscriptc::DB_isConsistent;
*getOrigFileName = *UCLAscriptc::DB_getOrigFileName;
*getAuxName = *UCLAscriptc::DB_getAuxName;
*getDirName = *UCLAscriptc::DB_getDirName;
*getFileNames = *UCLAscriptc::DB_getFileNames;
*getOrigFileFormat = *UCLAscriptc::DB_getOrigFileFormat;
*getDelimiter = *UCLAscriptc::DB_getDelimiter;
sub getLayout {
    my @args = @_;
    my $result = UCLAscriptc::DB_getLayout(@args);
    return undef if (!defined($result));
    $dbContext::OWNER{$result} = 1; 
    my %resulthash;
    tie %resulthash, ref($result), $result;
    return bless \%resulthash, ref($result);
}
sub getNetlist {
    my @args = @_;
    my $result = UCLAscriptc::DB_getNetlist(@args);
    return undef if (!defined($result));
    $dbNetlist::OWNER{$result} = 1; 
    my %resulthash;
    tie %resulthash, ref($result), $result;
    return bless \%resulthash, ref($result);
}
sub getNetlistForSurgery {
    my @args = @_;
    my $result = UCLAscriptc::DB_getNetlistForSurgery(@args);
    return undef if (!defined($result));
    $dbNetlist::OWNER{$result} = 1; 
    my %resulthash;
    tie %resulthash, ref($result), $result;
    return bless \%resulthash, ref($result);
}
sub getTiming {
    my @args = @_;
    my $result = UCLAscriptc::DB_getTiming(@args);
    return undef if (!defined($result));
    $dbTemporal::OWNER{$result} = 1; 
    my %resulthash;
    tie %resulthash, ref($result), $result;
    return bless \%resulthash, ref($result);
}
*saveDEF = *UCLAscriptc::DB_saveDEF;
*saveXYLineDrawing = *UCLAscriptc::DB_saveXYLineDrawing;
*hasDesignName = *UCLAscriptc::DB_hasDesignName;
*hasTechnoName = *UCLAscriptc::DB_hasTechnoName;
*getDesignName = *UCLAscriptc::DB_getDesignName;
*getTechnoName = *UCLAscriptc::DB_getTechnoName;
*evalHPWLcost = *UCLAscriptc::DB_evalHPWLcost;
*evalWHPWLcost = *UCLAscriptc::DB_evalWHPWLcost;
*printNetStats = *UCLAscriptc::DB_printNetStats;
*locatePin = *UCLAscriptc::DB_locatePin;
*setPlaceAndOrient = *UCLAscriptc::DB_setPlaceAndOrient;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
    };

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
    };

sub FETCH {
    my ($self,$field) = @_;
    my $member_func = "UCLAscriptc::DB_${field}_get";
    my $val = &$member_func($self);
    if (exists $BLESSEDMEMBERS{$field}) {
        return undef if (!defined($val));
        my %retval;
        tie %retval,$BLESSEDMEMBERS{$field},$val;
        return bless \%retval, $BLESSEDMEMBERS{$field};
    }
    return $val;
}

sub STORE {
    my ($self,$field,$newval) = @_;
    my $member_func = "UCLAscriptc::DB_${field}_set";
    if (exists $BLESSEDMEMBERS{$field}) {
        &$member_func($self,tied(%{$newval}));
    } else {
        &$member_func($self,$newval);
    }
}

sub FIRSTKEY {
    my $self = shift;
    $ITERATORS{$self} = ['spatial', 'easyAccess', 'routedNets', 'timing', ];
    my $first = shift @{$ITERATORS{$self}};
    return $first;
}

sub NEXTKEY {
    my $self = shift;
    $nelem = scalar @{$ITERATORS{$self}};
    if ($nelem > 0) {
        my $member = shift @{$ITERATORS{$self}};
        return $member;
    } else {
        $ITERATORS{$self} = ['spatial', 'easyAccess', 'routedNets', 'timing', ];
        return ();
    }
}


############# Class : DB_Parameters ##############

package DB_Parameters;
@ISA = qw( UCLAscript );
%OWNER = ();
%BLESSEDMEMBERS = (
);

%ITERATORS = ();
sub new {
    my $self = shift;
    my @args = @_;
    $self = UCLAscriptc::new_DB_Parameters(@args);
    return undef if (!defined($self));
    bless $self, "DB_Parameters";
    $OWNER{$self} = 1;
    my %retval;
    tie %retval, "DB_Parameters", $self;
    return bless \%retval,"DB_Parameters";
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
    };

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
    };

sub FETCH {
    my ($self,$field) = @_;
    my $member_func = "UCLAscriptc::DB_Parameters_${field}_get";
    my $val = &$member_func($self);
    if (exists $BLESSEDMEMBERS{$field}) {
        return undef if (!defined($val));
        my %retval;
        tie %retval,$BLESSEDMEMBERS{$field},$val;
        return bless \%retval, $BLESSEDMEMBERS{$field};
    }
    return $val;
}

sub STORE {
    my ($self,$field,$newval) = @_;
    my $member_func = "UCLAscriptc::DB_Parameters_${field}_set";
    if (exists $BLESSEDMEMBERS{$field}) {
        &$member_func($self,tied(%{$newval}));
    } else {
        &$member_func($self,$newval);
    }
}

sub FIRSTKEY {
    my $self = shift;
    $ITERATORS{$self} = ['ignoreLogicalPins', 'ignoreGlobalRoutingInfo', 'ignoreDetailedRoutingInfo', 'ignoreTimingLibs', 'fixPlacedPads', 'verbose', 'routedDesign', 'alwaysCheckConsistency', 'placeHolder2', 'placeHolder3', 'placeHolder4', 'placeHolder5', ];
    my $first = shift @{$ITERATORS{$self}};
    return $first;
}

sub NEXTKEY {
    my $self = shift;
    $nelem = scalar @{$ITERATORS{$self}};
    if ($nelem > 0) {
        my $member = shift @{$ITERATORS{$self}};
        return $member;
    } else {
        $ITERATORS{$self} = ['ignoreLogicalPins', 'ignoreGlobalRoutingInfo', 'ignoreDetailedRoutingInfo', 'ignoreTimingLibs', 'fixPlacedPads', 'verbose', 'routedDesign', 'alwaysCheckConsistency', 'placeHolder2', 'placeHolder3', 'placeHolder4', 'placeHolder5', ];
        return ();
    }
}


############# Class : RBPlacement ##############

package RBPlacement;
@ISA = qw( UCLAscript );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $self = shift;
    my @args = @_;
    $args[1] = tied(%{$args[1]});
    $self = UCLAscriptc::new_RBPlacement(@args);
    return undef if (!defined($self));
    bless $self, "RBPlacement";
    $OWNER{$self} = 1;
    my %retval;
    tie %retval, "RBPlacement", $self;
    return bless \%retval,"RBPlacement";
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        UCLAscriptc::delete_RBPlacement($self);
        delete $OWNER{$self};
    }
}

*getOrigFileName = *UCLAscriptc::RBPlacement_getOrigFileName;
*getAuxName = *UCLAscriptc::RBPlacement_getAuxName;
*getDirName = *UCLAscriptc::RBPlacement_getDirName;
*getFileNames = *UCLAscriptc::RBPlacement_getFileNames;
*resetPlacementWOri = *UCLAscriptc::RBPlacement_resetPlacementWOri;
*resetPlacement = *UCLAscriptc::RBPlacement_resetPlacement;
*getNumCells = *UCLAscriptc::RBPlacement_getNumCells;
*isPopulated = *UCLAscriptc::RBPlacement_isPopulated;
*allCellsPlaced = *UCLAscriptc::RBPlacement_allCellsPlaced;
*numCellsNotPlaced = *UCLAscriptc::RBPlacement_numCellsNotPlaced;
*isCoreCell = *UCLAscriptc::RBPlacement_isCoreCell;
*isFixed = *UCLAscriptc::RBPlacement_isFixed;
*isStorElt = *UCLAscriptc::RBPlacement_isStorElt;
*isInSubRow = *UCLAscriptc::RBPlacement_isInSubRow;
*getFixed = *UCLAscriptc::RBPlacement_getFixed;
*getStorElts = *UCLAscriptc::RBPlacement_getStorElts;
*setLocation = *UCLAscriptc::RBPlacement_setLocation;
sub getOrient {
    my @args = @_;
    my $result = UCLAscriptc::RBPlacement_getOrient(@args);
    return undef if (!defined($result));
    $Orient::OWNER{$result} = 1; 
    my %resulthash;
    tie %resulthash, ref($result), $result;
    return bless \%resulthash, ref($result);
}
*setOrient = *UCLAscriptc::RBPlacement_setOrient;
*findCoreRow = *UCLAscriptc::RBPlacement_findCoreRow;
*findSubRow = *UCLAscriptc::RBPlacement_findSubRow;
*findBothRows = *UCLAscriptc::RBPlacement_findBothRows;
*coreRowsBegin = *UCLAscriptc::RBPlacement_coreRowsBegin;
*coreRowsEnd = *UCLAscriptc::RBPlacement_coreRowsEnd;
*getNumCoreRows = *UCLAscriptc::RBPlacement_getNumCoreRows;
*isCellInRow = *UCLAscriptc::RBPlacement_isCellInRow;
*getCellCoord = *UCLAscriptc::RBPlacement_getCellCoord;
*extractCellsFromSR = *UCLAscriptc::RBPlacement_extractCellsFromSR;
*embedCellsInSR = *UCLAscriptc::RBPlacement_embedCellsInSR;
*permuteCellsInSR = *UCLAscriptc::RBPlacement_permuteCellsInSR;
*placeTerms = *UCLAscriptc::RBPlacement_placeTerms;
*evalHPWL = *UCLAscriptc::RBPlacement_evalHPWL;
*evalMSTWL = *UCLAscriptc::RBPlacement_evalMSTWL;
*evalWeightedWL = *UCLAscriptc::RBPlacement_evalWeightedWL;
*evalNetsHPWL = *UCLAscriptc::RBPlacement_evalNetsHPWL;
*getHGraph = *UCLAscriptc::RBPlacement_getHGraph;
*isConsistent = *UCLAscriptc::RBPlacement_isConsistent;
*printRows = *UCLAscriptc::RBPlacement_printRows;
*saveAsSCL = *UCLAscriptc::RBPlacement_saveAsSCL;
*saveAsNodesNetsWts = *UCLAscriptc::RBPlacement_saveAsNodesNetsWts;
*saveAsNetDAre = *UCLAscriptc::RBPlacement_saveAsNetDAre;
*savePlacement = *UCLAscriptc::RBPlacement_savePlacement;
*saveAsSpatialConstraints = *UCLAscriptc::RBPlacement_saveAsSpatialConstraints;
*saveAsPlot = *UCLAscriptc::RBPlacement_saveAsPlot;
*remOverlaps = *UCLAscriptc::RBPlacement_remOverlaps;
*remOverlapsVert = *UCLAscriptc::RBPlacement_remOverlapsVert;
*permuteCellsAndWSInSR = *UCLAscriptc::RBPlacement_permuteCellsAndWSInSR;
*updateIronedCells = *UCLAscriptc::RBPlacement_updateIronedCells;
*updateIronedCellsLR = *UCLAscriptc::RBPlacement_updateIronedCellsLR;
*updateIronedCellsRL = *UCLAscriptc::RBPlacement_updateIronedCellsRL;
*calcInstHPWL = *UCLAscriptc::RBPlacement_calcInstHPWL;
*saveLEFDEF = *UCLAscriptc::RBPlacement_saveLEFDEF;
*getBBox = *UCLAscriptc::RBPlacement_getBBox;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
    };

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
    };


############# Class : RBPlacement_Parameters ##############

package RBPlacement_Parameters;
@ISA = qw( UCLAscript );
%OWNER = ();
%BLESSEDMEMBERS = (
);

%ITERATORS = ();
*EQUAL_SPACE = *UCLAscriptc::RBPlacement_Parameters_EQUAL_SPACE;
*WITH_PIN_ALG1 = *UCLAscriptc::RBPlacement_Parameters_WITH_PIN_ALG1;
*WITH_PIN_ALG2 = *UCLAscriptc::RBPlacement_Parameters_WITH_PIN_ALG2;
sub new {
    my $self = shift;
    my @args = @_;
    $self = UCLAscriptc::new_RBPlacement_Parameters(@args);
    return undef if (!defined($self));
    bless $self, "RBPlacement_Parameters";
    $OWNER{$self} = 1;
    my %retval;
    tie %retval, "RBPlacement_Parameters", $self;
    return bless \%retval,"RBPlacement_Parameters";
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
    };

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
    };

sub FETCH {
    my ($self,$field) = @_;
    my $member_func = "UCLAscriptc::RBPlacement_Parameters_${field}_get";
    my $val = &$member_func($self);
    if (exists $BLESSEDMEMBERS{$field}) {
        return undef if (!defined($val));
        my %retval;
        tie %retval,$BLESSEDMEMBERS{$field},$val;
        return bless \%retval, $BLESSEDMEMBERS{$field};
    }
    return $val;
}

sub STORE {
    my ($self,$field,$newval) = @_;
    my $member_func = "UCLAscriptc::RBPlacement_Parameters_${field}_set";
    if (exists $BLESSEDMEMBERS{$field}) {
        &$member_func($self,tied(%{$newval}));
    } else {
        &$member_func($self,$newval);
    }
}

sub FIRSTKEY {
    my $self = shift;
    $ITERATORS{$self} = ['verb', 'numRowsToRemove', 'spaceCellsAlg', 'remCongestion', ];
    my $first = shift @{$ITERATORS{$self}};
    return $first;
}

sub NEXTKEY {
    my $self = shift;
    $nelem = scalar @{$ITERATORS{$self}};
    if ($nelem > 0) {
        my $member = shift @{$ITERATORS{$self}};
        return $member;
    } else {
        $ITERATORS{$self} = ['verb', 'numRowsToRemove', 'spaceCellsAlg', 'remCongestion', ];
        return ();
    }
}


############# Class : CompareCellIdsByX ##############

package CompareCellIdsByX;
@ISA = qw( UCLAscript );
%OWNER = ();
sub new {
    my $self = shift;
    my @args = @_;
    $self = UCLAscriptc::new_CompareCellIdsByX(@args);
    return undef if (!defined($self));
    bless $self, "CompareCellIdsByX";
    $OWNER{$self} = 1;
    my %retval;
    tie %retval, "CompareCellIdsByX", $self;
    return bless \%retval,"CompareCellIdsByX";
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
    };

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
    };


############# Class : masterNodeInfo ##############

package masterNodeInfo;
@ISA = qw( UCLAscript );
%OWNER = ();
%BLESSEDMEMBERS = (
);

%ITERATORS = ();
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
    };

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
    };

sub FETCH {
    my ($self,$field) = @_;
    my $member_func = "UCLAscriptc::masterNodeInfo_${field}_get";
    my $val = &$member_func($self);
    if (exists $BLESSEDMEMBERS{$field}) {
        return undef if (!defined($val));
        my %retval;
        tie %retval,$BLESSEDMEMBERS{$field},$val;
        return bless \%retval, $BLESSEDMEMBERS{$field};
    }
    return $val;
}

sub STORE {
    my ($self,$field,$newval) = @_;
    my $member_func = "UCLAscriptc::masterNodeInfo_${field}_set";
    if (exists $BLESSEDMEMBERS{$field}) {
        &$member_func($self,tied(%{$newval}));
    } else {
        &$member_func($self,$newval);
    }
}

sub FIRSTKEY {
    my $self = shift;
    $ITERATORS{$self} = ['nodeInfo', 'name', 'index', 'pinNames', 'pinOffsets', ];
    my $first = shift @{$ITERATORS{$self}};
    return $first;
}

sub NEXTKEY {
    my $self = shift;
    $nelem = scalar @{$ITERATORS{$self}};
    if ($nelem > 0) {
        my $member = shift @{$ITERATORS{$self}};
        return $member;
    } else {
        $ITERATORS{$self} = ['nodeInfo', 'name', 'index', 'pinNames', 'pinOffsets', ];
        return ();
    }
}


############# Class : nodesMasInfo ##############

package nodesMasInfo;
@ISA = qw( UCLAscript );
%OWNER = ();
%BLESSEDMEMBERS = (
);

%ITERATORS = ();
sub new {
    my $self = shift;
    my @args = @_;
    $self = UCLAscriptc::new_nodesMasInfo(@args);
    return undef if (!defined($self));
    bless $self, "nodesMasInfo";
    $OWNER{$self} = 1;
    my %retval;
    tie %retval, "nodesMasInfo", $self;
    return bless \%retval,"nodesMasInfo";
}

*putIndex = *UCLAscriptc::nodesMasInfo_putIndex;
*getMasterIndex = *UCLAscriptc::nodesMasInfo_getMasterIndex;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
    };

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
    };

sub FETCH {
    my ($self,$field) = @_;
    my $member_func = "UCLAscriptc::nodesMasInfo_${field}_get";
    my $val = &$member_func($self);
    if (exists $BLESSEDMEMBERS{$field}) {
        return undef if (!defined($val));
        my %retval;
        tie %retval,$BLESSEDMEMBERS{$field},$val;
        return bless \%retval, $BLESSEDMEMBERS{$field};
    }
    return $val;
}

sub STORE {
    my ($self,$field,$newval) = @_;
    my $member_func = "UCLAscriptc::nodesMasInfo_${field}_set";
    if (exists $BLESSEDMEMBERS{$field}) {
        &$member_func($self,tied(%{$newval}));
    } else {
        &$member_func($self,$newval);
    }
}

sub FIRSTKEY {
    my $self = shift;
    $ITERATORS{$self} = ['masterNodeIndex', ];
    my $first = shift @{$ITERATORS{$self}};
    return $first;
}

sub NEXTKEY {
    my $self = shift;
    $nelem = scalar @{$ITERATORS{$self}};
    if ($nelem > 0) {
        my $member = shift @{$ITERATORS{$self}};
        return $member;
    } else {
        $ITERATORS{$self} = ['masterNodeIndex', ];
        return ();
    }
}


############# Class : CapoPlacer ##############

package CapoPlacer;
@ISA = qw( UCLAscript );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $self = shift;
    my @args = @_;
    $args[0] = tied(%{$args[0]});
    $args[1] = tied(%{$args[1]});
    $self = UCLAscriptc::new_CapoPlacer(@args);
    return undef if (!defined($self));
    bless $self, "CapoPlacer";
    $OWNER{$self} = 1;
    my %retval;
    tie %retval, "CapoPlacer", $self;
    return bless \%retval,"CapoPlacer";
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        UCLAscriptc::delete_CapoPlacer($self);
        delete $OWNER{$self};
    }
}

*estimateWL = *UCLAscriptc::CapoPlacer_estimateWL;
*getBBoxPerLayer = *UCLAscriptc::CapoPlacer_getBBoxPerLayer;
*getCutPerLayer = *UCLAscriptc::CapoPlacer_getCutPerLayer;
*getNodesInEachBlock = *UCLAscriptc::CapoPlacer_getNodesInEachBlock;
*getTerminalsToEachBlock = *UCLAscriptc::CapoPlacer_getTerminalsToEachBlock;
*getCellToBlockMap = *UCLAscriptc::CapoPlacer_getCellToBlockMap;
*getPinLocation = *UCLAscriptc::CapoPlacer_getPinLocation;
*getNetlistHGraph = *UCLAscriptc::CapoPlacer_getNetlistHGraph;
sub getParams {
    my @args = @_;
    my $result = UCLAscriptc::CapoPlacer_getParams(@args);
    return undef if (!defined($result));
    $CapoParameters::OWNER{$result} = 1; 
    my %resulthash;
    tie %resulthash, ref($result), $result;
    return bless \%resulthash, ref($result);
}
*getPlacement = *UCLAscriptc::CapoPlacer_getPlacement;
*printCutDensityStats = *UCLAscriptc::CapoPlacer_printCutDensityStats;
*printSmallProblemStats = *UCLAscriptc::CapoPlacer_printSmallProblemStats;
*printNetlistStats = *UCLAscriptc::CapoPlacer_printNetlistStats;
*getNetCutInfo = *UCLAscriptc::CapoPlacer_getNetCutInfo;
*getTotalNetCut = *UCLAscriptc::CapoPlacer_getTotalNetCut;
*getBlockMembership = *UCLAscriptc::CapoPlacer_getBlockMembership;
*printBlockMembership = *UCLAscriptc::CapoPlacer_printBlockMembership;
*getHierCellNames = *UCLAscriptc::CapoPlacer_getHierCellNames;
*printHierCellNames = *UCLAscriptc::CapoPlacer_printHierCellNames;
*saveSmallProblem = *UCLAscriptc::CapoPlacer_saveSmallProblem;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
    };

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
    };


############# Class : CapoSplitterParams ##############

package CapoSplitterParams;
@ISA = qw( UCLAscript );
%OWNER = ();
%BLESSEDMEMBERS = (
);

%ITERATORS = ();
sub new {
    my $self = shift;
    my @args = @_;
    $self = UCLAscriptc::new_CapoSplitterParams(@args);
    return undef if (!defined($self));
    bless $self, "CapoSplitterParams";
    $OWNER{$self} = 1;
    my %retval;
    tie %retval, "CapoSplitterParams", $self;
    return bless \%retval,"CapoSplitterParams";
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
    };

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
    };

sub FETCH {
    my ($self,$field) = @_;
    my $member_func = "UCLAscriptc::CapoSplitterParams_${field}_get";
    my $val = &$member_func($self);
    if (exists $BLESSEDMEMBERS{$field}) {
        return undef if (!defined($val));
        my %retval;
        tie %retval,$BLESSEDMEMBERS{$field},$val;
        return bless \%retval, $BLESSEDMEMBERS{$field};
    }
    return $val;
}

sub STORE {
    my ($self,$field,$newval) = @_;
    my $member_func = "UCLAscriptc::CapoSplitterParams_${field}_set";
    if (exists $BLESSEDMEMBERS{$field}) {
        &$member_func($self,tied(%{$newval}));
    } else {
        &$member_func($self,$newval);
    }
}

sub FIRSTKEY {
    my $self = shift;
    $ITERATORS{$self} = ['doRepartitioning', 'useWSTolMethod', 'constantTolerance', 'numMLSets', 'useNameHierarchy', 'delimiters', 'verb', ];
    my $first = shift @{$ITERATORS{$self}};
    return $first;
}

sub NEXTKEY {
    my $self = shift;
    $nelem = scalar @{$ITERATORS{$self}};
    if ($nelem > 0) {
        my $member = shift @{$ITERATORS{$self}};
        return $member;
    } else {
        $ITERATORS{$self} = ['doRepartitioning', 'useWSTolMethod', 'constantTolerance', 'numMLSets', 'useNameHierarchy', 'delimiters', 'verb', ];
        return ();
    }
}


############# Class : CapoParameters ##############

package CapoParameters;
@ISA = qw( UCLAscript );
%OWNER = ();
%BLESSEDMEMBERS = (
    splitterParams => 'CapoSplitterParams',
);

%ITERATORS = ();
sub new {
    my $self = shift;
    my @args = @_;
    $self = UCLAscriptc::new_CapoParameters(@args);
    return undef if (!defined($self));
    bless $self, "CapoParameters";
    $OWNER{$self} = 1;
    my %retval;
    tie %retval, "CapoParameters", $self;
    return bless \%retval,"CapoParameters";
}

*printHelp = *UCLAscriptc::CapoParameters_printHelp;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
    };

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
    };

sub FETCH {
    my ($self,$field) = @_;
    my $member_func = "UCLAscriptc::CapoParameters_${field}_get";
    my $val = &$member_func($self);
    if (exists $BLESSEDMEMBERS{$field}) {
        return undef if (!defined($val));
        my %retval;
        tie %retval,$BLESSEDMEMBERS{$field},$val;
        return bless \%retval, $BLESSEDMEMBERS{$field};
    }
    return $val;
}

sub STORE {
    my ($self,$field,$newval) = @_;
    my $member_func = "UCLAscriptc::CapoParameters_${field}_set";
    if (exists $BLESSEDMEMBERS{$field}) {
        &$member_func($self,tied(%{$newval}));
    } else {
        &$member_func($self,$newval);
    }
}

sub FIRSTKEY {
    my $self = shift;
    $ITERATORS{$self} = ['verb', 'stopAtBlocks', 'replaceSmallBlocks', 'useActualPinLocs', 'smallPartThreshold', 'smallPlaceThreshold', 'doOverlapping', 'startOverlappingLayer', 'endOverlappingLayer', 'propFromPl', 'useKPl', 'mlParams', 'smplParams', 'lookAhead', 'allowRowSplits', 'splitterParams', 'plotBlocks', 'saveLayerBBoxes', 'saveBlocks', 'saveSmallPlProb', ];
    my $first = shift @{$ITERATORS{$self}};
    return $first;
}

sub NEXTKEY {
    my $self = shift;
    $nelem = scalar @{$ITERATORS{$self}};
    if ($nelem > 0) {
        my $member = shift @{$ITERATORS{$self}};
        return $member;
    } else {
        $ITERATORS{$self} = ['verb', 'stopAtBlocks', 'replaceSmallBlocks', 'useActualPinLocs', 'smallPartThreshold', 'smallPlaceThreshold', 'doOverlapping', 'startOverlappingLayer', 'endOverlappingLayer', 'propFromPl', 'useKPl', 'mlParams', 'smplParams', 'lookAhead', 'allowRowSplits', 'splitterParams', 'plotBlocks', 'saveLayerBBoxes', 'saveBlocks', 'saveSmallPlProb', ];
        return ();
    }
}


############# Class : MetaPlacerParams ##############

package MetaPlacerParams;
@ISA = qw( UCLAscript );
%OWNER = ();
%BLESSEDMEMBERS = (
);

%ITERATORS = ();
sub new {
    my $self = shift;
    my @args = @_;
    $self = UCLAscriptc::new_MetaPlacerParams(@args);
    return undef if (!defined($self));
    bless $self, "MetaPlacerParams";
    $OWNER{$self} = 1;
    my %retval;
    tie %retval, "MetaPlacerParams", $self;
    return bless \%retval,"MetaPlacerParams";
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
    };

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
    };

sub FETCH {
    my ($self,$field) = @_;
    my $member_func = "UCLAscriptc::MetaPlacerParams_${field}_get";
    my $val = &$member_func($self);
    if (exists $BLESSEDMEMBERS{$field}) {
        return undef if (!defined($val));
        my %retval;
        tie %retval,$BLESSEDMEMBERS{$field},$val;
        return bless \%retval, $BLESSEDMEMBERS{$field};
    }
    return $val;
}

sub STORE {
    my ($self,$field,$newval) = @_;
    my $member_func = "UCLAscriptc::MetaPlacerParams_${field}_set";
    if (exists $BLESSEDMEMBERS{$field}) {
        &$member_func($self,tied(%{$newval}));
    } else {
        &$member_func($self,$newval);
    }
}

sub FIRSTKEY {
    my $self = shift;
    $ITERATORS{$self} = ['verb', 'save', 'flip', 'skipRowIroning', ];
    my $first = shift @{$ITERATORS{$self}};
    return $first;
}

sub NEXTKEY {
    my $self = shift;
    $nelem = scalar @{$ITERATORS{$self}};
    if ($nelem > 0) {
        my $member = shift @{$ITERATORS{$self}};
        return $member;
    } else {
        $ITERATORS{$self} = ['verb', 'save', 'flip', 'skipRowIroning', ];
        return ();
    }
}


############# Class : MetaPlacer ##############

package MetaPlacer;
@ISA = qw( UCLAscript );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $self = shift;
    my @args = @_;
    $args[0] = tied(%{$args[0]});
    $args[1] = tied(%{$args[1]});
    $self = UCLAscriptc::new_MetaPlacer(@args);
    return undef if (!defined($self));
    bless $self, "MetaPlacer";
    $OWNER{$self} = 1;
    my %retval;
    tie %retval, "MetaPlacer", $self;
    return bless \%retval,"MetaPlacer";
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        UCLAscriptc::delete_MetaPlacer($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
    };

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
    };


############# Class : PartitioningProblem ##############

package PartitioningProblem;
@ISA = qw( UCLAscript );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $self = shift;
    my @args = @_;
    $args[0] = tied(%{$args[0]});
    $args[1] = tied(%{$args[1]});
    $args[2] = tied(%{$args[2]});
    $args[8] = tied(%{$args[8]});
    $self = UCLAscriptc::new_PartitioningProblem(@args);
    return undef if (!defined($self));
    bless $self, "PartitioningProblem";
    $OWNER{$self} = 1;
    my %retval;
    tie %retval, "PartitioningProblem", $self;
    return bless \%retval,"PartitioningProblem";
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        UCLAscriptc::delete_PartitioningProblem($self);
        delete $OWNER{$self};
    }
}

*propagateTerminals = *UCLAscriptc::PartitioningProblem_propagateTerminals;
*saveAsNetDAre = *UCLAscriptc::PartitioningProblem_saveAsNetDAre;
*saveAsNodesNets = *UCLAscriptc::PartitioningProblem_saveAsNodesNets;
*saveBestSol = *UCLAscriptc::PartitioningProblem_saveBestSol;
*reserveBuffers = *UCLAscriptc::PartitioningProblem_reserveBuffers;
*isDataOwned = *UCLAscriptc::PartitioningProblem_isDataOwned;
*partsComeFromGrid = *UCLAscriptc::PartitioningProblem_partsComeFromGrid;
*getNumXParts = *UCLAscriptc::PartitioningProblem_getNumXParts;
*getNumYParts = *UCLAscriptc::PartitioningProblem_getNumYParts;
*getXTics = *UCLAscriptc::PartitioningProblem_getXTics;
*getYTics = *UCLAscriptc::PartitioningProblem_getYTics;
sub getHGraph {
    my @args = @_;
    my $result = UCLAscriptc::PartitioningProblem_getHGraph(@args);
    return undef if (!defined($result));
    $HGraphFixed::OWNER{$result} = 1; 
    my %resulthash;
    tie %resulthash, ref($result), $result;
    return bless \%resulthash, ref($result);
}
sub getHGraphPointer {
    my @args = @_;
    my $result = UCLAscriptc::PartitioningProblem_getHGraphPointer(@args);
    return undef if (!defined($result));
    my %resulthash;
    tie %resulthash, ref($result), $result;
    return bless \%resulthash, ref($result);
}
sub getParameters {
    my @args = @_;
    my $result = UCLAscriptc::PartitioningProblem_getParameters(@args);
    return undef if (!defined($result));
    $PartitioningProblem_Parameters::OWNER{$result} = 1; 
    my %resulthash;
    tie %resulthash, ref($result), $result;
    return bless \%resulthash, ref($result);
}
sub getSolnBuffers {
    my @args = @_;
    my $result = UCLAscriptc::PartitioningProblem_getSolnBuffers(@args);
    return undef if (!defined($result));
    $PartitioningBuffer::OWNER{$result} = 1; 
    my %resulthash;
    tie %resulthash, ref($result), $result;
    return bless \%resulthash, ref($result);
}
sub getBestSoln {
    my @args = @_;
    my $result = UCLAscriptc::PartitioningProblem_getBestSoln(@args);
    return undef if (!defined($result));
    $Partitioning::OWNER{$result} = 1; 
    my %resulthash;
    tie %resulthash, ref($result), $result;
    return bless \%resulthash, ref($result);
}
*setSolnBuffers = *UCLAscriptc::PartitioningProblem_setSolnBuffers;
sub swapOutSolnBuffers {
    my @args = @_;
    my $result = UCLAscriptc::PartitioningProblem_swapOutSolnBuffers(@args);
    return undef if (!defined($result));
    my %resulthash;
    tie %resulthash, ref($result), $result;
    return bless \%resulthash, ref($result);
}
sub swapOutFixedConst {
    my @args = @_;
    my $result = UCLAscriptc::PartitioningProblem_swapOutFixedConst(@args);
    return undef if (!defined($result));
    my %resulthash;
    tie %resulthash, ref($result), $result;
    return bless \%resulthash, ref($result);
}
sub swapOutHGraph {
    my @args = @_;
    my $result = UCLAscriptc::PartitioningProblem_swapOutHGraph(@args);
    return undef if (!defined($result));
    my %resulthash;
    tie %resulthash, ref($result), $result;
    return bless \%resulthash, ref($result);
}
*getCosts = *UCLAscriptc::PartitioningProblem_getCosts;
*getViolations = *UCLAscriptc::PartitioningProblem_getViolations;
*getImbalances = *UCLAscriptc::PartitioningProblem_getImbalances;
sub getFixedConstr {
    my @args = @_;
    my $result = UCLAscriptc::PartitioningProblem_getFixedConstr(@args);
    return undef if (!defined($result));
    $Partitioning::OWNER{$result} = 1; 
    my %resulthash;
    tie %resulthash, ref($result), $result;
    return bless \%resulthash, ref($result);
}
*getCapacities = *UCLAscriptc::PartitioningProblem_getCapacities;
*getMaxCapacities = *UCLAscriptc::PartitioningProblem_getMaxCapacities;
*getMinCapacities = *UCLAscriptc::PartitioningProblem_getMinCapacities;
*getTotalWeight = *UCLAscriptc::PartitioningProblem_getTotalWeight;
*getPartitions = *UCLAscriptc::PartitioningProblem_getPartitions;
*getPartitionCenters = *UCLAscriptc::PartitioningProblem_getPartitionCenters;
*getScalingFactorForBBoxQuantization = *UCLAscriptc::PartitioningProblem_getScalingFactorForBBoxQuantization;
*getPadBlocks = *UCLAscriptc::PartitioningProblem_getPadBlocks;
*getPadBlockCenters = *UCLAscriptc::PartitioningProblem_getPadBlockCenters;
*getTerminalToBlock = *UCLAscriptc::PartitioningProblem_getTerminalToBlock;
*getNumPartitions = *UCLAscriptc::PartitioningProblem_getNumPartitions;
*getBestSolnNum = *UCLAscriptc::PartitioningProblem_getBestSolnNum;
*setBestSolnNum = *UCLAscriptc::PartitioningProblem_setBestSolnNum;
*printLargestCellStats = *UCLAscriptc::PartitioningProblem_printLargestCellStats;
*getPinBalances = *UCLAscriptc::PartitioningProblem_getPinBalances;
*printPinBalances = *UCLAscriptc::PartitioningProblem_printPinBalances;
sub getAttributes {
    my @args = @_;
    my $result = UCLAscriptc::PartitioningProblem_getAttributes(@args);
    return undef if (!defined($result));
    $PartitioningProblem_Attributes::OWNER{$result} = 1; 
    my %resulthash;
    tie %resulthash, ref($result), $result;
    return bless \%resulthash, ref($result);
}
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
    };

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
    };


############# Class : PartitioningProblem_Parameters ##############

package PartitioningProblem_Parameters;
@ISA = qw( UCLAscript );
%OWNER = ();
%BLESSEDMEMBERS = (
);

%ITERATORS = ();
sub new {
    my $self = shift;
    my @args = @_;
    $self = UCLAscriptc::new_PartitioningProblem_Parameters(@args);
    return undef if (!defined($self));
    bless $self, "PartitioningProblem_Parameters";
    $OWNER{$self} = 1;
    my %retval;
    tie %retval, "PartitioningProblem_Parameters", $self;
    return bless \%retval,"PartitioningProblem_Parameters";
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
    };

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
    };

sub FETCH {
    my ($self,$field) = @_;
    my $member_func = "UCLAscriptc::PartitioningProblem_Parameters_${field}_get";
    my $val = &$member_func($self);
    if (exists $BLESSEDMEMBERS{$field}) {
        return undef if (!defined($val));
        my %retval;
        tie %retval,$BLESSEDMEMBERS{$field},$val;
        return bless \%retval, $BLESSEDMEMBERS{$field};
    }
    return $val;
}

sub STORE {
    my ($self,$field,$newval) = @_;
    my $member_func = "UCLAscriptc::PartitioningProblem_Parameters_${field}_set";
    if (exists $BLESSEDMEMBERS{$field}) {
        &$member_func($self,tied(%{$newval}));
    } else {
        &$member_func($self,$newval);
    }
}

sub FIRSTKEY {
    my $self = shift;
    $ITERATORS{$self} = ['verbosity', ];
    my $first = shift @{$ITERATORS{$self}};
    return $first;
}

sub NEXTKEY {
    my $self = shift;
    $nelem = scalar @{$ITERATORS{$self}};
    if ($nelem > 0) {
        my $member = shift @{$ITERATORS{$self}};
        return $member;
    } else {
        $ITERATORS{$self} = ['verbosity', ];
        return ();
    }
}


############# Class : PartitioningProblem_Attributes ##############

package PartitioningProblem_Attributes;
@ISA = qw( UCLAscript );
%OWNER = ();
%BLESSEDMEMBERS = (
);

%ITERATORS = ();
sub new {
    my $self = shift;
    my @args = @_;
    $self = UCLAscriptc::new_PartitioningProblem_Attributes(@args);
    return undef if (!defined($self));
    bless $self, "PartitioningProblem_Attributes";
    $OWNER{$self} = 1;
    my %retval;
    tie %retval, "PartitioningProblem_Attributes", $self;
    return bless \%retval,"PartitioningProblem_Attributes";
}

*clearAll = *UCLAscriptc::PartitioningProblem_Attributes_clearAll;
*setAll = *UCLAscriptc::PartitioningProblem_Attributes_setAll;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
    };

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
    };

sub FETCH {
    my ($self,$field) = @_;
    my $member_func = "UCLAscriptc::PartitioningProblem_Attributes_${field}_get";
    my $val = &$member_func($self);
    if (exists $BLESSEDMEMBERS{$field}) {
        return undef if (!defined($val));
        my %retval;
        tie %retval,$BLESSEDMEMBERS{$field},$val;
        return bless \%retval, $BLESSEDMEMBERS{$field};
    }
    return $val;
}

sub STORE {
    my ($self,$field,$newval) = @_;
    my $member_func = "UCLAscriptc::PartitioningProblem_Attributes_${field}_set";
    if (exists $BLESSEDMEMBERS{$field}) {
        &$member_func($self,tied(%{$newval}));
    } else {
        &$member_func($self,$newval);
    }
}

sub FIRSTKEY {
    my $self = shift;
    $ITERATORS{$self} = ['hasMaxCap', 'hasMinCap', 'hasCap', 'hasPartBBoxes', 'hasPadBBoxes', 'hasPartCenters', 'hasPadCenters', 'hasTotalWeight', 'hasClusterDegrees', ];
    my $first = shift @{$ITERATORS{$self}};
    return $first;
}

sub NEXTKEY {
    my $self = shift;
    $nelem = scalar @{$ITERATORS{$self}};
    if ($nelem > 0) {
        my $member = shift @{$ITERATORS{$self}};
        return $member;
    } else {
        $ITERATORS{$self} = ['hasMaxCap', 'hasMinCap', 'hasCap', 'hasPartBBoxes', 'hasPadBBoxes', 'hasPartCenters', 'hasPadCenters', 'hasTotalWeight', 'hasClusterDegrees', ];
        return ();
    }
}


############# Class : BaseMLPart ##############

package BaseMLPart;
@ISA = qw( UCLAscript );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $self = shift;
    my @args = @_;
    $args[0] = tied(%{$args[0]});
    $args[1] = tied(%{$args[1]});
    $args[2] = tied(%{$args[2]});
    $self = UCLAscriptc::new_BaseMLPart(@args);
    return undef if (!defined($self));
    bless $self, "BaseMLPart";
    $OWNER{$self} = 1;
    my %retval;
    tie %retval, "BaseMLPart", $self;
    return bless \%retval,"BaseMLPart";
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        UCLAscriptc::delete_BaseMLPart($self);
        delete $OWNER{$self};
    }
}

*getPartitionArea = *UCLAscriptc::BaseMLPart_getPartitionArea;
*getPartitionRatio = *UCLAscriptc::BaseMLPart_getPartitionRatio;
*getBestSolnCost = *UCLAscriptc::BaseMLPart_getBestSolnCost;
*getAveSolnCost = *UCLAscriptc::BaseMLPart_getAveSolnCost;
*getNumLegalSolns = *UCLAscriptc::BaseMLPart_getNumLegalSolns;
*getUserTime = *UCLAscriptc::BaseMLPart_getUserTime;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
    };

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
    };


############# Class : BaseMLPart_Parameters ##############

package BaseMLPart_Parameters;
@ISA = qw( UCLAscript );
%OWNER = ();
%BLESSEDMEMBERS = (
);

%ITERATORS = ();
*NeverSave = *UCLAscriptc::BaseMLPart_Parameters_NeverSave;
*AtAllLastLevels = *UCLAscriptc::BaseMLPart_Parameters_AtAllLastLevels;
*AtAllLevels = *UCLAscriptc::BaseMLPart_Parameters_AtAllLevels;
*AtFirstLevelOfFirst = *UCLAscriptc::BaseMLPart_Parameters_AtFirstLevelOfFirst;
*AtLastLevelOfFirst = *UCLAscriptc::BaseMLPart_Parameters_AtLastLevelOfFirst;
*AtAllLevelsOfFirst = *UCLAscriptc::BaseMLPart_Parameters_AtAllLevelsOfFirst;
*NoVcycles = *UCLAscriptc::BaseMLPart_Parameters_NoVcycles;
*Exclusive = *UCLAscriptc::BaseMLPart_Parameters_Exclusive;
*Relaxed = *UCLAscriptc::BaseMLPart_Parameters_Relaxed;
*Relaxed2 = *UCLAscriptc::BaseMLPart_Parameters_Relaxed2;
*Comprehensive = *UCLAscriptc::BaseMLPart_Parameters_Comprehensive;
*ALL = *UCLAscriptc::BaseMLPart_Parameters_ALL;
*TOPONLY = *UCLAscriptc::BaseMLPart_Parameters_TOPONLY;
*ALLBUTLAST = *UCLAscriptc::BaseMLPart_Parameters_ALLBUTLAST;
*NEVER = *UCLAscriptc::BaseMLPart_Parameters_NEVER;
sub new {
    my $self = shift;
    my @args = @_;
    $self = UCLAscriptc::new_BaseMLPart_Parameters(@args);
    return undef if (!defined($self));
    bless $self, "BaseMLPart_Parameters";
    $OWNER{$self} = 1;
    my %retval;
    tie %retval, "BaseMLPart_Parameters", $self;
    return bless \%retval,"BaseMLPart_Parameters";
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
    };

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
    };

sub FETCH {
    my ($self,$field) = @_;
    my $member_func = "UCLAscriptc::BaseMLPart_Parameters_${field}_get";
    my $val = &$member_func($self);
    if (exists $BLESSEDMEMBERS{$field}) {
        return undef if (!defined($val));
        my %retval;
        tie %retval,$BLESSEDMEMBERS{$field},$val;
        return bless \%retval, $BLESSEDMEMBERS{$field};
    }
    return $val;
}

sub STORE {
    my ($self,$field,$newval) = @_;
    my $member_func = "UCLAscriptc::BaseMLPart_Parameters_${field}_set";
    if (exists $BLESSEDMEMBERS{$field}) {
        &$member_func($self,tied(%{$newval}));
    } else {
        &$member_func($self,$newval);
    }
}

sub FIRSTKEY {
    my $self = shift;
    $ITERATORS{$self} = ['savePartProb', 'flatPartitioner', 'useBBonTop', 'partFuzziness', 'runsPerClTree', 'solnPoolOnTopLevel', 'toleranceMultiple', 'toleranceAlpha', 'useTwoPartCalls', 'netThreshold', 'Vcycling', 'timeLimit', 'expPrint2Costs', 'clusterToTerminals', 'seedTopLvlSoln', 'pruningPercent', 'pruningPoint', 'maxNumPassesAtBottom', 'vcNumFailures', 'vcImproveRatio', 'vc1ClusterRatio', 'vc1FirstLevel', 'vc1LevelGrowth', 'vc2ClusterRatio', 'vc2FirstLevel', 'vc2LevelGrowth', 'clParams', ];
    my $first = shift @{$ITERATORS{$self}};
    return $first;
}

sub NEXTKEY {
    my $self = shift;
    $nelem = scalar @{$ITERATORS{$self}};
    if ($nelem > 0) {
        my $member = shift @{$ITERATORS{$self}};
        return $member;
    } else {
        $ITERATORS{$self} = ['savePartProb', 'flatPartitioner', 'useBBonTop', 'partFuzziness', 'runsPerClTree', 'solnPoolOnTopLevel', 'toleranceMultiple', 'toleranceAlpha', 'useTwoPartCalls', 'netThreshold', 'Vcycling', 'timeLimit', 'expPrint2Costs', 'clusterToTerminals', 'seedTopLvlSoln', 'pruningPercent', 'pruningPoint', 'maxNumPassesAtBottom', 'vcNumFailures', 'vcImproveRatio', 'vc1ClusterRatio', 'vc1FirstLevel', 'vc1LevelGrowth', 'vc2ClusterRatio', 'vc2FirstLevel', 'vc2LevelGrowth', 'clParams', ];
        return ();
    }
}


############# Class : MLPart ##############

package MLPart;
@ISA = qw( UCLAscript BaseMLPart );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $self = shift;
    my @args = @_;
    $args[0] = tied(%{$args[0]});
    $args[1] = tied(%{$args[1]});
    $args[2] = tied(%{$args[2]});
    $self = UCLAscriptc::new_MLPart(@args);
    return undef if (!defined($self));
    bless $self, "MLPart";
    $OWNER{$self} = 1;
    my %retval;
    tie %retval, "MLPart", $self;
    return bless \%retval,"MLPart";
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        UCLAscriptc::delete_MLPart($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
    };

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
    };


############# Class : HGraphFixed ##############

package HGraphFixed;
@ISA = qw( UCLAscript );
%OWNER = ();
%BLESSEDMEMBERS = (
);

%ITERATORS = ();
sub new {
    my $self = shift;
    my @args = @_;
    $self = UCLAscriptc::new_HGraphFixed(@args);
    return undef if (!defined($self));
    bless $self, "HGraphFixed";
    $OWNER{$self} = 1;
    my %retval;
    tie %retval, "HGraphFixed", $self;
    return bless \%retval,"HGraphFixed";
}

*getNumNodes = *UCLAscriptc::HGraphFixed_getNumNodes;
*getNumEdges = *UCLAscriptc::HGraphFixed_getNumEdges;
*getAvgNodeDegree = *UCLAscriptc::HGraphFixed_getAvgNodeDegree;
*getAvgEdgeDegree = *UCLAscriptc::HGraphFixed_getAvgEdgeDegree;
*nodesBegin = *UCLAscriptc::HGraphFixed_nodesBegin;
*nodesEnd = *UCLAscriptc::HGraphFixed_nodesEnd;
*terminalsBegin = *UCLAscriptc::HGraphFixed_terminalsBegin;
*terminalsEnd = *UCLAscriptc::HGraphFixed_terminalsEnd;
*edgesBegin = *UCLAscriptc::HGraphFixed_edgesBegin;
*edgesEnd = *UCLAscriptc::HGraphFixed_edgesEnd;
*getNodeByIdx = *UCLAscriptc::HGraphFixed_getNodeByIdx;
*haveSuchNode = *UCLAscriptc::HGraphFixed_haveSuchNode;
*haveSuchNet = *UCLAscriptc::HGraphFixed_haveSuchNet;
*getNodeByName = *UCLAscriptc::HGraphFixed_getNodeByName;
*getNetByName = *UCLAscriptc::HGraphFixed_getNetByName;
*getEdgeByIdx = *UCLAscriptc::HGraphFixed_getEdgeByIdx;
*getNodesSortedByWeights = *UCLAscriptc::HGraphFixed_getNodesSortedByWeights;
*getNodesSortedByDegrees = *UCLAscriptc::HGraphFixed_getNodesSortedByDegrees;
*maxNodeIndex = *UCLAscriptc::HGraphFixed_maxNodeIndex;
*maxEdgeIndex = *UCLAscriptc::HGraphFixed_maxEdgeIndex;
*addEdge = *UCLAscriptc::HGraphFixed_addEdge;
*fastAddEdge = *UCLAscriptc::HGraphFixed_fastAddEdge;
*adviseNodeDegrees = *UCLAscriptc::HGraphFixed_adviseNodeDegrees;
*finalize = *UCLAscriptc::HGraphFixed_finalize;
*saveAsNetDAre = *UCLAscriptc::HGraphFixed_saveAsNetDAre;
*saveAsNodesNetsWts = *UCLAscriptc::HGraphFixed_saveAsNodesNetsWts;
*isConsistent = *UCLAscriptc::HGraphFixed_isConsistent;
*sortAsDB = *UCLAscriptc::HGraphFixed_sortAsDB;
*printEdgeSizeStats = *UCLAscriptc::HGraphFixed_printEdgeSizeStats;
*printEdgeWtStats = *UCLAscriptc::HGraphFixed_printEdgeWtStats;
*printNodeWtStats = *UCLAscriptc::HGraphFixed_printNodeWtStats;
*printNodeDegreeStats = *UCLAscriptc::HGraphFixed_printNodeDegreeStats;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
    };

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
    };

sub FETCH {
    my ($self,$field) = @_;
    my $member_func = "UCLAscriptc::HGraphFixed_${field}_get";
    my $val = &$member_func($self);
    if (exists $BLESSEDMEMBERS{$field}) {
        return undef if (!defined($val));
        my %retval;
        tie %retval,$BLESSEDMEMBERS{$field},$val;
        return bless \%retval, $BLESSEDMEMBERS{$field};
    }
    return $val;
}

sub STORE {
    my ($self,$field,$newval) = @_;
    my $member_func = "UCLAscriptc::HGraphFixed_${field}_set";
    if (exists $BLESSEDMEMBERS{$field}) {
        &$member_func($self,tied(%{$newval}));
    } else {
        &$member_func($self,$newval);
    }
}

sub FIRSTKEY {
    my $self = shift;
    $ITERATORS{$self} = ['_nodeNames', '_netNames', '_nodeNamesMap', '_netNamesMap', ];
    my $first = shift @{$ITERATORS{$self}};
    return $first;
}

sub NEXTKEY {
    my $self = shift;
    $nelem = scalar @{$ITERATORS{$self}};
    if ($nelem > 0) {
        my $member = shift @{$ITERATORS{$self}};
        return $member;
    } else {
        $ITERATORS{$self} = ['_nodeNames', '_netNames', '_nodeNamesMap', '_netNamesMap', ];
        return ();
    }
}


############# Class : HGfromDB ##############

package HGfromDB;
@ISA = qw( UCLAscript HGraphFixed );
%OWNER = ();
%BLESSEDMEMBERS = (
);

%ITERATORS = ();
sub new {
    my $self = shift;
    my @args = @_;
    $args[0] = tied(%{$args[0]});
    $self = UCLAscriptc::new_HGfromDB(@args);
    return undef if (!defined($self));
    bless $self, "HGfromDB";
    $OWNER{$self} = 1;
    my %retval;
    tie %retval, "HGfromDB", $self;
    return bless \%retval,"HGfromDB";
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
    };

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
    };

sub FETCH {
    my ($self,$field) = @_;
    my $member_func = "UCLAscriptc::HGfromDB_${field}_get";
    my $val = &$member_func($self);
    if (exists $BLESSEDMEMBERS{$field}) {
        return undef if (!defined($val));
        my %retval;
        tie %retval,$BLESSEDMEMBERS{$field},$val;
        return bless \%retval, $BLESSEDMEMBERS{$field};
    }
    return $val;
}

sub STORE {
    my ($self,$field,$newval) = @_;
    my $member_func = "UCLAscriptc::HGfromDB_${field}_set";
    if (exists $BLESSEDMEMBERS{$field}) {
        &$member_func($self,tied(%{$newval}));
    } else {
        &$member_func($self,$newval);
    }
}

sub FIRSTKEY {
    my $self = shift;
    $ITERATORS{$self} = ['_nodeNames', '_netNames', '_nodeNamesMap', '_netNamesMap', ];
    my $first = shift @{$ITERATORS{$self}};
    return $first;
}

sub NEXTKEY {
    my $self = shift;
    $nelem = scalar @{$ITERATORS{$self}};
    if ($nelem > 0) {
        my $member = shift @{$ITERATORS{$self}};
        return $member;
    } else {
        $ITERATORS{$self} = ['_nodeNames', '_netNames', '_nodeNamesMap', '_netNamesMap', ];
        return ();
    }
}


# ------- VARIABLE STUBS --------

package UCLAscript;

*DumbPlacerSeed = *UCLAscriptc::DumbPlacerSeed;
*BaryPlacerSeed = *UCLAscriptc::BaryPlacerSeed;
*WeiszPlacerSeed = *UCLAscriptc::WeiszPlacerSeed;
*Never = *UCLAscriptc::Never;
*AtTheEnd = *UCLAscriptc::AtTheEnd;
*AtEveryLayer = *UCLAscriptc::AtEveryLayer;
1;
